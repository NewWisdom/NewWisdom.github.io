<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>NewWisdom.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>블로그 이사중... 아직 정리가 안되었음...</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>📋 Kotlin을 정복해봅시다 2</title>
	  <link>//kotlin2</link>
	  <author></author>
	  <pubDate>2021-05-26T19:18:00+09:00</pubDate>
	  <guid>//kotlin2</guid>
	  <description><![CDATA[
	     <h2 id="코틀린-dsl">코틀린 DSL</h2>

<h3 id="dls란">DLS란?</h3>

<ul>
  <li>도메인 특화 언어 (Domain-specific language) ↔️ 범용 프로그래밍 언어</li>
  <li>선언적 언어</li>
  <li>세부 실행은 언어를 해석하는 엔진에 맡김</li>
  <li>컴파일 시점에 제대로 검증하는 것이 어려움</li>
</ul>

<h3 id="코틀린-dsl이란">코틀린 DSL이란?</h3>

<ul>
  <li>범용 언어(= 코틀린)로 작성된 프로그램의 일부</li>
  <li>범용 언어와 동일한 문법 사용</li>
  <li>호출 결과를 객체로 변환하기 위해 노력할 필요 없음</li>
  <li>타입 안정성 보장</li>
</ul>

<h3 id="코틀린은-간결한-구문을-어떻게-지원하는가">코틀린은 간결한 구문을 어떻게 지원하는가?</h3>

<ul>
  <li>확장 함수</li>
  <li>중위 호출</li>
  <li>연산자 오버로딩</li>
  <li>get 메서드에 대한 관례</li>
  <li>람다를 괄호 밖으로 빼는 관례</li>
  <li>수신 객체 지정 람다</li>
</ul>

<h3 id="확장-함수-extension-functions">확장 함수 Extension functions</h3>

<ul>
  <li>코틀린은 클래스를 확장해서 새로운 기능을 개발할 수 있도록 지원</li>
  <li><code class="highlighter-rouge">상속</code> 과는 조금 다른 개념</li>
  <li>ex) 외부 라이브러리를 사용할 때 이 자체 클래스는 변경할 수  없지만 이를 확장해 원하는 새로운 함수를 만들 수 있음</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"Kotlin"</span><span class="p">.</span><span class="n">lastChar</span><span class="p">()</span>

<span class="k">fun</span> <span class="nf">String</span><span class="p">.</span><span class="n">lastChar</span><span class="p">():</span> <span class="n">Char</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">length</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="중위-표기-infix-notation">중위 표기 Infix notation</h3>

<h4 id="중위표기법">중위표기법?</h4>

<p><strong>infix(중위표기법)</strong> : 일상생활에서의 수식 표기법으로 두 개의 피연산자 사이에 연산자가 존재하는 표현방식이다.  ex) X + Y</p>

<p>Kotlin에서 <code class="highlighter-rouge">infix</code> 키워드를 사용하여 중위표기법으로 함수를 호출할 수 있다. 단, 아래 요건을 충족해야 한다.</p>

<ul>
  <li>They must be member functions or extension functions. (멤버 함수 혹은 확장 함수일 때)</li>
  <li>They must have a single parameter. (단일 매개 변수일 때)</li>
  <li>The parameter must not accept a variable number of arguments and must have no default value. (가변인자를 받으면 안되고 기본 값을 가지면 안된다.)</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">1</span> <span class="n">to</span> <span class="s">"one"</span>

<span class="k">infix</span> <span class="k">fun</span> <span class="nf">Any</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="p">=</span> <span class="n">Pair</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="연산자-오버로딩-operator-overloading">연산자 오버로딩 Operator overloading</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Point</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="p">+</span> <span class="n">Point</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>

<span class="kd">data class</span> <span class="nc">Point</span><span class="p">(</span><span class="kd">val</span> <span class="py">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="kd">val</span> <span class="py">y</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">operator</span> <span class="k">fun</span> <span class="nf">plus</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">Point</span><span class="p">):</span> <span class="n">Point</span> <span class="p">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span> <span class="p">+</span> <span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">+</span> <span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>plus 함수 앞에 <code class="highlighter-rouge">operator</code> 키워드를 붙여 연산자 오버로딩을 하는 함수임을 명시</li>
  <li>확장 함수로 정의할 수도 있음</li>
</ul>

<h4 id="이항-산술-연산-오버로딩">이항 산술 연산 오버로딩</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">연산 우선순위</th>
      <th style="text-align: center">식</th>
      <th style="text-align: center">함수 이름</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">a * b</td>
      <td style="text-align: center">times</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">a / b</td>
      <td style="text-align: center">div</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">a % b</td>
      <td style="text-align: center">mod(1.1부터 rem)</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">a + b</td>
      <td style="text-align: center">plus</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">a - b</td>
      <td style="text-align: center">minus</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>더 많은 연산자에 대한 메서드는 <strong><a href="https://kotlinlang.org/docs/operator-overloading.html#unary-prefix-operators">공식문서</a></strong> 참고</li>
</ul>

<h3 id="get-메서드에-대한-관례-indexed-access-operator">get 메서드에 대한 관례 Indexed access operator</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">names</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">"am"</span><span class="p">,</span> <span class="s">"mazzi"</span><span class="p">)</span>
<span class="n">names</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="n">names</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>get이 아닌 인덱스로 접근한다.</li>
</ul>

<h3 id="람다를-괄호-밖으로-빼내는-관례-passing-a-lambda-to-the-last-parameter">람다를 괄호 밖으로 빼내는 관례 Passing a lambda to the last parameter</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">check</span><span class="p">(</span><span class="k">false</span><span class="p">)</span> <span class="p">{</span> <span class="s">"Check failed."</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="수신-객체-지정-람다-lambda-with-receiver">수신 객체 지정 람다 Lambda with receiver</h3>

<ul>
  <li>람다 함수를 쓸 때 내가 자주 쓰고싶은 객체를 미리 지정해서 사용하는 람다</li>
</ul>

<h4 id="수신-객체">수신 객체?</h4>

<ul>
  <li>확장 함수에서의 this는 확장된 클래스의 객체</li>
  <li>즉 확장 함수를 사용하는 그 객체를 의미하는데 이 객체가 바로 수신 객체</li>
</ul>

<h4 id="with">with</h4>

<ul>
  <li>첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만듦</li>
</ul>

<p><strong>with를 사용하지 않을 경우</strong></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">alphabet</span><span class="p">():</span> <span class="n">String</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">result</span> <span class="p">=</span> <span class="n">StringBuilder</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">letter</span> <span class="k">in</span> <span class="sc">'A'</span><span class="o">..</span><span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
    	<span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"\nNow I know this alphabet!"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">result</code> 의 중복이 발생</li>
</ul>

<h4 id="with를-사용한-경우">with를 사용한 경우</h4>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">alphabet</span><span class="p">():</span> <span class="n">String</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">stringBuilder</span> <span class="p">=</span> <span class="n">StringBuilder</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">with</span><span class="p">(</span><span class="n">stringBuilder</span><span class="p">)</span> <span class="p">{</span>
    	<span class="k">for</span> <span class="p">(</span><span class="n">letter</span> <span class="k">in</span> <span class="sc">'A'</span><span class="o">..</span><span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
    		<span class="k">this</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
    	<span class="p">}</span>
        <span class="n">append</span><span class="p">(</span><span class="s">"\n amazzi~~~!"</span><span class="p">)</span>
        <span class="k">this</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 불필요한 stringBuilder 변수를 없애면 alpabet 함수가 식의 결과를 바로 반환하게 된다.
// 람다 식의 본문에 있는 마지막 식의 값을 반환
</span><span class="k">fun</span> <span class="nf">alphabet</span><span class="p">():</span> <span class="n">String</span> <span class="p">=</span> <span class="n">with</span><span class="p">(</span><span class="n">StringBuilder</span><span class="p">())</span> <span class="p">{</span>
    	<span class="k">for</span> <span class="p">(</span><span class="n">letter</span> <span class="k">in</span> <span class="sc">'A'</span><span class="o">..</span><span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">append</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
    	<span class="p">}</span>
        <span class="n">append</span><span class="p">(</span><span class="s">"\nNow I know this alphabet!"</span><span class="p">)</span>
        <span class="n">toString</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<ul>
  <li>with(stringBuilder, { … }) 와 같은 람다 함수</li>
</ul>

<h4 id="apply">apply</h4>

<ul>
  <li>with와 유사</li>
  <li>유일한 차이는 항상 자신에게 전달된 객체를 반환</li>
  <li>객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화해야되는 경우 유용</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">alphabet</span><span class="p">():</span> <span class="n">String</span> <span class="p">=</span> <span class="n">StringBuilder</span><span class="p">().</span><span class="n">apply</span> <span class="p">{</span>
    	<span class="k">for</span> <span class="p">(</span><span class="n">letter</span> <span class="k">in</span> <span class="sc">'A'</span><span class="o">..</span><span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
    		<span class="n">append</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
    	<span class="p">}</span>
        <span class="n">append</span><span class="p">(</span><span class="s">"\nNow I know this alphabet!"</span><span class="p">)</span>
    <span class="p">}.</span><span class="n">toString</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="초기화를-지연하는-방법">초기화를 지연하는 방법</h3>

<ul>
  <li>코틀린에서는 변수 선언을 먼저하고, 초기회는 뒤로 미루는 기능들을 제공</li>
  <li>사용할지 모른는 데이터를 미리 초기화할 필요가 없어 성능 향상에 도움</li>
</ul>

<h4 id="lateinit">lateInit</h4>

<ul>
  <li>필요할 때 초기화하고 사용</li>
  <li>초기화 하지 않고 사용하면 예외 발생</li>
  <li><code class="highlighter-rouge">var</code> 에만 사용 가능</li>
  <li>원시 타입에는 적용할 수 없음</li>
  <li>custom getter/setter 사용 불가
    <ul>
      <li></li>
    </ul>
  </li>
  <li>non-null 프로퍼티만 사용 가능</li>
</ul>

<h4 id="lazy">lazy</h4>

<ul>
  <li>변수를 선언할 때 초기화 코드도 함께 정의</li>
  <li>변수가 사용될 때 초기화 코드도 동작하여 변수가 초기화 됨</li>
</ul>

<hr />

<h2 id="0602-코드리뷰">0602 코드리뷰</h2>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="kd">class</span> <span class="nc">Symbol</span><span class="p">(</span><span class="kd">val</span> <span class="py">symbol</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DIAMOND</span><span class="p">(</span><span class="s">"다이아몬드"</span><span class="p">),</span>
    <span class="n">SPADE</span><span class="p">(</span><span class="s">"스페이드"</span><span class="p">),</span>
    <span class="n">HEART</span><span class="p">(</span><span class="s">"하트"</span><span class="p">),</span>
    <span class="n">CLOVER</span><span class="p">(</span><span class="s">"클로버"</span><span class="p">),</span>
  <span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>1.4부터 <code class="highlighter-rouge">,</code> 로 끝나도 컴파일 에러가 안남</li>
</ul>

<h3 id="property와-field">Property와 Field</h3>

<h4 id="field">Field</h4>

<ul>
  <li>단순히 값만 가짐</li>
  <li>값을 가져오거나 변경할 때는 직접 참조</li>
  <li>함수나 블록 내부에 선언된 지역 변수는 모두 필드로 간주</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="py">count</span> <span class="p">=</span> <span class="m">100</span> <span class="c1">// 메모리가 할당되고 값이 저장됨
</span><span class="n">println</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="c1">// count 변수값을 직접 참조하여 가져옴
</span><span class="n">count</span> <span class="p">+=</span> <span class="m">200</span> <span class="c1">// count 변수값을 직접 변경
</span></code></pre></div></div>

<h4 id="property">Property</h4>

<ul>
  <li>최상위 변수(함수나 클래스 외부에 정의됨)나 클래스의 멤버 변수로 선언됨</li>
  <li>선언 시 해당 속성의 getter/ setter가 자동으로 생성됨</li>
  <li><code class="highlighter-rouge">val</code> 로 선언시 getter 만 생성됨</li>
  <li>값을 가지지만 속성의 값을 가져오거나 변경할 때는 자동으로 관련 함수가 호출됨
    <ul>
      <li>이를 <strong>접근자</strong> 라고 함</li>
    </ul>
  </li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="py">count</span> <span class="p">=</span> <span class="m">100</span> <span class="c1">// 메모리가 할당되고 값이 저장됨
</span><span class="n">println</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="c1">// count 속성의 접근자가 호출되어 속성값을 반환
</span><span class="n">count</span> <span class="p">+=</span> <span class="m">200</span> <span class="c1">// count 속성의 접근자가 호출되어 속성값을 변환
</span></code></pre></div></div>

<p><strong>엥 근데 필드와 동일하게 코드를 작성하는데? 🤔</strong></p>

<ul>
  <li>프로그래머가 보는 관점에서는 같지만, 코틀린 컴파일러는 다르게 동작함</li>
  <li>다음과 같이 count  속성의 접근자를 자동으로 생성</li>
  <li>count 속성의 값을 가져오거나 변경할 때 자동으로 호출 됨</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="py">couhnt</span> <span class="p">=</span> <span class="m">100</span>
	<span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">field</span>
	<span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">field</span> <span class="p">=</span> <span class="n">value</span>
  <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">get()</code> 과 <code class="highlighter-rouge">set()</code> 이 접근자</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="n">pro1</span> <span class="p">+=</span> <span class="n">pro2</span>
  <span class="n">println</span><span class="p">(</span><span class="n">pro1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="py">pro1</span> <span class="p">=</span> <span class="m">100</span> <span class="c1">// 최상위 수준의 변수이므로 속성임
</span><span class="kd">var</span> <span class="py">pro2</span> <span class="p">=</span> <span class="m">200</span> <span class="c1">// 최상위 수준의 변수이므로 속성임
</span></code></pre></div></div>

<ul>
  <li>pro2의 게터가 호출되어 값을 가져옴</li>
  <li>pro1의 게터에서 반환된 값과 더함</li>
  <li>이 값이 pro1의 세터의 인자로 전달되어 pro1의 값이 변경됨</li>
  <li>pro1 게터에서 반환된 값을 출력</li>
</ul>

<p>프로퍼티에 <code class="highlighter-rouge">=</code> 을 이용해서 할당하는거랑 get을 사용해서</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">shouldDraw</span>  <span class="p">=</span> <span class="n">cards</span><span class="p">.</span><span class="n">score</span><span class="p">()</span>
<span class="kd">val</span> <span class="py">shouldDraw2</span> <span class="p">:</span> <span class="n">Boolean</span>
<span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">cards</span><span class="p">.</span><span class="n">scroe</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li>get을 쓰는 것은 매번 돌때마다 계산이 됨</li>
  <li>프로퍼티에 접근은 계산되어 있는 값을 씀</li>
</ul>

<h3 id="backing-fields">Backing fields﻿</h3>

<ul>
  <li>커스텀 getter와 setter를 제공할 경우 사용</li>
  <li>속성이 필드의 값을 필요로 할 때 코틀린은 지원 필드 키워드를 제공</li>
  <li>getter와 setter 범위에서만 사용 가능</li>
  <li><code class="highlighter-rouge">field</code> 지시자를 통해 속성의 게터나 세터에서 사용</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="py">counter</span> <span class="p">=</span> <span class="m">0</span> <span class="c1">// the initializer assigns the backing field directly
</span>    <span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">)</span>
            <span class="n">field</span> <span class="p">=</span> <span class="n">value</span>
            <span class="c1">// counter = value // ERROR StackOverflow: Using actual name 'counter' would make setter recursive
</span>    <span class="p">}</span>
</code></pre></div></div>

<p>아래 예제의 <code class="highlighter-rouge">this</code>는 backing field가 아님</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">isEmpty</span><span class="p">:</span> <span class="n">Boolean</span>
    <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">size</span> <span class="p">==</span> <span class="m">0</span>
</code></pre></div></div>

<h3 id="backing-properties">Backing properties﻿</h3>

<ul>
  <li>Backing fields﻿의 체계에 맞지 않는 작업을 수행할 경우 이는 Backing properties﻿가 됨</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Skills</span><span class="p">(</span><span class="n">skills</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">mutableListOf</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">_skills</span><span class="p">:</span> <span class="n">MutableList</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">skills</span><span class="p">.</span><span class="n">toMutableList</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">skills</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span>
        <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">_skills</span><span class="p">.</span><span class="n">toList</span><span class="p">()</span>

    <span class="k">fun</span> <span class="nf">soft</span><span class="p">(</span><span class="n">soft</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">_skills</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">soft</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fun</span> <span class="nf">hard</span><span class="p">(</span><span class="n">hard</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">_skills</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">hard</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://itandhumanities.tistory.com/28">코틀린 수신 객체 지정 람다 : with와 apply</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>📋 Kotlin을 정복해봅시다 1</title>
	  <link>//kotlin1</link>
	  <author></author>
	  <pubDate>2021-05-16T19:18:00+09:00</pubDate>
	  <guid>//kotlin1</guid>
	  <description><![CDATA[
	     <h2 id="코틀린이란">코틀린이란?</h2>

<ul>
  <li>자바 플랫폼에서 돌아가는 새로운 프로그래밍 언어</li>
  <li>간결하고 실용적</li>
  <li>자바 코드와의 상호 운용성을 중시</li>
  <li>코틀린 컴파일러가 생성한 바이트코드는 일반적인 자바 코드와 똑같이 효율적으로 실행</li>
</ul>

<h3 id="정적-타입-지정-언어">정적 타입 지정 언어</h3>

<p>정적 타입 지정이란 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있다.<br />
프로그램 안에서 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증해준다.</p>

<p>코틀린은 타입추론을 지원하여 개발자가 타입 선언해야하는 불편함이 줄어든다.<br />
매개 변수 이름 뒤에 매개 변수의 자료형을 쓴다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="n">val</span> <span class="n">PATTERN</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"//(.)\n(.*)"</span><span class="o">)</span>
<span class="kd">private</span> <span class="kd">const</span> <span class="n">val</span> <span class="n">FIRST_TARGET_STRING</span> <span class="o">=</span> <span class="s">"//"</span>
<span class="kd">private</span> <span class="kd">const</span> <span class="n">val</span> <span class="n">LAST_TARGET_STRING</span> <span class="o">=</span> <span class="s">"\n"</span>
</code></pre></div></div>

<h3 id="변수-선언">변수 선언</h3>

<ul>
  <li>val : 값이 변경되지 않는 변수</li>
  <li>var : 값이 변경될 수 있는 변수</li>
</ul>

<h4 id="블록이-본문인-함수">블록이 본문인 함수</h4>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">max</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="식이-본문인-함수">식이 본문인 함수</h4>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">max</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
</code></pre></div></div>

<hr />

<h2 id="코틀린-학습-테스트">코틀린 학습 테스트</h2>

<h3 id="named-arguments">named arguments</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Crew</span><span class="p">(</span><span class="s">"신지혜"</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="s">"아마찌"</span><span class="p">)</span>
</code></pre></div></div>

<p>Crew 객체에 name과 nickname 필드가 있을 때 생성자에 전달하는 인자만을 보고는 어떤 문자열이 어떤 역할인지 헷갈릴 수 있다.<br />
이는 함수의 시그니처를 살펴보지 않고는 알아내기 어려운데,<br />
코틀린으로 작성한 함수를 호출할 때는 가독성을 높이기 위해 전달하는 인자의 이름을 명시해줄 수 있다.  <br />
이때 인자 중 어느 하나라도 이름을 명시하면 그 뒤로 오는 모든 인자는 이름을 명시해야 한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Person</span><span class="p">(</span><span class="s">"신지혜"</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="n">nickname</span> <span class="p">=</span> <span class="s">"아마찌"</span><span class="p">),</span>
<span class="n">Person</span><span class="p">(</span><span class="n">name</span> <span class="p">=</span> <span class="s">"신지혜"</span><span class="p">,</span> <span class="n">nickname</span> <span class="p">=</span> <span class="s">"아마찌"</span><span class="p">,</span> <span class="n">age</span> <span class="p">=</span> <span class="m">20</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="nullable-types">nullable types</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span><span class="p">?,</span> <span class="kd">var</span> <span class="py">nickname</span><span class="p">:</span> <span class="n">String</span><span class="p">?)</span>
</code></pre></div></div>

<p>null이 될수 있는 type을 명시적으로 표시할 수 있다. <br />
type에 ?를 붙임으로서 null이 가능한 변수임을 명시적으로 표현한다.</p>

<h3 id="default-arguments">default arguments</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span> <span class="kd">var</span> <span class="py">nickname</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span><span class="k">null</span><span class="p">)</span>
</code></pre></div></div>

<p>자바는오버로딩을 하여 인자가 다른 같은 메서드를 만든다.</p>

<p>하지만 코틀린은 기본 인자를 지원하기 때문에, 1개의 메소드만 정의하여 메서드 오버로딩 기능을 한다. 
기본 인자를 설정하는 방법은, 다음과 같이 인자 이름 다음에 <code class="highlighter-rouge">인자 = 기본값</code>처럼 정의하면 된다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">add</span><span class="p">(</span><span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span><span class="p">)</span>
</code></pre></div></div>

<p>위의 메소드는 아래처럼 인자의 개수가 다르게 호출될 수 있습니다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>      <span class="c1">// num2 = 0 은 기본인자로 전달
</span><span class="n">add</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="data-classe">data classe</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">data class</span> <span class="nc">Person</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span> <span class="kd">var</span> <span class="py">nickname</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span><span class="k">null</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>수리 피셜 데이터 클래스는 DTO다.</li>
  <li>딱히 비즈니스 로직을 갖고 있지않다.</li>
  <li>생성자부터 getter &amp; setter, 심지어 canonical methods까지 알아서 생성해준다.</li>
</ul>

<h4 id="제한-사항">제한 사항</h4>

<ul>
  <li>기본 생성자에는 최소 하나의 파라미터가 있어야 한다.</li>
  <li>기본 생성자의 파라미터는 val이나 var여야만 한다.</li>
  <li>데이터 클래스는 abstract, open, sealed, inner가 되면 안 된다.</li>
</ul>

<h4 id="-canonical-methods">🤔 Canonical Methods?</h4>

<p>캐노니컬 메소드는 Any에 선언된 메소드 (Any는 자바의 Object처럼 코틀린에서 모든 객체의 조상이 되는 객체)<br />
따라서 코틀린의 모든 인스턴스가 갖고 있는 메소드를 뜻한다.</p>

<p>코틀린의 data class는 모든 Canonical 메서드를 올바르게 구현하고 있다.</p>

<ul>
  <li><strong>equlas(other: Any?): Boolean</strong> - 이 메소드는 참조가 아니라 데이터 클래스 간 값의 일치를 비교한다.</li>
  <li><strong>hashCode(): Int</strong> - 해쉬코드는 인스턴스의 숫자 표현이다. hashCode()가 같은 인스턴스에서 여러 번 호출될 때 항상 동일한 값을 반환해야 한다. equals()로 비교할 때 참을 반환하는 두 인스턴스는 같은 hashCode()를 가져야만 한다.</li>
  <li><strong>toString(): String</strong> - 인스턴스의 문자열 표현이다. 데이터 클래스는 이를 멤버 변수의 값을 나열하도록 자동으로 재정의 한다.</li>
  <li><strong>copy()</strong> : 객체를 복사하여 새 객체 생성</li>
  <li><strong>componentsN()</strong> : 속성을 순서대로 반환</li>
</ul>

<hr />

<h2 id="2단계-문자열-계산기-구현하면서-배운-사실들">2단계 문자열 계산기 구현하면서 배운 사실들</h2>

<h3 id="메서드-정의">메서드 정의</h3>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="err">메서드명(</span><span class="nf">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="err">반환타입</span> <span class="p">{</span>
    <span class="n">retunr</span> <span class="m">2</span> <span class="p">*</span> <span class="n">x</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="unit--nothing">Unit / Nothing</h3>

<p>코틀린은 원시타입과 wrapper type을 구분하지 않는다.</p>

<h4 id="unit">Unit</h4>

<p>함수의 반환 구문이 없다는 것을 표현한다. (자바의 void에 해당).<br />
void와는 다르게 인자로도 사용할 수 있다.</p>

<h4 id="nothing">Nothing</h4>

<p>함수가 정상적으로 끝나지 않는다라는걸 명시적으로 표현한다.</p>

<h4 id="firstornull">firstOrNull</h4>

<p>컬렉션 내 첫 번째 인자를 반환한다. 단순히 리스트 내에서 첫 번째에 위치하는 인자를 반환하는 것뿐 아니라, 특정 조건을 만족하는 첫 번째 인자를 반환하도록 구성하는 것도 가능하다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">operator</span> <span class="p">=</span> <span class="n">values</span><span class="p">().</span><span class="n">firstOrNull</span> <span class="p">{</span> <span class="n">item</span> <span class="p">-&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">op</span> <span class="p">==</span> <span class="n">op</span> <span class="p">}</span>
    <span class="o">?:</span> <span class="k">throw</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">"존재하지 않는 연산자입니다."</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h2 id="자동차-경주-피드백">자동차 경주 피드백</h2>

<h3 id="코틀린의-코딩-컨벤션">코틀린의 코딩 컨벤션</h3>

<h4 id="클래스">클래스</h4>

<ul>
  <li>프로퍼티</li>
  <li>초기화 블록</li>
  <li>부 생성자</li>
  <li>함수</li>
  <li>동반 객체</li>
</ul>

<p>순으로 작성한다.</p>

<h4 id="-ktlint-적용하기">➕ ktlint 적용하기</h4>

<p><strong>ktlint</strong>란 코틀린을 위한 정적 분석 도구로, 코틀린으로 작성한 코드의 스타일 검사와, 형식에 맞지 않는 부분을 수정하는 기능을 제공한다.</p>

<p>사용하기 위해서는 다음과 같이 플러그인을 추가해준다.</p>

<div class="language-gradle highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plugins</span> <span class="o">{</span>
    <span class="n">id</span> <span class="s1">'org.jetbrains.kotlin.jvm'</span> <span class="n">version</span> <span class="s1">'1.3.72'</span>
    <span class="n">id</span> <span class="s1">'org.jmailen.kotlinter'</span> <span class="n">version</span> <span class="s2">"3.2.0"</span> <span class="c1">// 추가</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://images.velog.io/images/new_wisdom/post/709c90c9-2cac-4eb0-8a48-a20ec4156ed6/image.png" style="zoom:33%;" /></p>

<p>플러그인을 추가하면 gradle-Tasks-formating이 생성되는데 lintKotlin을 눌러주면 lint로 코틀린 컨벤션이 틀린 부분을 잡아준다.</p>

<h3 id="주생성자-부-생성자">주생성자, 부 생성자</h3>

<h4 id="주-생성자">주 생성자</h4>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Car</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">position</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span><span class="p">)</span>
</code></pre></div></div>

<p>클래스 이름 뒤에 오는 생성자가 바로 주 생성자이다.<br />
주 생성자는 생성자 파라미터를 지정하고, 이에 의해 초기화되는 프로퍼티를 정의하는데 사용된다.<br />
또한 주 생성자는 객체 초기화를 시작하는 유일한 곳이기 때문에 제공되는 인자들이 완전해야 한다.</p>

<p>주 생성자에는 별도의 코드를 포함시킬 수 없다.<br />
이때 코틀린은 <code class="highlighter-rouge">init</code> 키워드로 초기화 블록을 선언할 수 있다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Car</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">position</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">init</span> <span class="p">{</span>
        <span class="n">require</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">length</span> <span class="p">&lt;=</span> <span class="n">MAX_NAME_LENGTH</span><span class="p">)</span> <span class="p">{</span>
            <span class="s">"자동차의 이름은 5글자를 초과할 수 없습니다."</span>
        <span class="p">}</span>
    <span class="c1">// ...
</span></code></pre></div></div>

<h4 id="부-생성자">부 생성자</h4>

<p>파라미터 목록이 다른 여러 생성자를 만들 경우 부 생성자를 둘 수 있다.<br />
부 생성자에서는 <code class="highlighter-rouge">this</code> 키워드를 사용해 주 생성자를 호출하도록 한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Car</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">var</span> <span class="py">position</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">constructor</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>하지만 이 경우보다는 <strong><code class="highlighter-rouge">default</code>키워드를 사용하여 매개변수의 기본값을 사용</strong>하자.</p>

<p><strong>주 생성자 호출 시점</strong></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constructor</span><span class="p">(</span><span class="n">carNUm</span> <span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="n">ArryaList</span><span class="p">())</span> <span class="p">{</span>
	<span class="n">createList</span><span class="p">(</span><span class="n">carName</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위와 같이 부 생성자에서 주 생성자를 호출할 때 <code class="highlighter-rouge">createList()</code>가 실행되는 순서는 다음과 같다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">Cars</span><span class="p">(</span><span class="n">int</span> <span class="n">carNUm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">(</span><span class="n">new</span> <span class="n">ArrayList</span><span class="p">())</span>
  <span class="k">this</span><span class="p">.</span><span class="n">createList</span><span class="p">(</span><span class="n">carNum</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="require-check---조건-확인-함수">require(), check() - 조건 확인 함수</h3>

<ul>
  <li>
    <p><strong>require()</strong> : 식이 참이 아닐 경우 <code class="highlighter-rouge">IllegalArgumentException</code> 발생</p>
  </li>
  <li>
    <p><strong>check()</strong> : 식이 참이 아닐 경우 <code class="highlighter-rouge">IllegalStateException</code> 발생</p>

    <p>위 예제처럼 <code class="highlighter-rouge">{}</code> 블록에 예외 메시지를 작성할 수도 있다.</p>
  </li>
</ul>

<h3 id="setter만-private으로---가시성-변경자">setter만 private으로 - 가시성 변경자</h3>

<p>자바를 생각하면 필드를 <code class="highlighter-rouge">private</code> 로 만들고,  getter를 통해 값을 꺼내도록 하였지만,<br />
코틀린에서는 필드를 private으로 두기보다는 setter 함수만 private으로 지정한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Car</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="py">position</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
        <span class="k">private</span> <span class="k">set</span>
<span class="p">}</span>
</code></pre></div></div>

<p>자바는 필드 기반  언어인데 코틀린은 프로퍼티 기반 언어이다.<br />
팁을 준다면 코틀린에서 프로퍼티에 무언가 연산이 들어간다면 함수를 만들고,<br />
값 자체만 반환한다면 위와 같이 쓰자.</p>

<h3 id="상수">상수</h3>

<p>기본 자료형의 상수는 <code class="highlighter-rouge">const val</code> 키워드로 표현한다.<br />
기본 자료형 외에는 <code class="highlighter-rouge">const</code> 키워드를 사용할 수 없다.</p>

<p>상수는 클래스 외부에다가도 선언할 수 있다.<br />
하지만 이 경우 확장자가 파일로 변경되니 사람 취향껏 하면 된다.</p>

<h4 id="companion-object---동반-객체">companion object - 동반 객체</h4>

<p>코틀린에서는 <code class="highlighter-rouge">static</code> 키워드가 없는데, 이 대신 사용할 수 있는 것이 companion object 이다.<br />
이는 객체이며, <code class="highlighter-rouge">companion object</code> 내에 선언된 속성과 함수는 <code class="highlighter-rouge">{클래스 이름}.{필드/함수 이름}</code> 형태로 바로 호출할 수 있다.  <br />
클래스의 맨 하단에 작성한다.</p>

<h4 id="jvmstatic">@JvmStatic</h4>

<p><code class="highlighter-rouge">ompanion object</code>를 사용하여 구성한 코드를 자바에서 사용하려면 속성 및 함수가 자바의 필드/메서드로 해석되도록 알려주어야 한다.</p>

<p><code class="highlighter-rouge">const</code> 선언이 되어 있는 프로퍼티는 별도의 처리 없이 자바에서도 사용 가능하며, 
함수는 <code class="highlighter-rouge">@JvmStatic</code> 어노테이션을 사용하여 자바에서 정적 메서드로 사용할 수 있게 한다.</p>

<h4 id="jvmfield">@JvmField</h4>

<p><code class="highlighter-rouge">const</code> 키워드는 기본 자료형에만 사용이 가능하다.<br />
이외의 타입 객체를 자바에서 정적 필드처럼 사용하려면 <code class="highlighter-rouge">@JvmField</code> 어노테이션을 사용해야 한다.</p>

<h3 id="utility-클래스">Utility 클래스</h3>

<p>자바에서는 모든 메서드를 클래스 내부에 작성해야했지만, 코틀린에서는 그럴 필요가 없다.<br />
필요한 유틸리티 메서드만 모아놓은 파일만을 만들고 이를 파일 최상위에 위치시키면 된다.</p>

<h3 id="스마트-캐스트">스마트 캐스트</h3>

<p>코틀린에서는 컴파일러가 대신 캐스팅을 해준다.<br />
원하는 타입을 검사하고 나면, 개발자가 변수를 원하는 타입으로 캐스팅하지 않아도 해당 변수가 원하는 타입으로 선언된 것처럼 사용할 수 있다.<br />
이는 컴파일러가 캐스팅을 수행해주어 가능한 일이다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">String</span><span class="p">?):</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">isNullOrBlank</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="n">IllegalArgumentException</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="kd">val</span> <span class="py">tokens</span> <span class="p">=</span> <span class="n">text</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">" "</span><span class="p">)</span>
    <span class="c1">// ...
</span><span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="코드-리뷰-중-짤막한-배움">코드 리뷰 중 짤막한 배움</h2>

<h4 id="maxby">maxBy{}</h4>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">findMaxPosition</span><span class="p">():</span> <span class="n">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">cars</span><span class="p">.</span><span class="n">maxBy</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">position</span> <span class="p">}</span><span class="o">!!</span><span class="p">.</span><span class="n">position</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>가장 큰 원소를 찾기 위해 비교에 사용할 값을 인자로 받는다. <br />
모든 컬렉션에 대해 maxBy 함수를 호출할 수 있다.</p>

<p><code class="highlighter-rouge">{ it.position }</code> 는 비교에 사용할 값을 돌려주는 함수이다.<br />
<code class="highlighter-rouge">maxBy{}</code> 의 반환 값은 nullable인데, 반환된 값의 프로퍼티를 사용하고 싶은 경우 <code class="highlighter-rouge">!!</code> 키워드를 통해 null이 아님을 선언하여 꺼낸다.</p>

<p><strong>참고</strong></p>

<p><code class="highlighter-rouge">?:</code>(엘비스 오퍼레이터 ) : null인 경우 설정한 default 값을 넣는다.</p>

<h4 id="pair">Pair</h4>

<p>Kotlin에서 제공하는 객체 타입 중 연관 타입끼리 관계가 없어도 2개를 쌍으로 가지고 있는 객체</p>

<p><strong>getter</strong>는 <strong>.first  .second</strong> 또는 <strong>.component1() / .component2()</strong>로 접근할 수 있다.</p>

<p><strong>RacingCar 일부</strong></p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">race</span><span class="p">(</span><span class="n">moveStrategy</span><span class="p">:</span> <span class="n">MoveStrategy</span><span class="p">):</span> <span class="n">Pair</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Cars</span><span class="p">&gt;,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Car</span><span class="p">&gt;&gt;</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">carsGroup</span> <span class="p">=</span> <span class="n">arrayListOf</span><span class="p">&lt;</span><span class="n">Cars</span><span class="p">&gt;()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">0</span> <span class="n">until</span> <span class="n">tryNumber</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">cars</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">cars</span><span class="p">.</span><span class="n">moveAll</span><span class="p">(</span><span class="n">moveStrategy</span><span class="p">)</span>
        <span class="n">carsGroup</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">cars</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Pair</span><span class="p">(</span><span class="n">carsGroup</span><span class="p">,</span> <span class="n">findWinners</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">fun</span> <span class="nf">findWinners</span><span class="p">():</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Car</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">maxPosition</span> <span class="p">=</span> <span class="n">cars</span><span class="p">.</span><span class="n">findMaxPosition</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">cars</span><span class="p">.</span><span class="n">findCarsBySamePosition</span><span class="p">(</span><span class="n">maxPosition</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="과-">==과 ===</h4>

<ul>
  <li>
    <p><code class="highlighter-rouge">==</code> 연산자는 자바의 equal와 같다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">===</code> 연산자는 자바의 <code class="highlighter-rouge">==</code>와 같다.</p>
  </li>
</ul>

<h4 id="list-mutablelist">List, MutableList</h4>

<p>코틀린에서는 읽기 전용 리스트(List)와 수정할 수 있는 리스트(MutableList)가 있다.<br />
<code class="highlighter-rouge">arrayListOf()</code> 를 쓰기보다는 코틀린이 제공하는 List 또는 MutableList를 사용하자</p>

<p><strong>List</strong></p>

<p>데이터를 읽기만 가능하고 리스트를 선언할 때 넣은 데이터들을 수정, 삭제, 변경할 수 없다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="py">cars</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="n">Car</span><span class="p">(</span><span class="s">"ama"</span><span class="p">),</span> <span class="n">Car</span><span class="p">(</span><span class="s">"mazzi"</span><span class="p">))</span>

<span class="n">println</span><span class="p">(</span><span class="n">cars</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="c1">// O
</span>
<span class="n">cars</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Car</span><span class="p">(</span><span class="s">"new"</span><span class="p">))</span> <span class="c1">// X 컴파일에러
</span><span class="n">cars</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>   <span class="c1">// X 컴파일에러
</span></code></pre></div></div>

<p><strong>MutableList</strong></p>

<p>기존 자바에서 사용하던 ArrayList와 유사하므로 ArrayList의 함수들을 모두 사용할 수 있다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="py">carsMutable</span> <span class="p">=</span> <span class="n">mutableListOf</span><span class="p">&lt;</span><span class="n">Car</span><span class="p">&gt;()</span>
<span class="n">carsMutable</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Car</span><span class="p">(</span><span class="s">"ama"</span><span class="p">))</span> <span class="c1">// O
</span><span class="n">carsMutable</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Car</span><span class="p">(</span><span class="s">"mazzi"</span><span class="p">))</span> <span class="c1">// O
</span><span class="n">carsMutable</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="c1">// O
</span><span class="n">println</span><span class="p">(</span><span class="n">carsMutable</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="c1">// O
</span></code></pre></div></div>

<p>List와 MutalbeList 서로의 타입으로 변경도 가능하다. 이 때 서로 새로운 리스트를 반환한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="py">carsMutable</span> <span class="p">=</span> <span class="n">mutableListOf</span><span class="p">&lt;</span><span class="n">Car</span><span class="p">&gt;()</span>
<span class="n">carsMutable</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Car</span><span class="p">(</span><span class="s">"ama"</span><span class="p">))</span> 
<span class="n">carsMutable</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Car</span><span class="p">(</span><span class="s">"mazzi"</span><span class="p">))</span> 

<span class="kd">var</span> <span class="py">arrNotMutable</span> <span class="p">=</span> <span class="n">carsMutable</span><span class="p">.</span><span class="n">toList</span><span class="p">()</span> <span class="c1">//mutable -&gt; list 변경
</span>
<span class="kd">var</span> <span class="py">arrReMutable</span> <span class="p">=</span> <span class="n">arrNotMutable</span><span class="p">.</span><span class="n">toMutableList</span><span class="p">()</span> <span class="c1">// list -&gt; mutable 변경
</span><span class="n">arrReMutable</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Car</span><span class="p">(</span><span class="s">"new"</span><span class="p">))</span>
<span class="n">println</span><span class="p">(</span><span class="n">arrReMutable</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="assertthrows">assertThrows</h4>

<p>자바처럼 <code class="highlighter-rouge">assertThatThrownBy</code> 를 쓰지 말고 아래와 같이 쓰자.<br />
이유는 <code class="highlighter-rouge">assertThatThrownBy</code> 를 사용할 경우 <code class="highlighter-rouge">isInstanceOf()</code> 를 사용하는데 여기에는 <code class="highlighter-rouge">.java.class</code> 를 붙여주어야 해 코틀린 스럽지 못하기 때문이다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="n">IllegalArgumentException</span><span class="p">&gt;</span> <span class="p">{</span><span class="n">Car</span><span class="p">(</span><span class="n">name</span> <span class="p">=</span> <span class="n">input</span><span class="p">)}</span>
</code></pre></div></div>

<h4 id="object">object</h4>

<p>클래스를 만듦과 동시에 인스턴스로 만든다. (싱글턴)</p>

<h4 id="람다-작성">람다 작성</h4>

<p>코틀린은 람다식을 작성할 때 <code class="highlighter-rouge">{}</code>로 표현한다. <br />
람다의 인자가 하나라면 람다식 내부에서 <code class="highlighter-rouge">it</code>으로 받을 수 있다.<br />
함수의 인자로 람다가 넘어올 때, 맨 마지막 순번이라면 <code class="highlighter-rouge">()</code> 밖에 쓸 수 있다.<br />
만약 람다 하나만 받는 거라면 <code class="highlighter-rouge">()</code>를 생략할 수 있겠죠?</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">newCars</span> <span class="p">=</span> <span class="n">cars</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="n">moveStrategy</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<h4 id="associate"><code class="highlighter-rouge">associate{}</code></h4>

<p>map을 기본적으로 반환한다.</p>

<h4 id="input을-재귀적으로">Input을 재귀적으로</h4>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">tailrec</span> <span class="k">fun</span> <span class="nf">inputCarNames</span><span class="p">():</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">"경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분)."</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">readLine</span><span class="p">()</span><span class="o">?.</span><span class="n">replace</span><span class="p">(</span><span class="s">" "</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span><span class="o">?.</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">)</span> <span class="o">?:</span> <span class="n">inputCarNames</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">tailrec</span> <span class="k">fun</span> <span class="nf">inputTryNumber</span><span class="p">():</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">"시도할 횟수는 몇 회인가요?"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">readLine</span><span class="p">()</span><span class="o">?.</span><span class="n">toIntOrNull</span><span class="p">()</span> <span class="o">?:</span> <span class="n">inputTryNumber</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="highlighter-rouge">tailrec</code></strong> : 꼬리재귀(tail recursive)라는 의미로, 추가적인 연산이 없이 자신 스스로 재귀적으로 호출하다가 어떤 값을 리턴하는 함수
    <ul>
      <li>해당 키워드를 붙이면 재귀적인 함수 호출의 최적화가(?) 일어남</li>
    </ul>
  </li>
</ul>

<h4 id="중위-함수-to-키워드">중위 함수 (to 키워드)</h4>

<ul>
  <li><strong>중위 표현법</strong> : 변수와 변수사이에 함수를 넣어 연산자 처럼 사용하는 것</li>
</ul>

<p><strong>조건</strong></p>

<ul>
  <li>멤버 메서드 또는 확장 함수여야 함</li>
  <li>하나의 매개변수를 가져야함</li>
  <li><strong>infix</strong> 키워드를 사용하여 정의</li>
</ul>

<p><strong>ex) Pair 객체를 생성할 때 to</strong></p>

<p><img src="https://images.velog.io/images/new_wisdom/post/7377057b-c283-4102-8e00-d704ae58d308/image.png" style="zoom:33%;" /></p>

<h4 id="by-키워드">by 키워드</h4>

<p><img src="https://images.velog.io/images/new_wisdom/post/da1ab914-04bb-4128-ae3d-3393fa9ec579/image.png" style="zoom:33%;" /></p>

<p>위 코드에서 Car의 일급 컬렉션인 Cars를 순회할 때 현재는 <code class="highlighter-rouge">List&lt;Car&gt;</code>에 접근하여 순회하고 있다.<br />
하지만 코틀린에서는 다음과 같이 변경할 수 있다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/4ed5d81e-1003-4aaa-aead-6cfe5f7cc4df/image.png" style="zoom:33%;" /></p>

<p>위와 같이 cars 일급 컬렉션을 바로 순회할 수 있는 이유는 Cars가 다음과 같이 <code class="highlighter-rouge">List&lt;Car&gt;</code> 인터페이스를 구현하고 있기 때문이다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/4ebb7070-a1b5-4d4b-a5b7-0d2c56524246/image.png" style="zoom:33%;" /></p>

<p>뭐야 완전 신기해….  <br />
제이슨이 일단 지금은 “와 뭐야” 이정도까지만 알아두어도 된다고 하였다.<br />
코틀린 짱</p>

	  ]]></description>
	</item>


</channel>
</rss>
