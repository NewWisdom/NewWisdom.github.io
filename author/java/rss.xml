<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>NewWisdom.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>I want to be a person who gives you new wisdom.</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>📖 Java 람다의 변수 범위</title>
	  <link>//Java-%EB%9E%8C%EB%8B%A4%EC%9D%98-%EB%B3%80%EC%88%98-%EB%B2%94%EC%9C%84</link>
	  <author></author>
	  <pubDate>2021-03-19T19:18:00+09:00</pubDate>
	  <guid>//Java-%EB%9E%8C%EB%8B%A4%EC%9D%98-%EB%B3%80%EC%88%98-%EB%B2%94%EC%9C%84</guid>
	  <description><![CDATA[
	     <h3 id="람다의-변수-범위">람다의 변수 범위</h3>

<p><img src="https://user-images.githubusercontent.com/43840561/111862130-956d4c80-8996-11eb-9abd-c2bef47886d9.png" alt="image" /></p>

<p>물론 위의 코드는 미션을 위해 일단 구현만을 목적으로 많은 리팩토링이 필요하니 참고 🥲<br />
미션을 진행하다가 for 문 내에 stream을 쓰게 되었는데, i의 값을 람다식 내에서 사용하려니 컴파일 에러가 났다.<br />
“Variable used in lambda expression should be final or effectively final”
즉 람다식에서 사용되는 변수는 final이거나 effectively final이어야 한다.</p>

<p>effectively final은 무엇이며, 람다의 변수 범위를 정확히 짚고 넘어가자.</p>

<h3 id="람다의-변수-범위-1">람다의 변수 범위</h3>

<p>다음과 같은 Lambda 클래스가 있고, 각각의 메서드를 호출해 클래스 필드인 <code class="highlighter-rouge">name</code>이 어떻게 바뀌는지 살펴본다 🔎</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lambda</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">example1</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">example2</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">10</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">example3</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">15</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/43840561/111862546-58568980-8999-11eb-8fb0-6ac25fc92285.png" alt="image" /></p>

<p>이에 대한 출력 결과는 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111862548-5ee50100-8999-11eb-9962-0697067614f8.png" alt="image" /></p>

<p>위 예제에서 람다식에서는 자신을 감싼 메서드나 클래스에 속한 변수에 접근을 할 수 있다.<br />
예제는 람다에 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수를 사용하고 있는데 이러한 변수를 <strong>자유 변수</strong>라고 부른다.</p>

<p>그렇다면 다시 맨 처음 오류를 가져와서 … 
<img src="https://user-images.githubusercontent.com/43840561/111862130-956d4c80-8996-11eb-9abd-c2bef47886d9.png" alt="image" /></p>

<p>이 부분에서 왜 자유 변수인 i를 final이나 effectvely final로 선언하라는 것일까 ?</p>

<p>먼저 <strong>지역 변수</strong>는 JVM에서 스택 영역에 저장이 된다. <br />
그리고 실제 메모리와 다르게 JVM에서 이 스택 영역은 스레드 마다 별도의 스택이 생성된다. <br />
따라서 지역 변수는 한 스레드 안에서만 사용이 되며, 스레드끼리 공유하지 못한다.</p>

<p>지역 변수와 다르게 인스턴스 변수는 힙 영역에 생성되어 서로 다른 스레드끼리도 공유할 수 있는 공유 변수이다.</p>

<p><strong>람다</strong>는 각각 별도의 스레드에서 실행이 가능하다.<br />
위 예제에서 각각의 메서드는 i를 증가시키는 것이 아니라 람다를 리턴할 뿐이다.<br />
실행 흐름 상 메서드를 호출한 스레드의 스택에 지역 변수인 i가 생성이 되는데,<br />
람다식을 반환한 후에는 해당 함수가 종료되었으니 메모리에서 i가 사라질 것이다. <br />
그렇지만 반환된 람다식은 다른 스레드에서 호출될 수 있는데, i가 GC에 의해 정리되어 접근할 수 없는 문제가 발생할 수 있다.</p>

<p>때문에 실행 시점에 지역 변수가 사라질 것을 방지하기 위해서 이 자유 변수의 복사본을 만들어서 동작한다. 
이 복사본을 가지고 동작할 예정인데, 이 복사본 값이 바뀌어 버리면 의도하지 않은 결과가 생길 수 있으므로 컴파일 단계에서<br />
final 또는 effectively final로 선언해 변수를 신뢰할 수 있게 만드는 것이다.<br />
이를 <strong>람다 캡처링</strong>이라고 한다.</p>

<p>위 문제에서 컴파일 에러가 뜨는 것은 i가 스코프 밖에 있어 값이 변할 수 있어 신뢰할 수 없다.<br />
때문에 인텔리제이가 권해주는 방법을 쓰면 i를 스코프 안 변수에 새로 할당해서 사용하게 된다.<br />
<img src="https://user-images.githubusercontent.com/43840561/111863899-7de79100-89a1-11eb-8ed3-6c685817269d.png" alt="image" /></p>

<p>여기서 i는 <code class="highlighter-rouge">final</code> 로 선언되지는 않았지만, 자바 8에서 추가된 effectively final로 선언된 것이다.<br />
effectively final은 final로 선언되지 않아도 컴파일러가 해당 변수가 변경되지 않았다고 판단할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111863962-d61e9300-89a1-11eb-85f8-b7e0a7d5ef7e.png" alt="image" /></p>

<p>만약 effectively final인 i의 값을 바꾸려 한다면 이렇게 컴파일 오류가 발생한다.</p>

<p>파도 파도 끝없는 람다의 세계 🤸‍♀️</p>

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://perfectacle.github.io/2019/06/30/java-8-lambda-capturing/">(Java) 람다 캡처링과 final 제약조건</a></li>
  <li><a href="https://futurecreator.github.io/2018/08/02/java-lambda-variable-scope/">Java Lambda (5) 변수 범위</a></li>
  <li><a href="https://jeong-pro.tistory.com/211">자바 람다에서 final이거나 final처럼 쓰인 지역 변수만 접근할 수 있는 이유</a></li>
</ul>

<hr />

<h3 id="enum-map">Enum Map</h3>


	  ]]></description>
	</item>

	<item>
	  <title>📖 Functional Interface</title>
	  <link>//Functional-Interface</link>
	  <author></author>
	  <pubDate>2021-03-06T19:18:00+09:00</pubDate>
	  <guid>//Functional-Interface</guid>
	  <description><![CDATA[
	     <h2 id="함수형-인터페이스">함수형 인터페이스</h2>
<p>자바 8부터 자바는 객체지향 언어일 뿐만 아니라 함수형 언어도 지원할 수 있게되었다.</p>

<p>자바에서는 숫자, 문자 같은 원시 타입, 클래스를 통해 정의하는 참조 타입 객체들이<br />
일급 객체가 될 수 있지만, <br />
(함수형 인터페이스가 등장하기 전까지는) 함수에 해당하는 메서드는 일급 객체가 아니었다.</p>

<p>덕분에 오늘 뜯어 볼 Functional Interface의 등장으로,<br />
객체 안에만 존재했던 함수(메서드)를 일급 객체로 다룰 수 있게되었다.</p>

<p><strong>🤔 일급 객체…?</strong><br />
어떤 개체가 다음 3가지 조건을 만족하는 경우, 이를 일급 객체라고 말한다.</p>

<ul>
  <li>파라미터로 전달할 수 있다.</li>
  <li>반환값으로 사용할 수 있다.</li>
  <li>변수나 데이터 구조 안에 담을 수 있다.</li>
  <li>할당에 사용된 이름과 관계없이 고유한 구별이 가능하다.</li>
</ul>

<p>자세한 내용은 <a href="https://isooo.github.io/etc/2019/11/13/%EC%9D%BC%EA%B8%89%EA%B0%9D%EC%B2%B4.html">이 글</a>을 참고하면 좋을 것 같다.</p>

<h3 id="함수형-인터페이스-정의하기">함수형 인터페이스 정의하기</h3>
<p>인터페이스에 추상 메소드가 딱 하나만 존재하는 것을 함수형 인터페이스라고 한다.<br />
자바의 람다식은 함수형 인터페이스를 통해서만 다뤄진다.<br />
함수형 인터페이스는 람다식과 인터페이스 메소드가 1:1로 연결되기 위해, <br />
<strong>추상 메소드가 단 하나뿐인 인터페이스</strong>이다.<br />
(static, defualt 메서드는 제외다.)</p>

<p>자바에서는 이를 <code class="highlighter-rouge">@FunctionalInterface</code> 어노테이션을 사용하여 나타낸다.<br />
참고로 어노테이션을 붙일 경우 컴파일러에서 어노테이션이 붙은 엔티티가 <br />
단일 추상메서드를 갖춘 인터페이스인지 검사하니 붙이도록 하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">Calculate</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="nf">cal</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="미리-정의되어-있는-함수형-인터페이스">미리 정의되어 있는 함수형 인터페이스</h2>
<h3 id="javautilfunction-패키지">java.util.function 패키지</h3>
<p>제네릭 메서드로 정의한다면, 매개변수나 반환 타입이 달라도 문제가 되지 않는다.<br />
때문에 자바 패키지에서는 자주 쓰이는 형식의 메서드를 함수형 인터페이스로<br />
미리 정의해 놓았다.<br />
사실 매번 람다식을 위해 함수형 인터페이스를 정의하는 것은 귀찮은 일이니<br />
가급적 이 패키지의 함수형 인터페이스를 사용하자!</p>

<h4 id="표준으로-정의된-대표적-함수형-인터페이스와-그-안에-있는-추상-메소드">표준으로 정의된 대표적 함수형 인터페이스와 그 안에 있는 추상 메소드</h4>

<table>
  <thead>
    <tr>
      <th>함수형 인터페이스</th>
      <th>추상 메서드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">Predicate&lt;T&gt;</code></td>
      <td><code class="highlighter-rouge">boolean test(T t)</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Supplier&lt;T&gt;</code></td>
      <td><code class="highlighter-rouge">T get()</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Consumer&lt;T&gt;</code></td>
      <td><code class="highlighter-rouge">void accept(T t)</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Funtion&lt;T, R&gt;</code></td>
      <td><code class="highlighter-rouge">R apply(T t)</code></td>
    </tr>
  </tbody>
</table>

<h3 id="predicatet"><code class="highlighter-rouge">Predicate&lt;T&gt;</code></h3>

<p>매개변수 타입 T, 반환타입 Boolean</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">test</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span> 
</code></pre></div></div>
<ul>
  <li>매개변수가 2개인 경우 <code class="highlighter-rouge">BiPredicate&lt;T, U&gt;</code></li>
</ul>

<p>전달된 인자를 대상으로 true, false를 반환해야하는 상황에 유용하게 사용된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">PredicateDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">sum</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">lst</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">lst</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>       
        
        <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="o">);</span>
    
        <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">sum</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"짝수 합: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">sum</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"홀수 합: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">sum(Predicate&lt;Integer&gt; p, List&lt;Integer&gt; lst)</code>에는 <br />
<code class="highlighter-rouge">boolean test(Integer t)</code> 메소드 정의에 해당하는 람다식을 작성해서 전달해야한다.</p>

<h3 id="suppliert"><code class="highlighter-rouge">Supplier&lt;T&gt;</code></h3>
<p>매개변수 없음, 반환 타입 T</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span> <span class="nf">get</span><span class="o">();</span>
</code></pre></div></div>
<p>단순히 무언가를 반환해야 할 때 사용된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">SupplierDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">makeIntList</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>    
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">spr</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
        <span class="o">};</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">makeIntList</span><span class="o">(</span><span class="n">spr</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>

        <span class="n">list</span> <span class="o">=</span> <span class="n">makeIntList</span><span class="o">(</span><span class="n">spr</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">makeIntList(Supplier&lt;Integer&gt; s, int n)</code> 는 정수를 담고 있는 컬렉션 인스턴스를 반환한다. <br />
첫 번째 인자에서 컬렌션 인스턴스에 담을 정수의 생성 방법을 결정할 수 있다.</p>

<h3 id="consumert"><code class="highlighter-rouge">Consumer&lt;T&gt;</code></h3>
<p>매개변수 타입 T, 반환 타입 없음</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span>
</code></pre></div></div>
<ul>
  <li>매개변수가 2개일 경우 <code class="highlighter-rouge">BiConsumer&lt;T, U&gt;</code></li>
</ul>

<p>전달 인자를 소비하는 형태로 매개변수와 반환형이 선언되어 있다.<br />
전달된 인자를 가지고 어떤 결과를 보여야 할 때 유용하게 사용된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ConsumerDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Consumer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        
        <span class="n">c</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">"Pineapple"</span><span class="o">);</span>    <span class="c1">// 출력이라는 결과를 보인다.</span>
        <span class="n">c</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">"Strawberry"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="funtiont-r"><code class="highlighter-rouge">Funtion&lt;T, R&gt;</code></h3>
<p>매개변수 타입 T, 반환타입 R</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">R</span> <span class="nf">apply</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span>
</code></pre></div></div>
<ul>
  <li>매개변수가 2개인 경우  <code class="highlighter-rouge">BiFunction&lt;T, U, R&gt;</code></li>
</ul>

<p>전달한 인자와 반환 값이 모두 존재하는 가장 보편적인 형태이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FunctionDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
    <span class="n">Function</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">toInt</span> <span class="o">=</span> <span class="n">value</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>

    <span class="n">Integer</span> <span class="n">number</span> <span class="o">=</span> <span class="n">toInt</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"100"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="함수형-인터페이스의-장점">함수형 인터페이스의 장점?</h3>
<p>이 부분은 여러 자료를 찾아보면서 스스로 생각해본 부분이다.</p>
<h4 id="간결한-표현과-가독성">간결한 표현과 가독성</h4>
<h4 id="행위도-값value처럼-쓰일-수-있다">행위도 값(value)처럼 쓰일 수 있다</h4>
<p>1~100까지의 짝수 합을 구하는 로직을 함수형 인터페이스를 사용하지 않고,<br />
함수형 인터페이스를 사용하여 두 가지 코드를 확인해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">evenSum</span><span class="o">()</span> <span class="o">{</span>  
   <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
         <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">evenSum</span><span class="o">()</span> <span class="o">{</span>  
   <span class="k">return</span> <span class="n">IntStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
         <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span><span class="mi">0</span><span class="o">)</span>
         <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">filter()</code>의 선언부를 보면 다음과 같다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/36ce9ae6-d645-4754-9b55-408a3509599a/image.png" style="zoom:50%;" /></p>

<p><code class="highlighter-rouge">Predicate&lt;&gt;</code> 함수형 인터페이스를 받기 때문에 조건에 대한 함수를 매개변수로 받아,<br />
행위 자체를 값으로 받고 있다.<br />
또한 이 덕분에 filter()에 매개변수로 행위가 어떤 것인지 람다식으로 명시적으로 드러내며 <br />
넘겨주기 때문에 직관성을 높인다고도 생각한다. (맞는지는 모르겠으나 개인적 생각🥲)</p>

<p>함수형 인터페이스의 명확한 장점을 말하고 싶은데,<br />
잘 정리가 안된다.<br />
이에 대해 <a href="http://ruaa.me/why-functional-matters/">함수형 프로그램의 장점</a>을 읽어 보는 것이 좋을 것 같다(❓)</p>
<h2 id="참고-자료">참고 자료</h2>
<ul>
  <li><a href="https://jogeum.net/18">자바로 함수형 인터페이스 사용하기 (Functional Interface)</a></li>
  <li><a href="https://woowacourse.github.io/javable/post/2020-07-17-Functional-Interface/">Functional Interface란</a></li>
  <li><a href="http://ruaa.me/why-functional-matters/">왜 함수형 프로그래밍이 좋을까?</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>추상 클래스와 인터페이스의 차이</title>
	  <link>//%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC-%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA-%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8B%E1%85%B4-%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%B5</link>
	  <author></author>
	  <pubDate>2021-03-05T19:18:00+09:00</pubDate>
	  <guid>//%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC-%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA-%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8B%E1%85%B4-%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%B5</guid>
	  <description><![CDATA[
	     <h2 id="추상-클래스">추상 클래스</h2>

<p><strong>간단히 말하면…</strong><br />
클래스를 설계도라 하면, 추상 클래스는 <strong>미완성 설계도</strong>에 비유할 수 있다.<br />
(여기서 클래스가 미완성이라는 것은 추상 메서드를 포함하고 있다는 의미이다.)</p>

<p>예를 들면, 같은 크기의TV라도 기능의 차이에 따라 여러 종류의 모델이 있지만<br />
설계도 90은 동일할테니, 어느정도 틀을 갖춘 상태에서 진행하는 것이 좋다.<br />
이때 사용할 수 있는 것이 <strong>추상 클래스</strong>이다.</p>

<h4 id="추상-메서드-">추상 메서드 ?</h4>

<p>선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다.<br />
추상 메서드는 상속받는 클래스에 따라 달라질 수 있다.</p>

<h3 id="추상-클래스-규칙">추상 클래스 규칙</h3>

<ul>
  <li>추상 클래스는 키워드 <code class="highlighter-rouge">abstract</code>를 붙여 표현한다.
추상 메서드를 포함하지 않은 클래스에서도 <code class="highlighter-rouge">abstract</code>를 붙여서 추상 클래스로 지정할 수도 있다.</li>
  <li>클래스를 abstract로 지정하면 <code class="highlighter-rouge">new</code>를 통해 객체를 직접 생성할 수 없다.</li>
  <li>메소드에 abstract를 사용할 경우 interface의 메소드와 같이 구현 부분은 없다.</li>
  <li>abstract로 선언한 메소드를 자식 클래스에서 반드시 구현해야 한다. (오버라이딩)
이는 자식 클래스에서 추상 메서드를 반드시 구현하도록 강제하는 것이다.</li>
</ul>

<p>다음 예제를 보면서 추상 클래스에 대해 알아보자 !</p>

<h4 id="exmaple">Exmaple</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Player</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">pause</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">currentPos</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Player</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pause</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">currentPos</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 지정된 위치에서 재생을 시작하는 기능 수행되도록 작성</span>
    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">(</span><span class="kt">int</span> <span class="n">pos</span><span class="o">);</span>
    <span class="c1">// 재생을 즉시 멈추는 기능을 수행하도록 작성</span>
    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">pause</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pause</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pause</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">play</span><span class="o">(</span><span class="n">currentPos</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">pause</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">stop</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Player 추상 클래스는 <br />
VCR이나 Audio 같은 재생이 가능한 기기의 부모 클래스가 될 수 있다.<br />
이제 Player 추상 클래스를 상속받는 CDPlayer 클래스를 만들어보자 🔨</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CDPlayer</span> <span class="kd">extends</span> <span class="n">Player</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">play</span><span class="o">(</span><span class="kt">int</span> <span class="n">pos</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 구현 생략</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 구현 생략</span>
    <span class="o">}</span>

    <span class="c1">//CDPlayer 클래스에 추가로 정의된 멤버</span>
    <span class="kt">int</span> <span class="n">currentTrack</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">nextTrack</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">currentTrack</span><span class="o">++;</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">preTrack</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">currentTrack</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">currentTrack</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>부모 클래스의 추상메서드를 CDPlayer에 맞게 오버라이딩해주고, <br />
CDPlayer만의 새로운 멤버들을 추가해주었다.</p>

<h2 id="인터페이스">인터페이스</h2>

<p><strong>간단히 말하면…</strong><br />
인터페이스는 일종의 추상 클래스로, 추상 메서드를 갖지만 <br />
추상 클래스보다 추상화 정도가 높아<br />
추상 클래스와 달리 몸통을 갖춘 일반 메서드, 멤버 변수를 구성원으로 가질 수 없다.<br />
추상 클래스를 미완성 설계도라 하면, 인터페이스는 구현된 것은 아무 것도 없는, <br />
밑그림만 그려진 <strong>기본 설계도</strong>라고 할 수 있다.</p>

<h3 id="인터페이스-규칙">인터페이스 규칙</h3>

<ul>
  <li>추상 클래스처럼 불완전한 것이기 때문에 그 자체만으로 사용되기 보다,
다른 클래스를 작성하는데 도움을 줄 목적으로 작성된다.</li>
  <li>일반 메서드 또는 멤버 변수를 구성원으로 가질 수 없다.</li>
  <li>모든 멤버 변수는 <code class="highlighter-rouge">public static final</code>이어햐 하며, 이를 생략할 수 있다.</li>
  <li>모든 메서드는 <code class="highlighter-rouge">public abtract</code>이어야 하며, 이를 생략할 수 있다.
(단, JDK1.8부터 static 메서드와 default 메서드를 사용할 수 있다.)</li>
</ul>

<p><strong>🤔 public static final의 사용 목적 ?</strong><br />
인터페이스 변수는 아무 인스턴스도 존재하지 않는 시점이기 떄문에 스스로 초기화 될 권한이 없다.<br />
때문에 <code class="highlighter-rouge">public static final</code>를 사용해 구현 객체의 같은 상태를 보장한다.</p>

<h3 id="인터페이스의-다중-상속">인터페이스의 다중 상속</h3>

<p>인터페이스는 인터페이스로부터만 상속받을 수 있으며,<br />
클래스와 달리 다중상속을 받는 것이 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Movable</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">move</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Attackable</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">attack</span><span class="o">(</span><span class="n">Unit</span> <span class="n">u</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Fightable</span> <span class="kd">extends</span> <span class="n">Movable</span><span class="o">,</span> <span class="n">Attackable</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p>클래스의 상속과 마찬가지로 자식 인터페이스는 부모 인터페이스에 정의된 멤버 모두 상속받는다.</p>

<p><strong>인터페이스가 다중 상속이 가능한 이유는?</strong>
인터페이스는 abstract 메소드만을 가지고 있는데,<br />
이를 상속할 경우 상속하는 클래스에서 무조건 그 메서드를 구현해주어야 하는데,<br />
이 경우 다중 상속하고 있는 인터페이스들에 동일한 메서드가 존재한다 하더라도,<br />
그 내부 구현은 정의되지 않았으니 문제될 것이 없기 때문이 아닐까 한다.</p>

<p>그런데 이제 인터페이스에서 default 메서드를 구현할 수 있는데<br />
두개의 인터페이스를 다중 상속하는 경우, <br />
이 default 메소드가 중복이 되면 어떻게 되는거지?</p>

<p>이 질문에 대한 답을 테스트 해보았다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/3bff8105-2d84-4583-ad1b-e208b362f524/image.png" style="zoom:50%;" /></p>

<p>동일한 <code class="highlighter-rouge">printStatic()</code> 을 가진 인터페이스 C와 B를 상속하는 <br />
인터페이스 A는 <code class="highlighter-rouge">printStatic()</code>를 무조건 오버라이딩하게 되어 있었다…<br />
만약 중복 메서드가 없을 경우 오버라이딩을 하지 않아도 컴파일 에러가 나지 않는다.</p>

<h4 id="-tip">🍯 Tip</h4>

<p>인터페이스 명은 대부분 “~을 할 수 있는”의 의미인 <code class="highlighter-rouge">able</code>로 끝나는 것들이 많다고 한다.<br />
그 이유는 어떤 기능 또는 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서다.<br />
때문에 그 인터페이스를 구현하는 클래스는 “~를 할 수 있는” 능력을 갖추었다는 의미이기도 하다.</p>

<h2 id="추상-클래스-vs-인터페이스">추상 클래스 VS 인터페이스</h2>

<h4 id="공통점-">공통점 ?</h4>

<p>먼저 추상 클래스와 인터페이스의 공통점을 찾아보자. <br />
추상 클래스와 인터페이스 둘 다 <strong>가지고 있는 추상 메서드를 구현하도록 강제한다.</strong><br />
또 <strong>인스턴스화가 불가능</strong>하다.</p>

<p>그렇다면 추상 클래스 안에 원하는 것만 추상 메서드를 여러개 두거나,<br />
전부 추상 메서드로 만들면 되어 추상 클래스가 인터페이스 역할을 할 수 있다.<br />
만약 모든 클래스가 인터페이스만 사용해서 구현한다면,<br />
모든 클래스에서 공통으로 필요한 기능들은 각각 오버라이딩 하게 되니 코드의 중복이 발생한다.<br />
때문에 이 공통으로 필요한 기능들을 부모 클래스에서 일반 메서드로 구현한<br />
추상클래스를 상속 받아 자식 클래스에서 사용할 수 있도록 하면 될거같은데…<br />
<strong>왜 인터페이스는 왜 필요한걸까? 🤔</strong></p>

<h3 id="접근자">접근자</h3>

<p><strong>인터페이스</strong>에서 모든 변수는 <code class="highlighter-rouge">public static final</code>, <br />
모든 메소드는 <code class="highlighter-rouge">public abstract</code>이다.<br />
하지만 <strong>추상 클래스</strong>에서는 <code class="highlighter-rouge">static</code>이나 <code class="highlighter-rouge">final</code>이 아닌 필드를 가질 수 있고, <br />
<code class="highlighter-rouge">public, protected, private</code> 모두 가질 수 있다.</p>

<p>개인적인 생각으로는 인터페이스만을 구현하면 <code class="highlighter-rouge">public static final</code>만을 사용해<br />
구현 객체의 같은 상태를 공유할수 밖에 없는데,<br />
추상 클래스는 <code class="highlighter-rouge">static</code>이나 <code class="highlighter-rouge">final</code>이 아닌 필드또한 가질 수 있기 때문에 <br />
추상 클래스를  상속 받은 객체들이 같은 상태를 가지고 있을 수 있다.</p>

<h3 id="다중-상속-여부">다중 상속 여부</h3>

<p><strong>인터페이스</strong>를 구현하는 클래스는 다른 여러개 인터페이스를 함께 구현할 수 있다.<br />
하지만 자바에서는 다중 상속을 지원하지 않기 때문에 여러 추상 클래스를 상속할 수 없다.</p>

<h3 id="사용-의도">사용 의도</h3>

<p>물론 다중 상속 여부의 차이는 있지만 이것이 포인트가 아니라,<br />
이에 따른 사용 목적이 다르다는 것에 포인트를 맞춰보자.<br />
위에서 말한 다중 상속 여부에 따라 추상 클래스와 인터페이스의 사용 의도 또한 다르다.</p>

<p><strong>추상 클래스</strong>는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로,<br />
상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며 <br />
부모 클래스가 가진 기능들을 구현해야할 경우 사용한다.</p>

<p><strong>인터페이스</strong>는 상속 관계를 타고 올라갔을 때 <br />
다른 조상 클래스를 상속하더라도, 같은 기능이 필요할 경우 사용한다.<br />
클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용한다.</p>

<h4 id="exmaple-1">Exmaple</h4>

<p>아래와 같은 관계를 갖는 예제를 살펴본다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/af9d99ef-28f2-483f-a261-161cb979fb4a/image.png" style="zoom:50%;" /></p>

<p>제일 부모 클래스인 Creature은 생물에 대한 Abstract Class이다.<br />
각 생물은 구분에 따라 Animal 또는 Plant를 상속한다.<br />
그리고 각각이 할 수 있는 추가적인 기능들을 인터페이스로 구현했다.</p>

<p>Animal을 상속받는 Amazzi(나^^), Dog, Cat은 Plant와 다르게<br />
bark(짖다) 할 수 있으니 Barkable 인터페이스를 구현하였다.</p>

<p>여기서 눈여겨 볼 것은 바로 Eatable인데, <br />
Eatable 인터페이스는 현재 상속 관계가 다른 Amazzi(나^^), Dog, Cat, FlyHellPlant에게<br />
공통적인 기능인 Eat 기능을 인터페이스를 사용함으로 같은 기능을 구현하도록 강제하고 있다.</p>

<p>그러면 결국 이 4가지 클래스 모두 생물 클래스를 상속하고 있는데,<br />
생물 클래스에 eat이라는 추상 메서드를 만들면 안되는가?라고 생각할 수 있지만<br />
Plant를 상속받은 Rose는 eat 메소드를 가질 수 없다.</p>

<p>그러면 어떻게하지 🤷‍♀️</p>

<p>이때 바로 인터페이스로 따로 선언을 해주어 각각 eat을 할 수 있는 <br />
클래스에 implements해주어 만들어 주면 <strong>가독성이 올라가며 유지보수 또한 쉬워진다.</strong></p>

<h3 id="각각의-적절한-사용-케이스-정리">각각의 적절한 사용 케이스 정리</h3>

<h4 id="추상-클래스-1">추상 클래스</h4>

<ul>
  <li>관련성이 높은 클래스 간에 코드를 공유하고 싶은 경우</li>
  <li>추상 클래스를 상속 받을 클래스들이 공통으로 가지는 메소드와 필드가 많거나, 
public이외의 접근자(protected, private) 선언이 필요한 경우</li>
  <li>non-static, non-final 필드 선언이 필요한 경우 (각 인스턴스에서 상태 변경을 위한 메소드가 필요한 경우)</li>
</ul>

<h4 id="인터페이스-1">인터페이스</h4>

<ul>
  <li>서로 관련성이 없는 클래스들이 인터페이스를 구현하게 되는 경우. 
ex) Comparable, Cloneable 인터페이스는 여러 클래스들에서 구현되는데, 구현클래스들 간에 관련성이 없다.</li>
  <li>특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동이 구현되는지는 신경쓰지 않는 경우.</li>
  <li>다중상속을 허용하고 싶은 경우</li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li>[[JAVA] 추상클래스 VS 인터페이스 왜 사용할까? 차이점, 예제로 확인 :: 마이자몽](</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>📖 상속에 대하여</title>
	  <link>//%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%8B%E1%85%A6-%E1%84%83%E1%85%A2%E1%84%92%E1%85%A1%E1%84%8B%E1%85%A7</link>
	  <author></author>
	  <pubDate>2021-03-04T19:18:00+09:00</pubDate>
	  <guid>//%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%8B%E1%85%A6-%E1%84%83%E1%85%A2%E1%84%92%E1%85%A1%E1%84%8B%E1%85%A7</guid>
	  <description><![CDATA[
	     <p>강의시간에 배운 상속 개념에 추가로 공부한 내용을 정리해본다 ✍️</p>

<h2 id="상속">상속</h2>
<p><strong>먼저 상속이란 ?</strong>
기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.<br />
예제를 보명서 상속의 필요성을 파악해보자 !</p>

<h3 id="example">Example</h3>
<p>카페에서 커피와 차를 판매한다.<br />
커피와 차를 준비하는 과정을 살펴보자.</p>

<h4 id="커피">커피</h4>
<ul>
  <li>물을 끓인다.</li>
  <li>커피머신으로 커피를 내린다.</li>
  <li>컵에 붓는다.</li>
  <li>설탕과 우유를 추가한다.
    <h4 id="차">차</h4>
  </li>
  <li>물을 끓인다.</li>
  <li>차 티백을 담근다.</li>
  <li>컵에 붓는다.</li>
  <li>레몬을 추가한다.</li>
</ul>

<p>그렇다면 각각의 과정들을 코드로 구현해본다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Coffee</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">prepareRecipe</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">boilWater</span><span class="o">();</span>
        <span class="n">brewCoffeeMachine</span><span class="o">();</span>
        <span class="n">pourInCup</span><span class="o">();</span>
        <span class="n">addSugarAndMilk</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">boilWater</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"물을 끓인다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">brewCoffeeMachine</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"커피머신으로 커피를 내린다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pourInCup</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"컵에 붓는다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addSugarAndMilk</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"설탕과 우유를 추가한다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tea</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">prepareRecipe</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">boilWater</span><span class="o">();</span>
        <span class="n">steepTeaBag</span><span class="o">();</span>
        <span class="n">pourInCup</span><span class="o">();</span>
        <span class="n">addLemon</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">boilWater</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"물을 끓인다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">steepTeaBag</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"티백을 담근다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pourInCup</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"컵에 붓는다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addLemon</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"레몬을 추가한다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Coffee 클래스와 Tea 클래스를 비교해보면 이상한 점을 느낄 수 있다.<br />
<code class="highlighter-rouge">prepareRecipe()</code>, <code class="highlighter-rouge">boilWater()</code>, <code class="highlighter-rouge">pourInCup()</code> <br />
이 세가지 메소드는 공통된 기능을 하지 않는가??</p>

<p>그렇다면 “이 중복된 부분을 어떻게 제거하느냐?”에 대한 해답으로<br />
바로 <strong>상속</strong>이 나온다.</p>

<p>그렇다면 두 클래스에서 공통된 부분을 추출하여 부모 클래스를 만들어본다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Beverage</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">boilWater</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"물을 끓인다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">pourInCup</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"컵에 붓는다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>공통된 기능을 묶은 부모 클래스인 Beverage를 상속 받는 각각의 클래스를 만들어본다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Coffee</span> <span class="kd">extends</span> <span class="n">Beverage</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">prepareRecipe</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">boilWater</span><span class="o">();</span>
        <span class="n">brewCoffeeMachine</span><span class="o">();</span>
        <span class="n">pourInCup</span><span class="o">();</span>
        <span class="n">addSugarAndMilk</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">brewCoffeeMachine</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"필터를 활용해 커피를 내린다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addSugarAndMilk</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"설탕과 우유를 추가한다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tea</span> <span class="kd">extends</span> <span class="n">Beverage</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">prepareRecipe</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">boilWater</span><span class="o">();</span>
        <span class="n">steepTeaBag</span><span class="o">();</span>
        <span class="n">pourInCup</span><span class="o">();</span>
        <span class="n">addLemon</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">steepTeaBag</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"티백을 담근다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addLemon</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"레몬을 추가한다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h3 id="extends">extends</h3>
<p>이렇게 상속은 <code class="highlighter-rouge">extends</code> 키워드로 이루어 진다.<br />
상속을 할 경우 멤버 필드와 메소드를 하위 클래스에서 그대로 상속하게 되는데,<br />
키워드의 의미대로 자식 클래스가 조상 클래스를 확장하는 의미로 해석할 수 있다.<br />
<strong>여기서 주의점 !</strong></p>

<ul>
  <li>생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.</li>
  <li>자식 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.</li>
  <li>private, default는 상속되지 않는다기 보다는 상속은 받지만 자식 클래스로부터의 접근이 제한된다.</li>
  <li>자바에서는 다중 상속을 지원하지 않는다.</li>
</ul>

<h2 id="오버라이딩">오버라이딩</h2>
<p>조상 클래스로부터 상속 받은 메서드의 내용을 변결하는 것<br />
자식 클래스에서 부모 클래스 메서드를 맞게 변경하는 경우 오버라이딩을 한다.</p>

<h3 id="오버라이딩의-조건">오버라이딩의 조건</h3>
<p>자식 클래스의 메소드에서 부모 클래스의 메소드와 다음 조건들이 같아야 한다.</p>
<ul>
  <li>메소드 명</li>
  <li>매개변수</li>
  <li>반환타입
    <h3 id="오버라이딩-주의점">오버라이딩 주의점</h3>
  </li>
  <li>접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.</li>
  <li>예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.</li>
  <li>인스턴스메서드를 static 메서드, 또는 그 반대로 변경할 수 없다.</li>
</ul>

<p><strong>🤔 조상 클래스에 정의된 static 메서드를 자손 클래스에서 똑같은 이름의 static 메서드로 정의할 수 있나?</strong><br />
가능은 하지만 각 클래스에 별개의 static 메서드를 정의한 것일 뿐 오버라이딩이 아니다.</p>

<h3 id="상속의-장점">상속의 장점</h3>
<ul>
  <li>중복된 코드를 줄일 수 있다.</li>
  <li>공통적 필드를 추가하거나, 수정할 때 부모 클래스에만 작업해주면 된다.</li>
</ul>

<h3 id="클래스간의-관계">클래스간의 관계</h3>
<p>상속을 통해 클래스간에 관계를 맺어주는데, <br />
이때 생기는 관계를 몇 가지 유형으로 나눠볼 수 있다.</p>

<h4 id="is-a-관계-is-a-relationship">is-a 관계 (is a relationship)</h4>
<p>is-a 관계는 일반적인 개념과 구체적인 개념과의 관계를 말한다.<br />
여기서 일반적인 개념 클래스는 상위 클래스인 부모 클래스를 뜻하고,<br />
구체적인 개념 클래스는 하위 클래스인 자식 클래스를 뜻한다.</p>

<p>말 그대로 <strong>“~은 ~이다.”라는 문장이 성립되어야 한다.</strong></p>
<ul>
  <li>Example
```java
public class Person{
String name; 
int age; 
}</li>
</ul>

<p>public class Student extends Person{
int number; 
int major; 
}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>위 예제에서는 Student 클래스가 Person 클래스를 상속받고 있다.  
"학생은 사람이다."처럼 이러한 관계를 is-a 관계라고 한다.

#### has-a 관계 (composition)
has-a 관계는 한 클래스가 다른 클래스를 소유한 관계이다.

말 그대로 **"~은 ~을 가지고 있다."라는 문장이 성립되어야 한다.**
* Example
```java
class Circle {
    Point point;
    int r;
} 

class Point {
    int x;
    int y;
}
</code></pre></div></div>
<p>위 예제에서는 Point 클래스를 재사용해서 Circle 클래스를 작성했다.<br />
하나의 거대한 클래스를 작성하는 것보다 단위별로 여러 개의 클래스를 작성한 후,<br />
이 단위 클래스들을 포함관계로 재사용하면 보다 간결하고 손쉽게 클래스를 작성할 수 있다.<br />
또 작성된 단위 클래스들은 다른 클래스를 작성하는데 재사용될 수 있다.</p>

<p>“~은 ~이다.” 또는 “~은 ~을 가지고 있다.” 문장을 만들어보고<br />
더 적합한 관계를 구현하는 것이 좋다.</p>

<p>(이펙티브 자바에 “상속보단 조합”이라는 개념이 있던데 이 부분도 정리해보아야겠다.)</p>

<h2 id="캐스팅">캐스팅</h2>
<p><strong>🤔 캐스팅이란 ?</strong>
타입을 변환하는 것을 말하며, 형변환이라고도 한다.<br />
기본형 변수와 같이 참조변수도 형변환이 가능한데, 상속 관계에 있는 클래스 사이에서만 가능하다.</p>

<p>이때, 기본형 참조형 변수의 형변환에서 자손 타입의 참조변수를 조상타입으로 <br />
형변환하는 경우에는 형변환을 생략할 수 있다.</p>

<h3 id="업캐스팅">업캐스팅</h3>
<p>자식 클래스의 참조변수를 부모 클래스의 참조변수로 변환하며, 형변환 생략이 가능하다.<br />
부모 클래스의 참조 변수가 자식 클래스로 객체화된 인스턴스를 가리킬 수 있다.<br />
때문에 다형성을 위해 사용된다.<br />
ex) 학생은 사람이다.</p>

<p>위에서 다뤘던 Student 예제로 확인해보자.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 참조변수 student를 이용하면 number, major에 접근 가능</span>
<span class="n">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">();</span>

<span class="c1">// 레퍼런스 person을 이용하면 Student 객체의 멤버 중 </span>
<span class="c1">// 오직 Person 클래스의 멤버만 접근이 가능하다.</span>
<span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="n">student</span><span class="o">;</span>
<span class="n">person</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"amazzi"</span><span class="o">;</span>
<span class="n">person</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

<span class="c1">// 아래 문장은 컴파일 오류가 난다.</span>
<span class="n">person</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="s">"12345678"</span><span class="o">;</span>
</code></pre></div></div>

<p>이처럼 업캐스팅을 하게되면 부모 클래스의 필드, 메서드에만 접근이 가능하다.</p>

<h3 id="다운캐스팅">다운캐스팅</h3>
<p>자식 클래스의 참조변수를 자식 타입의 참조변수로 변환하며, 형변환 생략이 불가능하다.<br />
자신의 고유한 특성을 잃은 서브 클래스의 객체를 다시 복구 시켜주는 것을 말한다. (업캐스팅 복구?)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 업캐스팅 먼저</span>
<span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">();</span>

<span class="c1">// 다운캐스팅</span>
<span class="n">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="o">(</span><span class="n">Student</span><span class="o">)</span> <span class="n">person</span><span class="o">;</span>

<span class="c1">// Ok</span>
<span class="n">student</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"amazzi"</span><span class="o">;</span>
<span class="n">student</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="s">"12345678"</span><span class="o">;</span>
</code></pre></div></div>

<p>꼭 업캐스팅이 먼저 선행이 되어야 한다.<br />
만약 다음과 같은 경우는 컴파일 오류는 나지 않지만 <code class="highlighter-rouge">ClassCastException</code> 런타임 오류가 발생한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="o">(</span><span class="n">Student</span><span class="o">)</span> <span class="k">new</span> <span class="n">Person</span><span class="o">();</span>
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>📖 BigDecimal에 관한 고찰</title>
	  <link>//BigDecimal%E1%84%8B%E1%85%A6-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%80%E1%85%A9%E1%84%8E%E1%85%A1%E1%86%AF</link>
	  <author></author>
	  <pubDate>2021-03-01T19:18:00+09:00</pubDate>
	  <guid>//BigDecimal%E1%84%8B%E1%85%A6-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%80%E1%85%A9%E1%84%8E%E1%85%A1%E1%86%AF</guid>
	  <description><![CDATA[
	     <p>이번 미션에서 <code class="highlighter-rouge">BigDecimal</code>에 대한 언급이 많았는데,<br />
<strong>도대체 그게 뭐지 🤷‍♀️ 나만 몰라 ❓</strong><br />
에서부터 출발한 BigDecimal에 대한 고찰 ~</p>

<p><del>이번주 회고에서 앞으로 포스팅을 내가 이해한 글을 설명하듯이 ! 작성하기로 다짐한
내용을 최대한 반영하려고 노력중 ✍️
누군가 이 글을 읽고 있다면 아 얘가 이런짓을 하고 있구나 가볍게 봐주길 ㅎㅎ 🙈</del></p>

<h2 id="bigdecimal을-왜-쓰지-">BigDecimal을 왜 쓰지 ?</h2>
<h4 id="test">Test</h4>
<p><img src="https://images.velog.io/images/new_wisdom/post/005a8086-2456-4ebb-9162-45a415ddb471/image.png" style="zoom:50%;" /></p>

<p>과연 위 테스트 케이스는 통과를 할까? 정답은 👀</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/1a1ea170-2681-4f65-b8af-842b4316a1ae/image.png" style="zoom:50%;" /></p>

<p>허허 어이없게도 실패합니다.<br />
왜 실패하냐구요 ?<br />
자바는 IEEE 754 부동 소수점 방식을 사용해서, <br />
정확한 실수를 저장하지 않고 최대한 완벽에 가깝기를 바라는 근사치 값을 저장하기 때문이다 !</p>

<p>지금은 단순히 개발자 하나가 테스트를 위해 작성한 코드이지만,<br />
금융권에서 달러를 다루는 개발자가 double을 이용해서 이런 사소한 값 차이가 발생한다면 🙃</p>

<p>그렇다면 이 문제를 어떻게 해결하느냐 !<br />
우리에겐 부동 소숫점 방식이 아닌, 정수를 이용해 실수를 표현하는 <code class="highlighter-rouge">java.math.BigDecimal</code> 클래스가 있다.</p>

<p>Java 언어에서 돈과 소수점을 다룬다면 BigDecimal은 <strong>선택이 아니라 필수</strong>다.</p>

<p>그렇다면 본격적으로 BigDecimal을 해부해 봅시다.</p>
<h2 id="bigdecimal-클래스">BigDecimal 클래스</h2>
<p><img src="https://images.velog.io/images/new_wisdom/post/239a603a-92ad-42c8-8db1-b9666e30b392/image.png" style="zoom:50%;" /></p>

<p><code class="highlighter-rouge">BigDecimal</code> 클래스의 일부를 가져왔다.<br />
여기서 간단하게 몇 가지 변수들의 쓰임 짚고 넘어가겠다.<br />
<em>참고로 BigDecimal은 불변 클래스임</em></p>

<h4 id="변수">변수</h4>
<ul>
  <li>intValue : 정수. 정수를 저장하는데 <code class="highlighter-rouge">BigInteger</code>를 사용한다.</li>
  <li>scale : 지수. 정확히는 소수점 첫째 자리부터 0이 아닌 수로 끝나는 위치까지의 총 소수점 자리수이다.</li>
  <li>precision : 정밀도. 정확히는 0이 아닌 수가 시작하는 위치부터 오른쪽부터 0이 아닌 수로 끝나는 위치까지의 총 자리수이다.
아래 출력 결과로 각 변수의 의미를 파악하자.</li>
  <li><img src="https://images.velog.io/images/new_wisdom/post/852fce1a-773b-423e-8925-a677f8bb63da/image.png" style="zoom:50%;" /></li>
</ul>

<h2 id="bigdecimal의-생성">BigDecimal의 생성</h2>
<p>BigDecimal의 생성 방법은 여러가지가 있는데, <br />
문자열로 숫자를 표현하는 것이 일반적이다.<br />
기본형 리터럴로는 표현할 수 있는 값의 한계가 있는데, 예를 들어<br />
double 타입의 값을 그대로 전달할 경우<br />
앞서 사칙연산 결과에서 본 것과 같이 예상과 다른 값을 얻을 수도 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">;</span>
<span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BigDecimal</span><span class="o">(</span><span class="s">"12345.6789"</span><span class="o">);</span>
<span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BigDecimal</span><span class="o">(</span><span class="mf">12345.678</span><span class="o">);</span> <span class="c1">// 오차가 날 수 있음</span>
<span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BigDecimal</span><span class="o">(</span><span class="mi">12345</span><span class="o">);</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">BigDecimal</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mf">12345.67</span><span class="o">);</span> <span class="c1">// 오차가 날 수 있음</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">BigDecimal</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">123456</span><span class="o">);</span>
</code></pre></div></div>

<p><img src="https://images.velog.io/images/new_wisdom/post/b2c32896-9f79-4931-871e-b38f26c09480/image.png" style="zoom:50%;" /></p>

<p>실제로 인텔리제이도 String으로 바꾸라고 알려준다 👀 똑똑이</p>

<h2 id="bigdecimal의-비교">BigDecimal의 비교</h2>
<p>BigDecimal은 <code class="highlighter-rouge">Comparable&lt;BigDecimal&gt;</code>를 구현하고 있기 때문에,<br />
<code class="highlighter-rouge">equals()</code>를 통해 내용을 비교할 수 있다.<br />
여기서 주의할 점은 <code class="highlighter-rouge">12.01</code>과 <code class="highlighter-rouge">12.010</code>은 같지 않다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/0eec192e-2454-4905-be4b-48aa984f4f6e/image.png" style="zoom:50%;" /></p>

<h2 id="bigdecimal의-타입-변환">BigDecimal의 타입 변환</h2>
<h3 id="문자열로-변환">문자열로 변환</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span> <span class="nf">toPlainString</span><span class="o">();</span> <span class="c1">// 무조건 다른 기호 없이 숫자로만 표현</span>
<span class="n">String</span> <span class="nf">toString</span><span class="o">();</span> <span class="c1">// 필요시 지수 형태로 표현할 수도 있음</span>
</code></pre></div></div>

<p><img src="https://images.velog.io/images/new_wisdom/post/2be425da-32bf-497a-9f2e-47d2a96106a6/image.png" style="zoom:50%;" /></p>

<p>또 <code class="highlighter-rouge">Number</code>를 상속받고 있기 때문에 <code class="highlighter-rouge">Number</code>의 기본형으로 변환하는 메서드를 가지고 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">intValue</span><span class="o">()</span>
<span class="kt">long</span> <span class="nf">longValue</span><span class="o">()</span>
<span class="kt">float</span> <span class="nf">floatValue</span><span class="o">()</span>
<span class="kt">double</span> <span class="nf">doubleValue</span><span class="o">()</span>
</code></pre></div></div>

<p>또 BigDecimal을 정수형으로 변환하는 메서드 중,<br />
이름 끝에 <code class="highlighter-rouge">Exact</code>가 붙은 것은 변환 결과가 변환 타입 범위에 속하지 않으면<br />
<code class="highlighter-rouge">ArithmeticException</code>을 발생시킨다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/6e38065d-30b2-4c9d-91b4-9d539b5130a3/image.png" style="zoom:50%;" /></p>

<p>테스트 성공 !</p>

<h2 id="bigdecimal의-연산">BigDecimal의 연산</h2>
<p>먼저 기본적인 연산을 수행하는 메서드들이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BigDecimal</span> <span class="nf">add</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">subtract</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">multiply</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">divide</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">remainder</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">)</span>
</code></pre></div></div>

<p><img src="https://images.velog.io/images/new_wisdom/post/b028fbb0-5e1d-4802-9cb6-ad0de651b9a1/image.png" style="zoom:50%;" /></p>

<p>테스트 성공 !</p>

<p><strong>참고로 BigDecimal은 불변 객체이기 때문에 
연산 후 반환 타입이 BigDecimal인 경우 새로운 인스턴스가 반환된다.</strong></p>

<p>추가로 다른 연산과 달리 <code class="highlighter-rouge">divide()</code>은 메서드가 다양한 버전으로 오버로딩 되어있다.<br />
어떻게 반올림할지(roundingMode), 몇 번째 자리(scale)에서 반올림 할건지를 지정할 수 있다.</p>

<h4 id="roundingmode">roundingMode</h4>
<p>반올림 처리 방법에 대한 것으로 BigDecimal에 정의된 다음 상수들에서 하나를 선택해 사용하면 된다.</p>
<ul>
  <li>CEILING – 올림</li>
  <li>FLOOR – 내림</li>
  <li>UP – 양수일 경우 올림, 음수일 경우 내림</li>
  <li>DOWN – 양수일 경우 내림, 음수일 경우 올림</li>
  <li>HALF_UP – 반올림(5이상 올림, 5미만 버림)</li>
  <li>HALF_EVEN – 반올림(반올림 자리의 값이 짝수면 HALF_DOWN, 홀수면 HALF_UP)</li>
  <li>HALF_DOWN – 반올림(6이상 올림, 6미만 버림)</li>
  <li>UNNECESSARY – 나눗셈 결과가 딱 떨어지지 않으면,<code class="highlighter-rouge">ArithmeticException</code> 발생</li>
</ul>

<h4 id="scale-변경">scale 변경</h4>
<p>소수점 위치를 바꾸고 싶을 때는 BigDecimal을 10으로 곱하거나 나누는 것이 아니라,<br />
<code class="highlighter-rouge">setScale()</code>을 통해 scale 값을 변경한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BigDecimal</span> <span class="nf">setScale</span><span class="o">(</span><span class="kt">int</span> <span class="n">newScale</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">setScale</span><span class="o">(</span><span class="kt">int</span> <span class="n">newScale</span><span class="o">,</span> <span class="kt">int</span> <span class="n">roundingMode</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">setScale</span><span class="o">(</span><span class="kt">int</span> <span class="n">newScale</span><span class="o">,</span> <span class="n">RounfingMode</span> <span class="n">mode</span><span class="o">)</span>
</code></pre></div></div>

<p>주의할 점은 <code class="highlighter-rouge">setScale()</code>로 scale을 줄이는 것은 10의 n제곱으로 나누는 것과 같으므로<br />
오차가 발생할 수 있으니 roundingMode를 지정하는 것이 좋다.</p>

<h2 id="생성자-대신-valueof를-사용해라-">생성자 대신 valueOf()를 사용해라 !</h2>
<p>이 부분은 개인적인 고찰이니 혹시나 이 글을 누군가 읽고 잘못된 부분이 있다면 반박 부탁드림다 🙈<br />
BigDecimal은 생성자와 정적 팩터리 메서드인 <code class="highlighter-rouge">valueOf()</code>를 사용해서 객체를 생성할 수 있는데,<br />
<strong>과연 두 개는 어떤 것이 다를까 ❓</strong></p>

<p>고것이 궁금해졌다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/12cdd08d-4e5e-4353-b820-8ff52f4a185c/image.png" style="zoom:50%;" /></p>

<p>일단 BigDecimal은 Integer클래스처럼 일부 값을 캐싱해 놓고 있다.<br />
왜일까 스스로 답을 해보았는데,</p>

<p>BigDecimal의 주생성자를 가보면,</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/6db0f234-25ad-4a33-9677-c7c7ecb84cac/image.png" style="zoom:50%;" /></p>

<p>정말 장황한 생성자를 볼 수 있다.<br />
때문에 BigDecimal이 성능이 느리다고도 하는데,<br />
내 생각에는 이러한 이유 때문에도 캐싱을 해논게 아닌가 싶다.</p>

<p>이쯤에서 정적 팩터리 메서드인<code class="highlighter-rouge">valueOf()</code>로 가보면,</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/df153dae-d768-461d-956c-996b2d689bf8/image.png" style="zoom:50%;" /></p>

<p>정적 팩터리 메서드는 static 변수인 캐싱 값에 바로 접근할 수 있다.<br />
때문에 이미 캐싱되어 있는 값이 존재한다면 생성자를 통하지 않고 그 값을 바로 반환한다.</p>

<p>➕ 
또 추가로<br />
double실수값을 생성자로 생성해도 연산결과가 정확하지 않을 수 있으니, <br />
<code class="highlighter-rouge">valueOf()</code>를 사용해서 생성하는 것이 좋다고도 한다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/8ec4f2b7-16ac-40a1-bacd-c8e21bb76b82/image.png" style="zoom:50%;" /></p>

<p>오호라 👀<br />
요즘 정적 팩터리 메서드와 캐싱개념들에 대해 살펴봤는데,<br />
BigDecimal을 뜯어보니 굉장히 흥미롭다 👻</p>

	  ]]></description>
	</item>

	<item>
	  <title>📖 Stream 부수기</title>
	  <link>//Stream-%E1%84%87%E1%85%AE%E1%84%89%E1%85%AE%E1%84%80%E1%85%B5</link>
	  <author></author>
	  <pubDate>2021-02-25T19:18:00+09:00</pubDate>
	  <guid>//Stream-%E1%84%87%E1%85%AE%E1%84%89%E1%85%AE%E1%84%80%E1%85%B5</guid>
	  <description><![CDATA[
	     <p>코드를 짜다보면 가독성과 간결함을 위해 stream을 자주 쓰게 된다.<br />
프리코스 때 Stream에 대해 정리했었으나,<br />
내가 쓴 글을 리팩토링(ㅎ) 해보면서 다시 개념을 익혀야 겠다.</p>

<h2 id="스트림">스트림?</h2>
<p>배열 또는 컬렉션 인스턴스에 저장된 데이터를 꺼내서 파이프에 흘려보낸다.</p>
<ul>
  <li>중간 연산 : 마지막이 아닌 위치에서 진행이 되어야 하는 연산</li>
  <li>최종 연산 : 마지막에 진행이 되어야 하는 연산
스트림은 중간 연산과 최종 연산을 진행하기 좋은 구조로 배치된 복사본이라 할 수 있다.</li>
</ul>

<h3 id="스트림의-특성">스트림의 특성</h3>
<h4 id="가독성과-간결함">가독성과 간결함</h4>
<p>컬렉션이나 배열에 데이터를 담고 원하는 결과를 얻기 위해 
for문과 Iterator를 이용해 작성한 코드는 가독성이 떨어지고 재사용성도 떨어진다.</p>

<h4 id="데이터-소스-추상화">데이터 소스 추상화</h4>
<p>어떤 메소드로 처리하기 위해 데이터 소스마다 다른 방식으로 다뤄야 하는 문제를
스트림을 통해 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 되었다.<br />
이는 코드의 재사용성을 가져온다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">listStream</span> <span class="o">=</span> <span class="n">strList</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">arrayStream</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">strArr</span><span class="o">);</span>

<span class="n">listStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="n">arrayStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<p>두 스트림의 데이터 소스는 서로 다르지만, 정렬하고 출력하는 방법은 같다.</p>

<h4 id="데이터-소스를-변경하지-않는다">데이터 소스를 변경하지 않는다.</h4>
<p>스트림은 데이터 소스로 부터 데이터를 읽기만 할 뿐, 
데이터 소스를 변경하지 않는다.<br />
필요시에만 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sortedList</span> <span class="o">=</span> <span class="n">listStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">Collections</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<h4 id="스트림은-일회용이다">스트림은 일회용이다.</h4>
<p>Iterator처럼 일회용이다. 한번 사용하면 닫혀서 다시 사용할 수 없다.<br />
필요하다면 스트림을 다시 생성해야한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">listStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">print</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">numOfElement</span> <span class="o">=</span> <span class="n">listStream</span><span class="o">.</span><span class="na">count</span><span class="o">();</span> <span class="c1">//에러- 스트림이 이미 닫혔다.</span>
</code></pre></div></div>

<h4 id="내부-반복">내부 반복</h4>
<p>스트림이 간결한 이유중 하나가 반복문을 메서드 내부에 숨기는 ‘내부 반복’ 덕분이다.<br />
<code class="highlighter-rouge">forEach()</code>는 스트림에 정의된 메서드 중의 하나로 매개변수에 대입된 
람다식을 데이터 소스의 모든 요소에 적용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<h2 id="스트림-생성하기">스트림 생성하기</h2>
<h3 id="스트림의-생성">스트림의 생성</h3>
<h4 id="메소드">메소드</h4>
<p>스트림 생성과 관련해 <code class="highlighter-rouge">Stream&lt;T&gt;</code> 인터페이스에 정의되어 있는 static 메소드는 두 개가 있다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static &lt;T&gt; Stream&lt;T&gt;(T t)
static &lt;T&gt; Stream&lt;T&gt; of(T...values)
</code></pre></div></div>
<p>이 메소드에 스트림 생성에 필요한 데이터를 인자로 직접 전달할 수 있다.</p>

<h4 id="example">Example</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class StreamOfStream {
    public static void main(String[] args) {
        // ex 1
        Stream.of(11, 22, 33, 44)
            .forEach(n -&gt; System.out.print(n + "\t"));
        System.out.println();

        // ex 2
        Stream.of("So Simple")
            .forEach(s -&gt; System.out.print(s + "\t"));
        System.out.println();

        // ex 3 세 개의 문자열로 이뤄진 스트림이 생성되는 것이 아닌
        // sl이 참조하는 하나의 인스턴스만 존재한다.
        List&lt;String&gt; sl = Arrays.asList("Toy", "Robot", "Box");
        Stream.of(sl)
            .forEach(w -&gt; System.out.print(w + "\t"));
        System.out.println();       
    }
}
</code></pre></div></div>
<p>of 메소드에 컬렉션 인스턴스를 전달하면 해당 인스턴스 하나로 이뤄진 스트림이 생성된다. <br />
하지만 배열을 전달하면 하나의 배열로 이뤄진 스트림이 생성되지 않고,<br />
배열에 저장된 요소로 이뤄진 스트림이 생성된다.</p>

<h3 id="배열">배열</h3>
<p>배열에 저장된 데이터를 대상으로 스트림을 생성할 때 호출되는 대표 메소드는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">satic</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">stream</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span> <span class="c1">// Arrays 클래스에 정의되어 있다</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">StringStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">"YOON"</span><span class="o">,</span> <span class="s">"LEE"</span><span class="o">,</span> <span class="s">"PARK"</span><span class="o">};</span>
        
        <span class="c1">// 스트림 생성</span>
        <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stm</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
        
        <span class="c1">// 최종 연산 진행</span>
        <span class="n">stm</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>forEach는 최종 연산이며 메소드의 매개변수형은 <code class="highlighter-rouge">Consumer&lt;T&gt;</code> 이므로 람다식을 인자로 전달해야하며, <br />
내부적으로 스트림 데이터를 하나씩 인자로 전달하면서 accept 메소드를 호출한다.</p>

<h3 id="컬렉션-인스턴스">컬렉션 인스턴스</h3>
<p>컬렉션 인스턴스를 대상으로 스트림을 생성할 때 호출되는 메소드는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">default</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">stream</span><span class="o">()</span>
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ListStream {
    public static void main(String[] args) {
        
        List&lt;String&gt; list = Arrays.asList("Toy", "Robot", "Box");
        
        list.stream()
          .forEach(s -&gt; System.out.print(s + "\t"));

        System.out.println();
    }
}
</code></pre></div></div>

<h3 id="특정-범위의-정수">특정 범위의 정수</h3>
<p><code class="highlighter-rouge">IntStream</code>과 <code class="highlighter-rouge">LongStream</code>은 지정된 범위의 연속된 정수를 스트림으로 생성해서
반환하는 <code class="highlighter-rouge">range()</code>와 <code class="highlighter-rouge">rangeClosed()</code>를 가지고 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IntStream intStream = IntStream.range(1, 5); // 1,2,3,4,
IntStream intStream = IntStream = Intstream.rangeClosed(1, 5); // 1,2,3,4,5 
</code></pre></div></div>
<p><code class="highlighter-rouge">range</code>는 end가 범위에 포함되지 않고 <code class="highlighter-rouge">rangeClosed</code>는 포함된다.</p>

<h3 id="람다식---iterate-generate">람다식 - iterate(), generate()</h3>
<p>Stream 클래스의 <code class="highlighter-rouge">iterate()</code>와 <code class="highlighter-rouge">generate()</code>는 람다식을 매개변수로 받아서,<br />
이 람다식에 의해 계산되는 값들을 요소로 하는 무한 스트림을 생성한다.</p>

<p>이때 생성되는 스트림은 무한하기 때문에 <code class="highlighter-rouge">limit()</code>를 호출하여 특정 사이즈로 제한해주는 것이 좋다.</p>
<h4 id="iterate">iterate()</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">evenStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
<span class="c1">// 0, 2, 4 ...</span>
</code></pre></div></div>
<p>씨드로 지정된 값부터 시작해서,  람다식에 의해 계산된 결과를 다시 시드 값으로 해서 
계산을 반복한다.</p>

<h4 id="generate">generate()</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">randomStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="nl">Math:</span><span class="o">:</span><span class="n">random</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">iterate()</code>처럼 람다식에 의해 계산되는 값을 요소로 하는 무한 스트림을 생성해서
반환하지만, <code class="highlighter-rouge">iterate()</code>와 달리 이전 결과를 이용해서 다음 요소를 계산하지 않는다.</p>

<h3 id="빈-스트림">빈 스트림</h3>
<p>요소가 하나도 없는 비어있는 스트림을 생성할 수도 있다.<br />
스트림에 연산을 수핸한 결과가 하나도 없을 때, null보다 빈 스트림을 반환하는게 낫다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span> <span class="n">emptyStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span> <span class="c1">// empty() 는 빈 스트림을 생성해서 반환한다.</span>
<span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">emptyStream</span><span class="o">.</span><span class="na">count</span><span class="o">();</span> <span class="c1">// count값은 0</span>
</code></pre></div></div>
<p>여기서 <code class="highlighter-rouge">count()</code>는 요소의 갯수를 반환한다.</p>

<h2 id="스트림의-연산">스트림의 연산</h2>
<h4 id="지연-처리">지연 처리</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyFirstStream2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ar</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>

        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">ar</span><span class="o">)</span> <span class="c1">// 스트림을 생성</span>
                        <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// filter 통과</span>
                        <span class="o">.</span><span class="na">sum</span><span class="o">();</span> <span class="c1">// sum을 통과시켜 그 결과를 반환</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위 예제에서 쓰인 두 메소드는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">IntStream</span> <span class="nf">stream</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span>
<span class="n">IntStream</span> <span class="nf">filter</span><span class="o">(</span><span class="n">IntPredicate</span> <span class="n">predicate</span><span class="o">)</span>
</code></pre></div></div>
<p>filter와 sum 메소드는 IntStream의 인스턴스 메소드이다.</p>

<p>스트림의 연산은 “지연 처리” 방식으로 동작한다.<br />
최종 연산이 수행 되기 전까지는 중간 연산이 수행되지 않는다.</p>

<p>위 예제에서는 sum이 호출될 때까지 filter의 호출 결과는 스트림에 반영되지 않는다.<br />
최종 연산인 sum이 호출되어야만 filter의 호출 결과가 스트림에 반영된다.<br />
이처럼 최종 연산이 생략되면 중간 연산이 의미가 없다.</p>

<h3 id="스트림의-중간-연산">스트림의 중간 연산</h3>
<p>연산 결과가 스트림인 연산으로, 스트림에 연속해서 중간 연산할 수 있다.</p>
<h3 id="filter-필터링">filter (필터링)</h3>
<p>스트림을 구성하는 데이터 중 일부를 조건에 따라 걸러내는 행위를 의미한다.</p>
<h4 id="메소드-1">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span> <span class="c1">// Stream&lt;T&gt;에 존재</span>
</code></pre></div></div>
<p>매개변수 형이 Predicate이므로 test 메소드의 구현에 해당하는 람다식을 
인자로 전달해야 한다.<br />
내부적으로 스트림 데이터를 하나씩 인자로 전달하면서 test를 호출하고,<br />
그 결과가 true이면 해당 데이터를 스트림에 남긴다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FilterStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ar</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">ar</span><span class="o">)</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// 홀수만 통과</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"Toy"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">,</span> <span class="s">"Box"</span><span class="o">);</span>
        <span class="n">sl</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">// 길이가 3이면 통과</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>       
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h3 id="map-맵핑">map (맵핑)</h3>
<p>스트림 요소에서 저장된 값 중에서 원하는 필드만 뽑아내거나 특정 형태로 변환해야 할 떄가 있다.<br />
맵핑을 진행하면 스트림의 데이터 형이 달라지는 특징이 있다.</p>

<h4 id="메소드-2">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span>
</code></pre></div></div>
<p>매개변수 형이 Function이므로 apply 메소드의 구현에 해당하는 람다식을 
인자로 전달해야 한다.<br />
내부적으로 스트림 데이터를 하나씩 인자로 전달하면서 apply를 호출하고,<br />
그 결과로 반환되는 값을 모아 새 스트림을 생성한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MapToInt</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"Box"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">,</span> <span class="s">"Simple"</span><span class="o">);</span>
        
        <span class="n">ls</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
          <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
          <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h4 id="map-vs-flatmap">map vs flatMap</h4>
<h5 id="map의-메소드">map의 메소드</h5>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span>
</code></pre></div></div>
<p>map에 전달할 람다식에서는 스트림을 구성할 데이터만 반환하면 된다.</p>
<h5 id="flatmap의-메소드">flatMap의 메소드</h5>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;&gt;</span> <span class="n">mapper</span><span class="o">)</span>
</code></pre></div></div>
<p>flatMap에 전달할 람다식에서는 스트림을 생성하고 이를 반환해야 한다.</p>

<h3 id="filter--map">filter &amp; map</h3>
<h4 id="example-1">example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
	<span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="o">)</span>
	<span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">getPrice</span><span class="o">())</span>
	<span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="sorted">sorted</h3>
<h4 id="메소드-3">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">sorted</span><span class="o">()</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">compatator</span><span class="o">)</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">sorted()</code>는 지정된 Comparator로 스트림을 정렬하는데, Comparator대신 
int 값을 반환하는 람다식을 사용할 수도 있다.<br />
Comparator를 지정하지 않으면 스트림 요소의 기본 정렬 기준으로 정렬한다.<br />
하지만 스트림 요소가 Comparable을 구현한 클래스가 아니면 예외가 발생한다.<br />
정렬에 사용되는 메서드의 개수가 많지만 기본적인 메서드는 <code class="highlighter-rouge">comparing()</code>이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">comparing</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">keyExtractor</span><span class="o">)</span>
<span class="n">comparing</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">keyExtractor</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">keyComparator</span><span class="o">)</span>
</code></pre></div></div>
<p>스트림 요소가 Comparable을 구현한 경우, 매개변수 하나짜리를 사용하면 되고,<br />
그렇지 않으면 추가적인 매개변수로 정렬기준(Comparator)을 따로 지정해줘야 한다.</p>

<p>정렬 조건을 추가할 때는 <code class="highlighter-rouge">thenComparing()</code>을 사용한다.</p>

<h4 id="example-2">Example</h4>
<p>학생 스트림을 반별, 성적순, 이름 순으로 정렬하는 예시이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">student</span><span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="nl">Student:</span><span class="o">:</span><span class="n">getBan</span><span class="o">)</span>
	<span class="o">.</span><span class="na">thenComparing</span><span class="o">(</span><span class="nl">Student:</span><span class="o">:</span><span class="n">getTOtalScore</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenComparing</span><span class="o">(</span><span class="nl">Student:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span>
        <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="peek">peek</h3>
<p>스트림을 이루는 모든 데이터 각각을 대상으로 특정 연산을 진행하는 행위를 “루핑”이라 한다.<br />
forEach는 루핑으로 최종연산이지만, 중간연산에도 루핑 메소드가 있다.</p>

<h4 id="메소드-4">메소드</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Stream&lt;T&gt;의 메소드
Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)
</code></pre></div></div>
<h4 id="example-3">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LazyOpStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 최종 연산이 생략된 스트림의 파이프 라인</span>
        <span class="c1">// 아무 것도 출력되지 않는다.</span>
        <span class="n">IntStream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
            <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">d</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

  
        <span class="c1">// 최종 연산이 존재하는 파이프 라인</span>
        <span class="n">IntStream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
            <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">d</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">sum</span><span class="o">();</span>            
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="스트림의-최종-연산">스트림의 최종 연산</h2>
<p>최종 연산은 스트림의 요소를 소모해서 결과를 만들어낸다.<br />
그래서 최종 연산 후에는 스트임니 닫혀 더 이상 사용할 수 없다.<br />
최종 연산의 결과는 스트림의 요소의 합과 같은 단일 값이거나, <br />
스트림의 요소가 담긴 배열 또는 컬렉션일 수 있다.</p>

<h3 id="foreach">forEach</h3>
<p>지정된 작업을 스트림의 모든 요소에 대해 수행한다.
주의할 점은 <code class="highlighter-rouge">forEach()</code>는 스트림의 요소를 소모하면서 작업을 수행하므로 같은 스트림에 <code class="highlighter-rouge">forEach()</code>를 두 번 호출할 수 없다.</p>

<h4 id="메소드-5">메소드</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Stream&lt;T&gt;의 메소드
void forEach(Consumer&lt;? super T&gt; action)
</code></pre></div></div>
<p><code class="highlighter-rouge">peek()</code>과 달리 스트림의 요소를 소모하는 최종 연산이기 때문에 반환형이 void이다.</p>

<h3 id="reduce">reduce</h3>
<p>스트림 요소를 줄여나가면서 연산을 수행하고 최종 결과를 반환한다.<br />
처음 두 요소를 가지고 연산한 결과를 가지고 그 다음 요소와 연산한다.<br />
이 과정에서 스트림의 요소를 하나씩 소모하게 되며, 스트림의 모든 요소를 소모하면 그 결과를 반환한다.</p>

<p>스트림의 요소가 하나도 없는 경우, 초기값이 반환되므로 반환타입이 <code class="highlighter-rouge">Optional&lt;T&gt;</code>가 아니라 <code class="highlighter-rouge">T</code>이다.</p>
<h4 id="메소드-6">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">T</span> <span class="n">identity</span><span class="o">,</span> <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">)</span> <span class="c1">// Stream&lt;T&gt;에 존재</span>
</code></pre></div></div>
<p>reduce는 전달하는 람다식에 의해 연산의 내용이 결정된다.</p>

<p><strong><code class="highlighter-rouge">BinaryOperator&lt;T&gt;</code>의 추상 메소드</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T apply(T t1, T t2)
</code></pre></div></div>
<p>reduce 호출 시 메소드 apply에 대한 람다식을 인자로 전달해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ReduceStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"Box"</span><span class="o">,</span> <span class="s">"Simple"</span><span class="o">,</span> <span class="s">"Complex"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">);</span>
        
        <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">lc</span> <span class="o">=</span> 
            <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> 
               <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
                   <span class="k">return</span> <span class="n">s1</span><span class="o">;</span>
               <span class="k">else</span> 
                   <span class="k">return</span> <span class="n">s2</span><span class="o">;</span>                   
            <span class="o">};</span>
        
        <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                      <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">lc</span><span class="o">);</span> <span class="c1">// 스트림이 빈 경우 빈 문자열 반환</span>
      
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span> <span class="c1">// Complex</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>reduce 메소드는 스트림이 빈 경우에 첫 번째 인자로 전달된 값을 반환한다.</p>
<h3 id="allmatch-anymatch-nonematch">allMatch, anyMatch, noneMatch</h3>
<p>스트림의 요소에 대해 지정된 조건에 모든 요소가 일치하는 지, 일부가 일치하는지,<br />
아니면 어떤 요소도 일치하지 않는지 확인하는데 사용할 수 있다.</p>

<h4 id="메소드-7">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">allMatch</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span>

<span class="kt">boolean</span> <span class="nf">anyMatch</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span>

<span class="kt">boolean</span> <span class="nf">noneMatch</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span>
</code></pre></div></div>
<ul>
  <li>allMatch : 스트림의 데이터가 조건을 모두 만족하는가?</li>
  <li>anyMatch : 스트림의 데이터가 조건을 하나라도 만족하는가?</li>
  <li>noneMatch : 스트림의 데이터가 조건을 하나도 만족하지 않는가?
    <h3 id="findany-findfirst">findAny, findFirst</h3>
    <p><code class="highlighter-rouge">filter()</code>와 함께 쓰여서 조건에 맞는 스트림의 요소가 있는지 확인하는데 사용된다.<br />
둘의 반환 타입은 <code class="highlighter-rouge">Optionsnal&lt;T&gt;</code>이며, 스트림의 요소가 없을 때 빈 Optional 객체를 반환한다.</p>
  </li>
</ul>

<h4 id="example-4">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">student</span><span class="o">.</span><span class="na">filer</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getTotalScore</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">).</span><span class="na">findFirst</span><span class="o">();</span>
</code></pre></div></div>
<h3 id="collect">collect</h3>
<p>파이프라인을 통해서 가공되고 걸러진 데이터를 최종 연산 과정에서 별도로 저장이 필요할 때 사용한다.</p>
<h4 id="메소드-8">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Stream&lt;T&gt;의 메소드</span>
<span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span> 
				<span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">,</span>
                <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">combiner</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="example-5">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CollectStringStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"Box"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">,</span> <span class="s">"Toy"</span><span class="o">};</span>
        <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">words</span><span class="o">);</span>
        
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">)</span>
                          <span class="o">.</span><span class="na">collect</span><span class="o">(</span>
                              <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(),</span>
                              <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">),</span>
                              <span class="o">(</span><span class="n">lst1</span><span class="o">,</span> <span class="n">lst2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">lst1</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">lst2</span><span class="o">));</span>
    
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ls</span><span class="o">);</span> <span class="c1">// [Box, Toy]</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>첫 번째 매개변수인 람다식을 기반으로 데이터를 저장할 저장소를 생성한다.<br />
두 번째 매개변수인 람다식에서의 첫 번째 매개변수(c)는 
collect의 첫번째 인자를 통해서 생성된 컬렉션 인스턴스이며,<br />
두 번째 매개변수(s)는 스트림을 이루는 데이터 이다.<br />
세 번째 매개변수인 람다식은 병렬 스트림이 아닌 순차 스트림일 경우 사용되지 않는다.</p>

<h2 id="collect-1">collect()</h2>
<p>스트림의 요소를 수집하는 최종 연산으로 <code class="highlighter-rouge">reduce()</code>와 유사하다.<br />
collect()가 스트림의 요소를 수집하려면, 어떻게 수집할 것인가에 대한 방법이 정의되어<br />
있어야 하는데, 이 방법을 정의한 것이 컬렉터이다.</p>

<h3 id="컬렉터">컬렉터</h3>
<p>컬렉터는 <code class="highlighter-rouge">Collector</code> 인터페이스를 구현한 것으로, 직접 구현할 수도 있고 미리 작성된 것을 사용할 수도 있다.<br />
다양한 static 메서드를 가지고 있다.</p>

<ul>
  <li>collect() : 스트림의 최종연산, 매개변수로 컬렉터를 필요로 한다.</li>
  <li>Collector : 인터페이스. 컬렉터는 이 인터페이스를 구현해야한다.</li>
  <li>Collectors : 클래스. static 메서드로 미리 작성된 컬렉터를 제공한다.</li>
</ul>

<p>Collector는 인터페이스이기 때문에 직접 구현해서 컬렉터를 만들어야 한다.</p>

<h3 id="collect-2">collect()</h3>
<p><code class="highlighter-rouge">collect()</code>는 매개변수 타입이 Collector인데, 매개변수가 Collector를 구현한 클래스의 객체여야 한다.<br />
<code class="highlighter-rouge">collect()</code>는 이 객체에 구현된 방법대로 스트림의 요소를 수집한다.<br />
<em>sort()할 때 Comparator가 필요한 것처럼 colllect()할 때는 Collector가 필요하다.</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Object</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Collector</span> <span class="n">collector</span><span class="o">)</span> 
</code></pre></div></div>

<h3 id="스트림을-컬렉션과-배열로-반환">스트림을 컬렉션과 배열로 반환</h3>
<ul>
  <li><code class="highlighter-rouge">toList()</code>, <code class="highlighter-rouge">toSet()</code>, <code class="highlighter-rouge">toMap()</code>, <code class="highlighter-rouge">toCollection()</code>, <code class="highlighter-rouge">toArray()</code></li>
</ul>

<p>스트림의 모든 요소를 컬렉션에 수집하려면, Collectors 클래스의 <code class="highlighter-rouge">toList()</code>와 같은 메서드를 사용하면 된다.<br />
특정 컬렉션을 지정하려면 <code class="highlighter-rouge">toCollection()</code>에 해당하는 컬렉션의 
생성자 참조를 매개변수로 넣어주면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toCollection</span><span class="o">(</span><span class="n">toCollection</span><span class="o">(</span><span class="nl">ArrayList:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
</code></pre></div></div>

<p>Map은 키와 값의 쌍으로 저장해야하니 객체의 어떤 필드를 키로 사용할지와 값으로 사용할지를 지정해줘야 한다.<br />
아래 예제는 스트림에서 사람의 주민번호를 키로 하고, 값으로 Person 객체를 그대로 저장한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Person</span><span class="o">&gt;</span> <span class="n">map</span>  <span class="o">=</span> <span class="n">personStream</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toMap</span><span class="o">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">.</span><span class="na">getRegId</span><span class="o">(),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">));</span>
</code></pre></div></div>

<h2 id="참고-자료">참고 자료</h2>
<ul>
  <li>자바의 정석</li>
  <li>윤성우의 열혈 자바 프로그래밍</li>
</ul>

<hr />
<p>자주 사용하던 스트림을 정리하니까 각 메소드의 사용 목적이 명확해졌다 🙃<br />
또 Collector와 Collectors는 뭐가 다른지 궁금했는데 정리되었다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📖 Exception에 대하여</title>
	  <link>//Exception%E1%84%8B%E1%85%A6-%E1%84%83%E1%85%A2%E1%84%92%E1%85%A1%E1%84%8B%E1%85%A7</link>
	  <author></author>
	  <pubDate>2021-02-24T19:18:00+09:00</pubDate>
	  <guid>//Exception%E1%84%8B%E1%85%A6-%E1%84%83%E1%85%A2%E1%84%92%E1%85%A1%E1%84%8B%E1%85%A7</guid>
	  <description><![CDATA[
	     <p>오늘 수업 시간에 자바의 Exception에 대해 배웠다.<br />
수업을 듣고 들은 내용을 자바의 정석의 예외 처리를 함께 보면서 정리 ✍️</p>

<h2 id="프로그램-오류-종류">프로그램 오류 종류</h2>
<ul>
  <li>컴파일 에러 - 컴파일 시에 발생하는 에러</li>
  <li>런타임 에러 - 실행 시에 발생하는 에러</li>
  <li>논리적 에러 - 실행은 되지만, 의도와 다르게 동작하는 것</li>
</ul>

<p>프로그램에서 실행 도중 발생할 수 있는 모든 경우의 수를 고려해 이에 대한 적절한 대비가 필요하다!</p>

<h3 id="error와-exception의-차이">Error와 Exception의 차이?</h3>
<h4 id="error">Error</h4>
<p>애플리케이션이 정상적으로 동작하는데 심각한 문제가 있는 경우 사용한다.<br />
ex) 메모리 부족이나 스택오버플로우 등</p>

<p>개발자가 Error를 사용하는 일은 거의 없다고 한다.</p>

<h4 id="exception">Exception</h4>
<p>비즈니스 로직 상에서 에러가 발생하는 경우 사용한다. <br />
발생하더라도 수습이 가능하여 프로그래머가 이에 대한 적절한 처리를 할 수 있다.</p>

<h2 id="예외-클래스-계층-구조">예외 클래스 계층 구조</h2>
<p><img src="https://images.velog.io/images/new_wisdom/post/b3233d4f-d9e9-4c54-991b-5a0d24430cfb/pngwing.com.png" style="zoom:67%;" /></p>

<p>모두 Throwable을 상속하고 있으며, 여기서부터 Error와 Exception이 발생한다.<br />
여기서 모든 예외의 조상은 Exception 클래스이다.</p>

<p>또 예외 클래스들은 두 개의 그룹으로 나뉘어 질 수 있다.</p>
<ul>
  <li>RuntimeException 클래스와 그 자손 클래스들</li>
  <li>Exception 클래스와 그 자손 클래스들</li>
</ul>

<p>이 글에서는 RuntimeException 클래스와 그 자손 클래스들을 <strong>Checked Exception</strong>이라 하고,<br />
Exception 클래스와 그 자손 클래스들을 <strong>Unchecked Exception</strong>이라고 하겠다.</p>

<h3 id="checked-exception">Checked Exception</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">lotto.view.ErrorView</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomException</span> <span class="kd">extends</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">CustomException</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ErrorView</span><span class="o">.</span><span class="na">printErrorMessage</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<p>…</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">CustomException</span> <span class="o">{</span>
        <span class="n">LottoNumber</span> <span class="n">lottoNumber</span> <span class="o">=</span> <span class="n">LottoNumber</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Exception을 상속받아 사용하는 경우 컴파일 시점에 Exception을 확인할 수 있다. <br />
만약 컴파일 시점에 Exception에 대한 처리(try/catch)를 하지 않을 경우 컴파일 에러가 발생한다.<br />
Exception이 발생하는 메소드에서 throws 예약어를 활용해<br />
Exception을 호출 메소드에 전달해야 한다.</p>

<p>상위 메서드로 throw를 던지는 행위는 상위 메서드들의 책임이 그만큼 증가하기 때문에,<br />
그리 좋은 방법 같지는 않다.</p>

<h3 id="unchecked-exception">Unchecked Exception</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IllegalLottoNumberException</span> <span class="kd">extends</span> <span class="n">IllegalArgumentException</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IllegalLottoNumberException</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ErrorView</span><span class="o">.</span><span class="na">printIllegalLottoNumberMessage</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>…</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">LottoNumber</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MIN_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">45</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Pattern</span> <span class="n">NUMBER_PATTERN</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"^[0-9]*$"</span><span class="o">);</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LottoNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">validateLottoNumber</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateLottoNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isBlank</span><span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">||</span> <span class="n">isInvalidNumberFormat</span><span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">||</span> <span class="n">isInvalidLottoNumberRange</span><span class="o">(</span><span class="n">number</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalLottoNumberException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>Runtime Time Exception 이라고 한다.<br />
컴파일 시점에 Exception이 발생할 것인지의 여부를 판단할 수 없다.<br />
Exception이 발생하는 메소드에서 throws 예약어를 활용해 Exception을 처리할 필요가 없지만, 처리해도 무방하다.</p>

<h3 id="checked-exception-vs-unchecked-exception">Checked Exception VS Unchecked Exception</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>Checked Exception</th>
      <th>Unchecked Exception</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>확인 시점</td>
      <td>컴파일타임</td>
      <td>런타임</td>
    </tr>
    <tr>
      <td>처리</td>
      <td>반드시 예외 처리해야 한다.</td>
      <td>throws를 통해 그냥 던져도, 처리해도 상관 없다.</td>
    </tr>
    <tr>
      <td>대표 예외</td>
      <td>IOException, SQLException</td>
      <td>IllegalArgumentException, NullPointEception</td>
    </tr>
  </tbody>
</table>

<p>너무 치명적이면 Checked 쓰고,<br />
굳이 경고가 필요없고, 서비스 코드를 만드는 입장이라면 최상단에서 <br />
에러를 핸들링 할 수 있으니 Unchecked를 쓰는게 좋다.</p>

<p>참고로 코틀린에서는 Checked Exception은 코드만 늘어날 뿐이라 생각(?)해서 <br />
여러가지 이유로… Checked Exception이 없다고 한다.<br />
또 프로그래머 입장에서 메인과 같은 중앙에서 핸들링하는 녀석을 만들어 관리하는데,<br />
굳이 우리가 Checked Exception을 제공할 필요가 있냐는 말이다.</p>

<p>수업시간에 다양한 말들로 둘을 구분지어 보았는데,<br />
**Checked Exception는 **</p>

<ul>
  <li>내부 구현이 어떻게 되는지 알려주고 싶어!</li>
  <li>내가 집 수리할건데 손 다칠수도 있으니까 구급차 미리 불러!</li>
  <li>너 진짜 조심해야해!</li>
</ul>

<p>**Unchecked Exception는 **</p>
<ul>
  <li>내부에서 예외에 대한 방어가 있는데 클라이언트한테 공개는 안할거야, 대신 값을 잘 넣어주면 좋겠어.</li>
  <li>내가 집 수리할건데 아냐 다치지 않고 잘 할 수 있어!</li>
  <li>클라이언트가 입력할 값을 잘 알고 있겠지 ~</li>
</ul>

<p>이런 느낌으로 이야기가 나왔다.<br />
Checked인지 Unchecked인지는 <strong>클라이언트에게 얼마나 책임을 떠넘기느냐</strong>에 대한 관점으로 봐도 좋을 것 같다.</p>

<h2 id="예외-처리---try-catch문">예외 처리 - try-catch문</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="c1">// 예외 발생 가능성 있는 문장들</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception1</span> <span class="n">e1</span><span class="o">){</span>
    <span class="c1">// Exception1이 발생했을 경우, 처리하는 문장</span>
<span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception2</span> <span class="n">e2</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Exception2가 발생했을 경우, 처리하는 문장</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이렇게 하나의 try 블럭 다음에는 여러 종류의 예외를 처리할 수 있도록<br />
하나 이상의 catch 블럭이 올 수 있다.</p>

<h4 id="흐름">흐름</h4>
<p>try 블럭에서 예외가 발생하면, 예외가 발생한 위치 이후에 있는 <br />
try 블럭의 문장들은 수행되지 않는다.<br />
때문에 try 블럭에 포함시킬 코드의 범위를 잘 선택해야 한다.</p>

<p>예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 만들어진다.<br />
try블럭에서 예외가 발생되고, 첫 catch 문부터 차례대로 catch 블럭의<br />
괄호 내 선언된 참조변수의 종류와 생성된 예외 클래스의 인스턴스에 <code class="highlighter-rouge">instanceof</code>연산자를 이용해 검사한다.<br />
검사한 결과가 true인 블럭을 만날 때 까지 계속 검사한다.</p>

<h4 id="try에서-발생한-예외의-종류와-일치하는-단-하나의-catch-블럭만-수행된다">try에서 발생한 예외의 종류와 일치하는 단 하나의 catch 블럭만 수행된다.</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">number</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">LottoNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">LottoNumber</span> <span class="nf">from</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">CustomException</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">CustomException</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>다음과 같이 LottoNumber 객체를 <code class="highlighter-rouge">from()</code>으로 생성했을 때 <br />
<code class="highlighter-rouge">Exception</code>을 상속받고 있는 <code class="highlighter-rouge">CustomException</code>을 발생시킨다고 해보자.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/daa06d54-027d-44b4-aa16-4c4d985f3e72/image.png" style="zoom:50%;" /></p>

<p>인텔리제이에서도 알 수 있듯이 <code class="highlighter-rouge">CustomException</code>의 상위 클래스인 <br />
<code class="highlighter-rouge">Exception</code>을 미리 catch해주었기 때문에 하위 catch에서 <br />
<code class="highlighter-rouge">CustomException</code>를 잡는 것은 소용이 없다.</p>

<p>모든 예외 클래스는 Exception 클래스의 자손이므로, <br />
Exception 클래스 타입의 참조변수를 선언하면 해당 블럭에서 어떤 예외던지 처리된다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/aae681e5-9d55-4e86-99fe-da67d1cf9492/image.png" style="zoom:50%;" /></p>

<p>또 위와 같은 코드를 실행시켜보면 아래와 같은 출력 결과가 나온다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/20c67935-d673-4440-beb6-a943faf7d55d/image.png" style="zoom:50%;" /></p>

<p><strong>멀티 catch 블럭</strong><br />
JDK1.7부터 catch 블럭을 <code class="highlighter-rouge">|</code>을 이용해 하나의 catch 쁠럭으로 합칠 수 있게 되었다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/0ae3a6dd-c32e-47ff-8d0c-9788613a410e/image.png" style="zoom:50%;" /></p>

<p>하지만 이렇게 부모 자식 관계가 있다면 컴파일 에러가 발생한다.</p>

<h4 id="중첩된-try-catch">중첩된 try-catch</h4>
<p><img src="https://images.velog.io/images/new_wisdom/post/720fe0b3-6297-4a8e-85cb-4ad644451cd7/image.png" style="zoom:50%;" /></p>

<p>하나의 메서드 안에 여러개의 try-catch를 사용할 수 있으며,<br />
중첩으로도 사용이 가능하다.<br />
하지만 catch블럭 괄호 내 참조 변수는 catch 블럭 내에서 유효한데,<br />
위의 예제에서는 <code class="highlighter-rouge">e</code>의 참조변수의 영역이 서로 겹치기 때문에 컴파일 에러가 난다.</p>

<h2 id="custom-exception">Custom Exception</h2>
<p>기존에 정의된 예외 클래스 외에 필요에 따라 사용자 정의 클래스를 정의하여 사용할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyException</span> <span class="kd">extends</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">MyException</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span> 
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>생성시 string을 인자로 받아서 메시지로 저장할 수 있다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📖 Enum 열거형</title>
	  <link>//Enum-%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%80%E1%85%A5%E1%84%92%E1%85%A7%E1%86%BC</link>
	  <author></author>
	  <pubDate>2021-02-21T19:18:00+09:00</pubDate>
	  <guid>//Enum-%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%80%E1%85%A5%E1%84%92%E1%85%A7%E1%86%BC</guid>
	  <description><![CDATA[
	     <h2 id="열거형이란">열거형이란?</h2>
<p>JDK 1.5 부터 새로 추가된 개념이다.</p>

<p>기존의 언어들과 자바의 Enum이 다른 점은</p>
<ul>
  <li>열거형이 갖는 값 뿐만 아니라 타입까지 관리하기 때문에 보다 
논리적인 오류를 줄일 수 있다.</li>
  <li>‘타입에 안전한 열거형’을 제공하여 실제 값이 같아도 타입이 다르면 조건식 결과가 false이다. 값 뿐만 아니라 타입까지 체크한다.</li>
  <li>상수 값이 바뀌어도 기존 소스를 다시 컴파일하지 않아도 된다.</li>
</ul>

<h3 id="열거형의-정의와-사용">열거형의 정의와 사용</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="err">열거형이름</span> <span class="o">{</span><span class="err">상수명</span><span class="mi">1</span><span class="o">,</span> <span class="err">상수명</span><span class="mi">2</span><span class="o">,</span> <span class="o">...}</span>
</code></pre></div></div>
<p>열거형에 정의된 상수를 사요아는 방법은 <code class="highlighter-rouge">열거형이름.상수명</code>이다.<br />
클래스의 static 변수를 참조하는 것과 동일하다.</p>

<h4 id="열거형-상수간-비교">열거형 상수간 비교</h4>
<p><code class="highlighter-rouge">==</code> 연산자를 사용하여 비교할 수 있다.<br />
<code class="highlighter-rouge">equals()</code>가 아닌 <code class="highlighter-rouge">==</code>으로 비교가 가능하다는 것은 그만큼 성능이 좋다는 것이다.<br />
<code class="highlighter-rouge">&lt;, &gt;</code>로는 비교할 수 없지만 <code class="highlighter-rouge">compareTo()</code>는 사용이 가능하다.</p>

<p>또 <code class="highlighter-rouge">switch</code> 문의 조건식에도 사용할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span><span class="o">(</span><span class="n">d1</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nl">EAST:</span> <span class="c1">// Direction.EAST라고 쓰면 안된다.</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The direction is EAST."</span><span class="o">);</span> 
        <span class="k">break</span><span class="o">;</span>
    <span class="k">case</span> <span class="nl">SOUTH:</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The direction is SOUTH."</span><span class="o">);</span> 
        <span class="k">break</span><span class="o">;</span>
    <span class="k">case</span> <span class="nl">WEST:</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The direction is WEST."</span><span class="o">);</span> 
        <span class="k">break</span><span class="o">;</span>
    <span class="k">case</span> <span class="nl">NORTH:</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The direction is NORTH."</span><span class="o">);</span> 
        <span class="k">break</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Invalid direction."</span><span class="o">);</span> 
        <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<h4 id="다양한-메소드">다양한 메소드</h4>
<p>열거형에 정의된 모든 상수를 출력하려면 다음과 같이 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Direction</span><span class="o">[]</span> <span class="n">dArr</span> <span class="o">=</span> <span class="n">Direction</span><span class="o">.</span><span class="na">values</span><span class="o">();</span>

<span class="k">for</span><span class="o">(</span><span class="n">Direction</span> <span class="n">d</span> <span class="o">:</span> <span class="n">dArr</span> <span class="o">)</span> 
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%s=%d%n"</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="na">name</span><span class="o">(),</span> <span class="n">d</span><span class="o">.</span><span class="na">original</span><span class="o">());</span>
</code></pre></div></div>
<ul>
  <li><code class="highlighter-rouge">values()</code> : 열거형의 모든 상수를 배열에 담아 반환한다.</li>
  <li><code class="highlighter-rouge">ordinal()</code> : 모든 열거형의 조상인 <code class="highlighter-rouge">java.lang.Enum</code> 클래스에 정의된 것으로, 정의된 순서를 정수로 반환한다.</li>
  <li><code class="highlighter-rouge">name()</code> : 열거형 상수의 이름을 문자열로 반환한다.</li>
  <li><code class="highlighter-rouge">valueOf()</code> : 지정된 열거형에서 name과 일치하는 열거형 상수를 반환한다.</li>
</ul>

<h3 id="열거형의-생성자">열거형의 생성자</h3>
<p>Enum 타입은 열거형을 의미하는 특별한 형태의 클래스이기 때문에 일반 클래스와 같이<br />
생성자가 존재하여애 한다. 자바가 기본 생성자를 만들어주긴 하지만, <br />
열거형의 생성자는 제어자가 묵시적으로 private으로 지정해줘야 한다.</p>

<p>이유는 고정된 상수의 집합으로 런타임이 아닌 컴파일 타임에 모든 값을 <br />
알고 있어야 하기 때문이다.<br />
즉, 다른 패키지나 클래스에서 접근해 동적으로 값을 할당할 수 없다.</p>

<h3 id="열거형에-멤버-추가하기">열거형에 멤버 추가하기</h3>
<p><code class="highlighter-rouge">oridinal()</code>이 열거형 상수가 정의된 순서를 반환하지만, <br />
내부적인 용도로만 사용되기 위한 것이기 때문에 열거형 상수의 값으로 사용하지 않는 것이 좋다.</p>

<p>열거 상수의 값이 불규칙적인 경우에는 다음과 같이 열거형 상수 이름 옆에 <br />
원하는 값을 괄호와 함께 적어준다.<br />
그리고 지정된 값을 저장할 수 있는 인스턴스 변수와 생성자를 새로 추가해주어야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">Direction</span> <span class="o">{</span>
    <span class="n">EAST</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">SOUTH</span><span class="o">(</span><span class="mi">5</span><span class="o">),</span> <span class="n">WEST</span><span class="o">(-</span><span class="mi">1</span><span class="o">),</span> <span class="n">NORTH</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
    
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span> <span class="c1">// 정수를 저장할 필드(인스턴스 변수) 추가</span>
    <span class="n">Direction</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">value</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>필요에 따라 하나의 열거형 상수에 여러 값을 지정할 수 있다.<br />
이에 맞게 인스턴스 변수와 생성자 등을 새로 추가해주어야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">Direction</span> <span class="o">{</span>
    <span class="n">EAST</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"&gt;"</span><span class="o">),</span> <span class="n">SOUTH</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="s">"V"</span><span class="o">),</span> <span class="n">WEST</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="s">"&lt;"</span><span class="o">),</span> <span class="n">NORTH</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="s">"^"</span><span class="o">);</span>
    
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span> <span class="c1">// 정수를 저장할 필드(인스턴스 변수) 추가</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">symbol</span><span class="o">;</span>
    <span class="n">Direction</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">,</span> <span class="n">String</span> <span class="n">symbol</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">symbol</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">value</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getSymbol</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">symbol</span><span class="o">;}</span>
</code></pre></div></div>
<h4 id="example">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">Direction</span> <span class="o">{</span> 
    <span class="n">EAST</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"&gt;"</span><span class="o">),</span> <span class="n">SOUTH</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="s">"V"</span><span class="o">),</span> <span class="n">WEST</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"&lt;"</span><span class="o">),</span> <span class="n">NORTH</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="s">"^"</span><span class="o">);</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Direction</span><span class="o">[]</span> <span class="n">DIR_ARR</span> <span class="o">=</span> <span class="n">Direction</span><span class="o">.</span><span class="na">values</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">symbol</span><span class="o">;</span>

    <span class="n">Direction</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">,</span> <span class="n">String</span> <span class="n">symbol</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// private Direction(int value)</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span>  <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">symbol</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="o">()</span>      <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span>  <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getSymbol</span><span class="o">()</span>  <span class="o">{</span> <span class="k">return</span> <span class="n">symbol</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Direction</span> <span class="nf">of</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">dir</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">dir</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Invalid value :"</span> <span class="o">+</span> <span class="n">dir</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">DIR_ARR</span><span class="o">[</span><span class="n">dir</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>		
    <span class="o">}</span>	

    <span class="c1">// 방향을 회전시키는 메서드. num의 값만큼 90도씩 시계방향으로 회전한다.</span>
    <span class="kd">public</span> <span class="n">Direction</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">4</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">num</span> <span class="o">+=</span><span class="mi">4</span><span class="o">;</span> <span class="c1">// num이 음수일 때는 시계반대 방향으로 회전 </span>

        <span class="k">return</span> <span class="n">DIR_ARR</span><span class="o">[(</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">num</span><span class="o">)</span> <span class="o">%</span> <span class="mi">4</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">name</span><span class="o">()+</span><span class="n">getSymbol</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span> <span class="c1">// enum Direction</span>

<span class="kd">class</span> <span class="nc">EnumEx2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Direction</span> <span class="n">d</span> <span class="o">:</span> <span class="n">Direction</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> 
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%s=%d%n"</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="na">name</span><span class="o">(),</span> <span class="n">d</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span> 

        <span class="n">Direction</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">Direction</span><span class="o">.</span><span class="na">EAST</span><span class="o">;</span>
        <span class="n">Direction</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">Direction</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"d1=%s, %d%n"</span><span class="o">,</span> <span class="n">d1</span><span class="o">.</span><span class="na">name</span><span class="o">(),</span> <span class="n">d1</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"d2=%s, %d%n"</span><span class="o">,</span> <span class="n">d2</span><span class="o">.</span><span class="na">name</span><span class="o">(),</span> <span class="n">d2</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Direction</span><span class="o">.</span><span class="na">EAST</span><span class="o">.</span><span class="na">rotate</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Direction</span><span class="o">.</span><span class="na">EAST</span><span class="o">.</span><span class="na">rotate</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Direction</span><span class="o">.</span><span class="na">EAST</span><span class="o">.</span><span class="na">rotate</span><span class="o">(-</span><span class="mi">1</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Direction</span><span class="o">.</span><span class="na">EAST</span><span class="o">.</span><span class="na">rotate</span><span class="o">(-</span><span class="mi">2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h3 id="열거형에-추상-메서드-추가하기">열거형에 추상 메서드 추가하기</h3>
<h4 id="example-1">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">Transportation</span> <span class="o">{</span> 
    <span class="n">BUS</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>      <span class="o">{</span> <span class="kt">int</span> <span class="nf">fare</span><span class="o">(</span><span class="kt">int</span> <span class="n">distance</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">distance</span><span class="o">*</span><span class="n">BASIC_FARE</span><span class="o">;}},</span>
    <span class="n">TRAIN</span><span class="o">(</span><span class="mi">150</span><span class="o">)</span>    <span class="o">{</span> <span class="kt">int</span> <span class="nf">fare</span><span class="o">(</span><span class="kt">int</span> <span class="n">distance</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">distance</span><span class="o">*</span><span class="n">BASIC_FARE</span><span class="o">;}},</span>
    <span class="n">SHIP</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>     <span class="o">{</span> <span class="kt">int</span> <span class="nf">fare</span><span class="o">(</span><span class="kt">int</span> <span class="n">distance</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">distance</span><span class="o">*</span><span class="n">BASIC_FARE</span><span class="o">;}},</span>
    <span class="n">AIRPLANE</span><span class="o">(</span><span class="mi">300</span><span class="o">)</span> <span class="o">{</span> <span class="kt">int</span> <span class="nf">fare</span><span class="o">(</span><span class="kt">int</span> <span class="n">distance</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">distance</span><span class="o">*</span><span class="n">BASIC_FARE</span><span class="o">;}};</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">BASIC_FARE</span><span class="o">;</span> <span class="c1">// protected로 해야 각 상수에서 접근가능</span>
	
    <span class="n">Transportation</span><span class="o">(</span><span class="kt">int</span> <span class="n">basicFare</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// private Transportation(int basicFare) {</span>
		<span class="n">BASIC_FARE</span> <span class="o">=</span> <span class="n">basicFare</span><span class="o">;</span>
	<span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getBasicFare</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">BASIC_FARE</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">abstract</span> <span class="kt">int</span> <span class="nf">fare</span><span class="o">(</span><span class="kt">int</span> <span class="n">distance</span><span class="o">);</span> <span class="c1">// 거리에 따른 요금 계산</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">EnumEx3</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"bus fare="</span>     <span class="o">+</span><span class="n">Transportation</span><span class="o">.</span><span class="na">BUS</span><span class="o">.</span><span class="na">fare</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"train fare="</span>   <span class="o">+</span><span class="n">Transportation</span><span class="o">.</span><span class="na">TRAIN</span><span class="o">.</span><span class="na">fare</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ship fare="</span>    <span class="o">+</span><span class="n">Transportation</span><span class="o">.</span><span class="na">SHIP</span><span class="o">.</span><span class="na">fare</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"airplane fare="</span><span class="o">+</span><span class="n">Transportation</span><span class="o">.</span><span class="na">AIRPLANE</span><span class="o">.</span><span class="na">fare</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Transportation은 운송 수단의 종류 별로 상수를 정의하고 있고,<br />
각 운송 수단에는 기본요금이 책정되어 있다.<br />
여기서 거리에 따라 요금을 계산하는 방식이 각 운송 수단마다 다른 경우를 위해,<br />
추상 메서드 <code class="highlighter-rouge">fare(int distance)</code>를 선언해 각 열거형 상수가 이 추상 메서드를 반드시 구현해야 한다.</p>

<p>열거형에 추상 메서드를 선언할 일은 그리 많지 않다.</p>

<h3 id="열거형의-비교">열거형의 비교</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">Direction</span> <span class="o">{</span> <span class="n">EAST</span><span class="o">,</span> <span class="n">SOUTH</span><span class="o">,</span> <span class="n">WEST</span><span class="o">,</span> <span class="n">NORTH</span><span class="o">;</span> <span class="o">}</span>
</code></pre></div></div>
<p>이 열거형 상수 하나하나가 Direction 객체이다. <br />
Direction 클래스의 static 상수 EAST, SOUTH, WEST, NORTH의 값은 객체의 주소이고,<br />
이 값은 바뀌지 않는 값이므로 <code class="highlighter-rouge">==</code>로 비교가 가능하다.</p>

<h4 id="example-2">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">MyEnum</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">MyEnum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		
    <span class="kt">int</span> <span class="n">ordinal</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ordinal</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">ordinal</span><span class="o">;</span> <span class="o">}</span>
	
    <span class="n">MyEnum</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="n">ordinal</span> <span class="o">=</span> <span class="n">id</span><span class="o">++;</span>	
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">ordinal</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="na">ordinal</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>객체가 생성될 때마다 번호를 붙여서 인스턴스 변수 ordinal에 저장한다.<br />
그리고 Comparable 인터페이스를 구현해서 열거형 상수간의 비교가 가능하도록 되어 있다.</p>

<p>만일 클래스를 <code class="highlighter-rouge">MyEnum&lt;T&gt;</code>와 같이 선언하였다면, compareTo()를 위와 같이<br />
간단히 작성할 수 없었을 것이다.<br />
타입 T에 <code class="highlighter-rouge">ordinal()</code>이 정의되어 있는지 확인할 수 없기 때문이다.<br />
그래서 <code class="highlighter-rouge">MyEnum&lt;T extends&lt;MyEnum&lt;T&gt;&gt;</code>와 같이 선언한 것이며,<br />
이것은 타입 T가 <code class="highlighter-rouge">MyEnum&lt;T&gt;</code>의 자손이어야 한다는 의미이다.<br />
타입 T가 MyEnum의 자손이므로 ordinal()이 정의되어 있는 것은 분명하므로,<br />
형변환 없이도 에러가 나지 않는다.</p>

<p>그리고 추상 메서드를 새로 추가하면, 클래스 앞에도 abstract를 붙여줘야 하고,<br />
각 static 상수들도 추상 메서드를 구현해주어야 한다.</p>

<h3 id="참고-자료">참고 자료</h3>
<ul>
  <li>자바의 정석 3판</li>
  <li><a href="https://www.nextree.co.kr/p11686/">Java: enum의 뿌리를 찾아서</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>📖 Effective java item 34 - int 상수 대신 열거 타입을 사용하라</title>
	  <link>//Effective-java-item-34-int-%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%AE-%E1%84%83%E1%85%A2%E1%84%89%E1%85%B5%E1%86%AB-%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%80%E1%85%A5-%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%85%E1%85%A1</link>
	  <author></author>
	  <pubDate>2021-02-20T19:18:00+09:00</pubDate>
	  <guid>//Effective-java-item-34-int-%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%AE-%E1%84%83%E1%85%A2%E1%84%89%E1%85%B5%E1%86%AB-%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%80%E1%85%A5-%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%85%E1%85%A1</guid>
	  <description><![CDATA[
	     <h2 id="enum-">Enum ?</h2>
<p><a href="https://velog.io/@new_wisdom/Java-Enum-%EC%97%B4%EA%B1%B0%ED%98%95">[Java] Enum 열거형</a></p>
<h2 id="int-enum-pattern의-단점">int Enum Pattern의 단점</h2>
<h3 id="타입-안전을-보장할-방법이-없다">타입 안전을 보장할 방법이 없다.</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">APPLE_FUJI</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">APPLE_PIPPIN</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">APPLE_GRANNY_SMITH</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ORANGE_NAVEL</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ORANGE_TEMPLE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ORANGE_BLOOD</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
</code></pre></div></div>
<p>위와 같은 예제에서는 사과용 상수 이름은 모두 <code class="highlighter-rouge">APPLE_</code>로 시작,<br />
오렌지용 상수는 <code class="highlighter-rouge">ORANGE_</code>로 시작한다.<br />
이는 표현력이 좋지 않다.<br />
자바가 정수 열거 패턴을 위한 별도 이름 공간을 지원하지 않는다.</p>

<h3 id="프로그램이-깨지기-쉽다">프로그램이 깨지기 쉽다.</h3>
<p>평범한 상수를 나열한 것뿐이라 컴파일하면 그 값이 클라이언트 파일에 그대로 새겨진다.<br />
상수의 값이 바뀌면 클라이언트도 반드시 다시 컴파일해야 한다.</p>

<h3 id="문자열로-출력하기-까다롭다">문자열로 출력하기 까다롭다.</h3>
<p>값을 출력하거나 디버거로 살펴보면 단지 숫자로만 보여서 썩 도움이 되지 않는다.<br />
같은 정수 열거 그룹에 속한 모든 상수를 순회하는 방법도 마땅하지 않다.<br />
또 이 안에 상수가 몇 개인지도 알 수 없다.</p>

<h4 id="정수-대신-문자열-상수를-사용하는-변형-패턴은">정수 대신 문자열 상수를 사용하는 변형 패턴은?</h4>
<p>더 나쁘다.
상수의 의미를 출력할 수 있다는 점은 좋지만,<br />
문자열 상수릐 이름 대신 문자열 값을 그대로 하드코딩하게 만들기 떄문이다.<br />
문자열에 오타가 있어도 컴파일러는 확인할 길이 없으니 자연스럽게 런타임 버그가 생긴다.<br />
또 문자열 비교는 비교적 성능 저하를 일으킨다.</p>

<h2 id="열거-타입enum">열거 타입(Enum)</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Apple</span> <span class="o">{</span><span class="n">FUJI</span><span class="o">,</span> <span class="n">PIPPIN</span><span class="o">,</span> <span class="n">GRANNY_SMITH</span><span class="o">}</span>
<span class="kd">public</span> <span class="kd">enum</span> <span class="n">Orange</span> <span class="o">{</span><span class="n">NAVEL</span><span class="o">,</span> <span class="n">TEMPLE</span><span class="o">,</span> <span class="n">BLOOD</span><span class="o">}</span>
</code></pre></div></div>
<p>C, C++ 같은 다른 언어의 열거 타입과 다른 점은 자바의 열거 타입은 완전한 형태의 클래스다.</p>

<p>열거 타입 자체는 클래스며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 <br />
<code class="highlighter-rouge">public static final</code> 필드로 공개한다.<br />
열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 final이다.<br />
따라서 클라이언트가 인스턴스를 직접 생성하거나 확장할 수 없으니 열거 타입 선언으로 <br />
만들어진 인스턴스들은 딱 하나씩만 존재함이 보장된다.<br />
즉 열거 타입은 인스턴스 통제된다. <br />
싱글턴은 원소가 하나뿐인 열거타입이라 할 수 있고, <br />
열거 타입은 싱글턴을 일반화한 형태라고 볼 수 있다.</p>

<h3 id="컴파일타임-타입-안정성-제공">컴파일타임 타입 안정성 제공</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Apple</span> <span class="o">{</span><span class="n">FUJI</span><span class="o">,</span> <span class="n">PIPPIN</span><span class="o">,</span> <span class="n">GRANNY_SMITH</span><span class="o">}</span>
<span class="kd">public</span> <span class="kd">enum</span> <span class="n">Orange</span> <span class="o">{</span><span class="n">NAVEL</span><span class="o">,</span> <span class="n">TEMPLE</span><span class="o">,</span> <span class="n">BLOOD</span><span class="o">}</span>
</code></pre></div></div>
<p>위 코드에서 Apple의 열거 타입을 매개변수로 받는 메서드를 선언했다면,<br />
건네받은 참조는 Apple의 세 가지 값 중 하나임이 확실하다.<br />
다른 타입의 값을 넘기려 하면 컴파일 오류가 난다.<br />
타입이 다른 열거 타입 변수에 할당하려 하거나 <br />
다른 열거 타입의 값 끼리 <code class="highlighter-rouge">==</code> 연산자로 비교하려는 꼴이기 때문이다.</p>

<h3 id="각자의-이름-공간이-존재한다">각자의 이름 공간이 존재한다.</h3>
<p>때문에 이름이 같은 상수도 평화롭게 공존한다.<br />
열거 타입에 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일 하지 않아도 된다.<br />
열거 타입에 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일 하지 않아도 된다.<br />
공개되는 것이 오직 필드의 이름뿐이니 ,<br />
정수 열거 패턴과 달리 상수 값이 클라이언트로 컴파일 되어 각인되지 않기 때문이다.</p>

<h3 id="문자열로-출력하기-적합하다">문자열로 출력하기 적합하다.</h3>
<p>열거타입의 <code class="highlighter-rouge">toString()</code>은 출력하기에 적합한 문자열을 내어준다.</p>

<h3 id="임의의-메서드-필드를-추가하고-임의의-인터페이스를-구현할-수도-있다">임의의 메서드, 필드를 추가하고 임의의 인터페이스를 구현할 수도 있다.</h3>
<p><code class="highlighter-rouge">Object</code> 메서드들을 높은 품질로 구현해놨고, <code class="highlighter-rouge">Comparable</code>과 <code class="highlighter-rouge">Serializable</code>을 <br />
구현했으며, 그 직렬화 형태도 웬만큼 변형을 가해도 문제없이 동작하게끔 구현해놨다.</p>

<h2 id="열거-타입-사용-경우">열거 타입 사용 경우</h2>
<h3 id="각-상수와-연관된-데이터를-해당-상수-자체에-내재시킬-때">각 상수와 연관된 데이터를 해당 상수 자체에 내재시킬 때</h3>
<p>예제로 들었던 Apple과 Orange에 과일 색을 알려주거나, <br />
과일 이미지를 반환하는 메서드를 추가한다면, 열거 타입에 이 기능을 메서드로 추가할 수 있다.</p>

<p>가장 단순하게는 그저 상수의 모음일 뿐인 열거 타입이지만, <br />
고차원의 추상 개념 하나를 완벽히 표현해낼 수도 있다.</p>

<h4 id="example">Example</h4>
<p>태양개의 행성에는 각각 질량과 반지름이 있고, 이 두 속성을 이용해 표면중력을 계산할 수 있다.<br />
따라서 어떤 객체의 질량이 주어지면 그 객체가 행성 표면에 있을 때의 무게도 계산할 수 있다.<br />
표면 중력을 계산해 저장한 이유는 단순히 최적화를 위해서다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">enum</span> <span class="n">Planet</span> <span class="o">{</span>
    <span class="n">MERCURY</span><span class="o">(</span><span class="mf">3.302</span><span class="n">e</span><span class="o">+</span><span class="mi">23</span><span class="o">,</span> <span class="mf">2.439e6</span><span class="o">),</span>
    <span class="n">VENUS</span><span class="o">(</span><span class="mf">4.869</span><span class="n">e</span><span class="o">+</span><span class="mi">24</span><span class="o">,</span> <span class="mf">6.052e6</span><span class="o">),</span>
    <span class="n">EARTH</span><span class="o">(</span><span class="mf">5.975</span><span class="n">e</span><span class="o">+</span><span class="mi">24</span><span class="o">,</span> <span class="mf">6.378e6</span><span class="o">),</span>
    <span class="n">MARS</span><span class="o">(</span><span class="mf">6.419</span><span class="n">e</span><span class="o">+</span><span class="mi">23</span><span class="o">,</span> <span class="mf">3.393e6</span><span class="o">),</span>
    <span class="n">JUPITER</span><span class="o">(</span><span class="mf">1.899</span><span class="n">e</span><span class="o">+</span><span class="mi">27</span><span class="o">,</span> <span class="mf">7.149e7</span><span class="o">),</span>
    <span class="n">SATURN</span><span class="o">(</span><span class="mf">5.685</span><span class="n">e</span><span class="o">+</span><span class="mi">26</span><span class="o">,</span> <span class="mf">6.027e7</span><span class="o">),</span>
    <span class="n">URANUS</span><span class="o">(</span><span class="mf">8.683</span><span class="n">e</span><span class="o">+</span><span class="mi">25</span><span class="o">,</span> <span class="mf">2.556e7</span><span class="o">),</span>
    <span class="n">NEPTUNE</span><span class="o">(</span><span class="mf">1.024</span><span class="n">e</span><span class="o">+</span><span class="mi">26</span><span class="o">,</span> <span class="mf">2.447e7</span><span class="o">);</span>
    
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">mass</span><span class="o">;</span>            <span class="c1">// 질량(단위: 킬로그램)</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">radius</span><span class="o">;</span>          <span class="c1">// 반지름(단위: 미터)</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">surfaceGravity</span><span class="o">;</span>  <span class="c1">// 표면중력(단위: m / s^2)</span>
    
    <span class="c1">// 중력상수 (단위: m^3 / kg s^2)</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">G</span> <span class="o">=</span> <span class="mf">6.67300</span><span class="n">E</span><span class="o">-</span><span class="mi">11</span><span class="o">;</span>
    
    <span class="c1">// 생성자</span>
    <span class="n">Planet</span><span class="o">(</span><span class="kt">double</span> <span class="n">mass</span><span class="o">,</span> <span class="kt">double</span> <span class="n">radius</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">mass</span> <span class="o">=</span> <span class="n">mass</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">surfaceGravity</span> <span class="o">=</span> <span class="n">G</span> <span class="o">*</span> <span class="n">mass</span> <span class="o">/</span> <span class="o">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">surfaceWeight</span><span class="o">(</span><span class="kt">double</span> <span class="n">mass</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">mass</span> <span class="o">*</span> <span class="n">surfaceGravity</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>열거 타입 상수 각각을 특정 데이터와 연관지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.</p>

<h4 id="열거-타입은-근본적으로-불변이라-모든-필드는-final이어야-한다">열거 타입은 근본적으로 불변이라 모든 필드는 final이어야 한다.</h4>
<p>필드를 public으로 선언해도 되지만 private로 두어 별도의 public 접근자 메서드를 두는게 낫다.</p>

<p>어떤 객체의 지구에서의 무게를 입력받아 행성에서의 무게를 출력하는 일을 
다음같이 짧게 작성할 수도 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">classs</span> <span class="n">WeightTable</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    	<span class="kt">double</span> <span class="n">earthWeight</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">parseDouble</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="kt">double</span> <span class="n">mass</span> <span class="o">=</span> <span class="n">earthWeight</span> <span class="o">/</span> <span class="n">Planet</span><span class="o">.</span><span class="na">EARTH</span><span class="o">.</span><span class="na">surfaceGravity</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Planet</span> <span class="n">p</span> <span class="o">:</span> <span class="n">Palanet</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> 
        	<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"%s에서 무게는 %f이다. %n"</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">surfaceWeight</span><span class="o">(</span><span class="n">mass</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="지원하는-메서드">지원하는 메서드</h3>
<ul>
  <li><code class="highlighter-rouge">values()</code> : 자신 안에 정의된 상수들의 값을 배열에 담아 반환하는 
정적 메서드, 값들은 선언된 순서로 저장</li>
  <li><code class="highlighter-rouge">valueOf()</code> : 상수 이름을 입력받아 그 이름에 해당하는 상수를 반환</li>
  <li><code class="highlighter-rouge">toString()</code> : 상수 이름을 문자열로 반환, 원하는 대로 재정의도 가능하다.</li>
  <li><code class="highlighter-rouge">fromString()</code> : <code class="highlighter-rouge">toString</code>이 반환하는 문자열을 해당 열거 타입 상수로 변환</li>
</ul>

<h4 id="열거-타입에서-상수를-하나-제거하면">열거 타입에서 상수를 하나 제거하면?</h4>
<p>제거한 상수를 참조하지 않는 클라이언트에는 아무 영향이 없다.<br />
제거된 상수를 참조하는 클라이언트는 컴파일타임에 오류가 발생해 이를 잡을 수 있다.</p>

<h3 id="상수마다-동작이-달라져야-할-경우">상수마다 동작이 달라져야 할 경우</h3>
<p>사칙연산 계산기의 연산 종류를 열거 타입으로 선언하고,
실제 연산까지 열거 타입 상수가 직접 수행하기로 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Operation</span> <span class="o">{</span>
    <span class="n">PLUS</span><span class="o">,</span> <span class="n">MINUS</span><span class="o">,</span> <span class="n">TIMES</span><span class="o">,</span> <span class="n">DIVIDE</span>
<span class="o">}</span>
</code></pre></div></div>
<h4 id="switch-문으로-분기처리"><code class="highlighter-rouge">switch</code> 문으로 분기처리</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 상수가 뜻하는 연산을 수행한다. */</span>
<span class="kd">public</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">switch</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nl">PLUS:</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">case</span> <span class="nl">MINUS:</span> <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">case</span> <span class="nl">TIMES:</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">case</span> <span class="nl">DIVIDE:</span> <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">(</span><span class="s">"알 수 없는 연산: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이 방법의 단점은 깨지기 쉬운 코드라는 것이다.<br />
새로운 상수를 추가하면 해당 case 문도 추가해주어야 한다.</p>

<p>하지만 기존 열거 타입에 상수별 동작을 혼합해서 넣을 때는 좋은 선택이다.<br />
추가하려는 메서드가 의미상 열거 타입에 속하지 않는다면 직접 만든 열거 타입이라도 이 방식이 유용하다.</p>

<h4 id="apply-추상-메서드-선언"><code class="highlighter-rouge">apply()</code> 추상 메서드 선언</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Operation</span> <span class="o">{</span>
    <span class="n">PLUS</span> <span class="o">{</span><span class="kd">public</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;}},</span>
    <span class="n">MINUS</span> <span class="o">{</span><span class="kd">public</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;}},</span>
    <span class="n">TIMES</span> <span class="o">{</span><span class="kd">public</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;}},</span>
    <span class="n">DIVIDE</span> <span class="o">{</span><span class="kd">public</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;}};</span>
    
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">apply()</code>가 추상 메서드이므로 재정의하지 않았다면 컴파일 오류로 알려준다.</p>

<h4 id="상수별-클래스-몸체와-데이터를-사용">상수별 클래스 몸체와 데이터를 사용</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Operation</span> <span class="o">{</span>
    <span class="n">PLUS</span><span class="o">(</span><span class="s">"+"</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;}</span>
    <span class="o">}</span>
    <span class="n">MINUS</span><span class="o">(</span><span class="s">"-"</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">;}</span>
    <span class="o">}</span>
    <span class="n">TIMES</span><span class="o">(</span><span class="s">"*"</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">;}</span>
    <span class="o">}</span>
    <span class="n">DIVIDE</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">;}</span>
    <span class="o">};</span>
    
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">symbol</span><span class="o">;</span>
    
    <span class="n">Operation</span><span class="o">(</span><span class="n">String</span> <span class="n">symbol</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">symbol</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">;}</span>
    
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">symbol</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<h4 id="열거-타입용-fromstring-메서드-구현">열거 타입용 fromString 메서드 구현</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Operation</span><span class="o">&gt;</span> <span class="n">stringToEnum</span> <span class="o">=</span> 
<span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">values</span><span class="o">()).</span><span class="na">collect</span><span class="o">(</span><span class="n">toMap</span><span class="o">(</span><span class="nl">Object:</span><span class="o">:</span><span class="n">toString</span><span class="o">,</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">));</span>

<span class="cm">/* 지정한 문자열에 해당하는 Operation을 (존재한다면) 반환한다. */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Operation</span><span class="o">&gt;</span> <span class="nf">fromString</span><span class="o">(</span><span class="n">String</span> <span class="n">symbol</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">stringToEnum</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">symbol</span><span class="o">));</span>
<span class="o">}</span>

</code></pre></div></div>
<p>Operation 상수가 stringToEnum 맵에 추가되는 시점은 
열거 타입 상수 생성 후 정적 필드가 초기화 될 때이다.</p>

<p>위 예제는 values 메서드가 반환하는 배열 대신 스트림을 사용했다.</p>

<p>열거 타입 상수는 생성자에서 자신의 인스턴스를 맵에 추가할 수 없다.<br />
이렇게 하려면 컴파일 오류가 나는데, 이 방식이 허용된다면 런타임에 <code class="highlighter-rouge">NullPointerException</code>이 발생했을 것이다.</p>

<p>열거 타입의 정적 필드 중 열거 타입의 생성자에서 접근할 수 있는 것은 상수 변수 뿐이다.</p>

<p>열거 타입 생성자가 실행되는 시점에는 정적 필드들이 아직 초기화되기 전이라, <br />
자기 자신을 추가하지 못하게 하는 제약이 꼭 필요하다.<br />
특수한 예로, 열거 타입 생성자에서 같은 열거 타입의 다른 상수에도 접근할 수 없다. <br />
(열거 타입의 각 상수는 해당 열거 타입의 인스턴스를 <code class="highlighter-rouge">public static final</code> 필드로 선언했다.<br />
즉, 다른 형제 상수도 <code class="highlighter-rouge">static</code>이므로 열거 타입 생성자에서 정적 필드에 접근할 수 없다는 제약이 적용된다.)</p>

<p>또한, 위 예제에서 <code class="highlighter-rouge">fromString</code>이 <code class="highlighter-rouge">Optional&lt;Operation&gt;</code>을 반환하는 점도 주의하자.<br />
주어진 문자열이 가리키는 연산이 존재하지 않을 수 있음을 클라이언트에 알리고, 
그 상황을 클라이언트에서 대처하도록 한 것이다.</p>

<h4 id="값에-따라-분기하여-코드를-공유하는-열거-타입---좋은-방법인가">값에 따라 분기하여 코드를 공유하는 열거 타입 - 좋은 방법인가?</h4>
<p>상수별 메서드 구현에는 열거 타입 상수끼리 코드를 공유하기 어렵다는 단점이 있다.<br />
예시로 급여명세서에서 쓸 요일을 표현하는 열거 타입을 예로 생각해 보면,
직원의 기본 임금, 그날 일한 시간이 주어지면 일당을 계산해주는 메서드를 가지고 있다.<br />
주중에 오버타임이 발생하면 잔업 수장이 주어지고, 주말에는 무조건 잔업 수당이 주어진다.<br />
<code class="highlighter-rouge">switch</code> 문을 이용하면 case 문을 날짜별로 두어 이 계산을 쉽게 수행할  수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">PayrollDay</span> <span class="o">{</span>
    <span class="n">MONDAY</span><span class="o">,</span> <span class="n">TUESDAY</span><span class="o">,</span> <span class="n">WEDSDAY</span><span class="o">,</span> <span class="n">THURSDAY</span><span class="o">,</span> <span class="n">FRIDAY</span><span class="o">,</span> <span class="n">SATURDAY</span><span class="o">,</span> <span class="n">SUNDAY</span><span class="o">;</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MINS_PER_SHIFT</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">60</span><span class="o">;</span>
    
    <span class="kt">int</span> <span class="nf">pay</span><span class="o">(</span><span class="kt">int</span> <span class="n">minutesWorked</span><span class="o">,</span> <span class="kt">int</span> <span class="n">payRate</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">basePay</span> <span class="o">=</span> <span class="n">minutesWorked</span> <span class="o">*</span> <span class="n">payRate</span><span class="o">;</span>
        
        <span class="kt">int</span> <span class="n">overtimePay</span><span class="o">;</span>
        <span class="k">switch</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nl">SATURDAY:</span> <span class="k">case</span> <span class="nl">SUNDAY:</span> <span class="c1">// 주말</span>
                <span class="n">overtimePay</span> <span class="o">=</span> <span class="n">basePay</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span> <span class="c1">// 주중</span>
                <span class="n">overtimePay</span> <span class="o">=</span> <span class="n">minutesWOrked</span> <span class="o">&lt;=</span> <span class="n">MINS_PER_SHIFT</span> <span class="o">?</span>
                <span class="mi">0</span> <span class="o">:</span> <span class="n">minutesWorked</span> <span class="o">-</span> <span class="n">MINS_PER_SHIFT</span><span class="o">)</span> <span class="o">*</span> <span class="n">payRate</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
            
        <span class="k">return</span> <span class="n">basePay</span> <span class="o">+</span> <span class="n">overtimePay</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이 코드의 문제점은 휴가와 같은 새로운 값을 열거 타입에 추가하려면 그 값을 처리하는 
<code class="highlighter-rouge">case</code>문을 잊지 말고 쌍으로 넣어줘야 한다.</p>

<p>PayrollDay에 평일 잔업수당 계산용 메서드인 overtimePay를 구현해놓고,
주말 상수에서만 재정의해 써도, 새로운 상수를 추가하면서 overtimePay 메서드를 
재정의하지 않으면 평일용 코드를 그대로 물려받게 된다.</p>

<h4 id="정략-열거-타입-패턴">정략 열거 타입 패턴</h4>
<p>새로운 상수를 추가할 때 잔업수당 ‘전략’을 선택하도록 하는 것이다.<br />
잔업 수당 계산을 private 중첩 열거 타입(PayType)으로 옮기고,
PayrollDay 열거 타입의 생성자에서 이 중 적당한 것을 선택한다.</p>

<p>그러면 payrollDay 열거 타입은 잔업수당 계산을 그 전략 열거 타입에 위임하여, 
switch 문이나 상수별 메서드 구현이 필요 없게 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">PayrollDay</span> <span class="o">{</span>
    <span class="n">MONDAY</span><span class="o">,</span> <span class="n">TUESDAY</span><span class="o">,</span> <span class="n">WEDSDAY</span><span class="o">,</span> <span class="n">THURSDAY</span><span class="o">,</span> <span class="n">FRIDAY</span><span class="o">,</span> 
    <span class="n">SATURDAY</span><span class="o">(</span><span class="n">PayTyoe</span><span class="o">.</span><span class="na">WEEKEND</span><span class="o">),</span> <span class="n">SUNDAY</span><span class="o">(</span><span class="n">PayType</span><span class="o">.</span><span class="na">WEEKEND</span><span class="o">);</span>
    
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">PayType</span> <span class="n">payType</span><span class="o">;</span>
    
    <span class="n">PayrollDya</span><span class="o">(</span><span class="n">PayType</span> <span class="n">payTyoe</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">payType</span> <span class="o">=</span> <span class="n">payType</span><span class="o">;}</span>
    
    <span class="kt">int</span> <span class="nf">pay</span><span class="o">(</span><span class="kt">int</span> <span class="n">minutesWorked</span><span class="o">,</span> <span class="kt">int</span> <span class="n">payRate</span><span class="o">)</span> <span class="o">{</span>
    	<span class="k">return</span> <span class="n">payType</span><span class="o">.</span><span class="na">pay</span><span class="o">(</span><span class="n">minutesWorked</span><span class="o">,</span> <span class="n">payRate</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/* 전략 열거 타입 */</span>
    <span class="kd">enum</span> <span class="n">PayType</span> <span class="o">{</span>
        <span class="n">WEEKDAY</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="nf">overtimePay</span><span class="o">(</span><span class="kt">int</span> <span class="n">minusWorked</span><span class="o">,</span> <span class="kt">int</span> <span class="n">payRate</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">minusWorked</span> <span class="o">&lt;=</span> <span class="n">MINS_PER_SHIFT</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
                <span class="o">(</span><span class="n">minusWorked</span> <span class="o">-</span> <span class="n">MINS_PER_SHIFT</span><span class="o">)</span> <span class="o">*</span> <span class="n">payRate</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">},</span>
        <span class="n">WEEKEND</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="nf">overtimePay</span><span class="o">(</span><span class="kt">int</span> <span class="n">minusWorked</span><span class="o">,</span> <span class="kt">int</span> <span class="n">payRate</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">minusWorked</span> <span class="o">*</span> <span class="n">payRate</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">};</span>
        
        <span class="kd">abstract</span> <span class="kt">int</span> <span class="nf">overtimePay</span><span class="o">(</span><span class="kt">int</span> <span class="n">mins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">payRate</span><span class="o">);</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MINS_PER_SHIFT</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">60</span><span class="o">;</span>
        
        <span class="kt">int</span> <span class="nf">pay</span><span class="o">(</span><span class="kt">int</span> <span class="n">minsWorked</span><span class="o">,</span> <span class="kt">int</span> <span class="n">payRate</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">basePay</span> <span class="o">=</span> <span class="n">minsWorked</span> <span class="o">*</span> <span class="n">payRate</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">basePay</span> <span class="o">+</span> <span class="n">overtimePay</span><span class="o">(</span><span class="n">minsWorked</span><span class="o">,</span> <span class="n">payRate</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="필요한-원소를-컴파일타임에-다-알-수-있는-상수-집합이라면-항상-열거-타입을-사용하자">필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면, 항상 열거 타입을 사용하자</h3>
<p>열거 타입에 정의된 상수 개수가 영원히 고정 불변일 필요는 없다.<br />
열거 타입은 나중에 상수가 추가돼도 바이너리 수준에서 호환되도록 설계되었다.</p>

<h3 id="정리">정리</h3>
<ul>
  <li>열거 타입은 정수 상수보다 읽기 쉽고, 안전하고 강력하다.</li>
  <li>열거 타입은 명시적 생성자나 메서드 없이 쓰이지만, 각 상수를 특정 데이터와 
연결짓거나 상수마다 다르게 동작하게 할 때 필요하다.</li>
  <li>드물게 하나의 메서드가 상수별로 다르게 동작해야 할 때도 있다.
이런 열거 타입에서는 switch 문 대신 상수별 메서드 구현을 사용한다.</li>
  <li>열거 타입 상수 일부가 같은 동작을 공유하면 전략 열거 타입 패턴을 사용하자.</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>📖 Effective java item 28 - 배열보다는 리스트를 사용하라</title>
	  <link>//Effective-java-item-28-%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%87%E1%85%A9%E1%84%83%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%85%E1%85%A1</link>
	  <author></author>
	  <pubDate>2021-02-17T19:18:00+09:00</pubDate>
	  <guid>//Effective-java-item-28-%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%87%E1%85%A9%E1%84%83%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%85%E1%85%A1</guid>
	  <description><![CDATA[
	     <p>우테코 Level 1 로또 미션에서 “배열 대신 ArrayList를 사용한다.”가 요구사항에 들어있었다.<br />
왜 배열대신 ArrayList를 사용하라는 것일까?<br />
찾아보니 이펙티브 자바에서도 그 내용이 나와 있어서 스스로의 물음에 답하는 내용을 정리하려 한다.</p>

<h2 id="array배열-vs-arraylist리스트">Array(배열) vs ArrayList(리스트)</h2>
<p>들어가기에 앞서 이펙티브 자바를 보기 전 Array과 ArrayList의 차이점을 간단히 적어본다.</p>
<h3 id="array배열">Array(배열)</h3>
<ul>
  <li>사이즈가 정적인 데이터 구조이다. 일단 생성되면 크기를 변경할 수 없다.</li>
  <li>원시 타입과 객체 모두 원소로 포함할 수 있다.</li>
  <li><code class="highlighter-rouge">for</code> 또는 <code class="highlighter-rouge">for-each</code> 루프를 통해서 반복된다.</li>
  <li>길이에 대해 <code class="highlighter-rouge">length</code> 변수를 사용한다.</li>
  <li>Generic(제네릭)을 사용 할 수 없다.</li>
  <li>원소를 할당하기 위해 할당 연산자<code class="highlighter-rouge">=</code>를 사용한다.</li>
</ul>

<h3 id="arraylist리스트">ArrayList(리스트)</h3>
<ul>
  <li>사이즈가 동적인 데이터 구조이다. 용량을 초과하는 요소를 추가하면 크기가 자동으로 증가한다.</li>
  <li>객체 원소만 포함할 수 있다.</li>
  <li>요소를 반복하는 iterators를 제공한다.</li>
  <li>길이에 대해 <code class="highlighter-rouge">size()</code> 메서드를 사용한다.</li>
  <li>Generic(제네릭)을 지원한다.</li>
  <li>원소를 할당하기 위해 <code class="highlighter-rouge">add()</code> 메서드를 사용한다.</li>
  <li>Collections가 제공하는 다양한 메소드들을 사용할 수 있다.</li>
</ul>

<h1 id="effective-java-item-28">Effective Java item 28</h1>
<h2 id="배열과-제네릭-타입의-차이">배열과 제네릭 타입의 차이</h2>
<h3 id="배열은-공변이다">배열은 공변이다.</h3>
<p><code class="highlighter-rouge">Sub</code>가 <code class="highlighter-rouge">Super</code>의 하위 타입이라면 배열 <code class="highlighter-rouge">Sub[]</code>는 <code class="highlighter-rouge">Super[]</code>의 하위 타입이 된다.<br />
즉 함께 변한다는 말이다.<br />
하지만 제네릭은 불공변으로 서로 다른 타입 <code class="highlighter-rouge">Type1</code>, <code class="highlighter-rouge">Type2</code>가 있을 때, <br />
<code class="highlighter-rouge">List&lt;Type1&gt;</code>은 <code class="highlighter-rouge">List&lt;Type2&gt;</code>의 하위 타입도, 상위 타입도 아니다.</p>

<h4 id="공변이-왜-문제가-되지">공변이 왜 문제가 되지?</h4>
<p>아래 코드는 문법상 허용은 되지만 런타임에 실패한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Object</span><span class="o">[]</span> <span class="n">objectArray</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Long</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
<span class="cm">/* ArrayStoreException 발생 */</span>
<span class="n">objectArray</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"타입이 달라 넣을 수 없음"</span><span class="o">;</span>
</code></pre></div></div>
<p>또 아래 코드는 컴파일 오류를 일으킨다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">objectList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;();</span>
<span class="n">objectList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"타입이 달라 넣을 수 없음"</span><span class="o">);</span>
</code></pre></div></div>
<p>두 코드 모두에서 Long용 저장소에 String을 넣을 수 없다.<br />
배열은 이를 런타임에 알게 되지만 리스트는 컴파일 때 바로 알 수 있다.</p>

<h3 id="배열은-실체화된다">배열은 실체화된다.</h3>
<p>배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.<br />
때문에 Long용 저장소에 String을 넣으려 하면 ArrayStoreException을 발생시킨다.</p>

<p>하지만 제네릭은 타입 정보가 런타임에는 소거된다.<br />
이는 원소의 타입을 컴파일 타임에만 검사하며 런타임에는 알 수 없다는 것이다.<br />
여기서 타입 정보의 소거라 함은 제네릭이 지원되기 전 <br />
레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해준다.</p>

<h2 id="제네릭-배열을-만들지-못하게-한-이유">제네릭 배열을 만들지 못하게 한 이유?</h2>
<p>그 이유는 타입 안전하지 않기 떄문이다.
제네릭 배열을 허용한다면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCastException이<br />
발생할 수 있는데, 이는 런타임에 이 예외가 발생하는 일을 막겠다는 제네릭 타입 시스템 취지에 벗어난다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;[]</span> <span class="n">stringLists</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;[</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// (1) </span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="n">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>              <span class="c1">// (2)</span>
<span class="n">Object</span><span class="o">[]</span> <span class="n">objects</span> <span class="o">=</span> <span class="n">stringLists</span><span class="o">;</span>                   <span class="c1">// (3)</span>
<span class="n">objects</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">intList</span><span class="o">;</span>                             <span class="c1">// (4)</span>
<span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">stringLists</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>                 <span class="c1">// (5)</span>
</code></pre></div></div>

<p>만약 (1)이 허용된다면 (2)는 원소가 하나인 <code class="highlighter-rouge">List&lt;Integer&gt;</code>를 생성한다. <br />
(3)은 (1)에서 생성한 <code class="highlighter-rouge">List&lt;String&gt;</code>의 배열을 <code class="highlighter-rouge">Object</code> 배열에 할당한다.<br />
배열은 공변이니 아무 문제가 없다.
(4) 번은 (2)에서 생성한 <code class="highlighter-rouge">List&lt;Integer&gt;</code>의 인스턴스를 <code class="highlighter-rouge">Object</code> 배열의 첫 원소로 저장한다. <br />
제네릭은 런타임 시점에서 타입 정보를 소거하니 <code class="highlighter-rouge">List&lt;Integer&gt;</code>은 <code class="highlighter-rouge">List</code>가 되고 <br />
<code class="highlighter-rouge">List&lt;Integer&gt;[]</code>는 <code class="highlighter-rouge">List[]</code>가 된다. <br />
따라서 (4)에서도 ArrayStoreException이 발생하지 않는다.<br />
(5)에서는 <code class="highlighter-rouge">List&lt;String&gt;</code> 인스턴스만 담겠다고 선언한 <code class="highlighter-rouge">stringLists</code> 배열에는 <br />
<code class="highlighter-rouge">List&lt;Integer&gt;</code> 인스턴스가 저장돼 있다.<br />
(5)는 이 배열의 처음 리스트에서 첫 원소를 꺼내려 하는데 컴파일러는 꺼낸 원소를 자동으로 String으로<br />
형변환 하는데, 이 원소는 <code class="highlighter-rouge">Integer</code>이니 런타임에 ClassCastExceptiondl qkftodgksek.</p>

<p>이를 막기 위해서 제네릭 배열 생성을 막도록 (1)에서 컴파일 오류를 내야 한다.</p>

<h2 id="실체화-불가-타입">실체화 불가 타입</h2>
<p><code class="highlighter-rouge">E</code>, <code class="highlighter-rouge">List&lt;E&gt;</code>, <code class="highlighter-rouge">List&lt;String&gt;</code> 같은 타입을 실체화 불가 타입이라 한다. <br />
제네릭은 타입 소거로 인해 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입을 뜻한다.<br />
(매개변수화 타입 가운데 실체화 될 수 있는 타입은 비한정적 와일드카드 타입 뿐이다.)</p>

<h2 id="정리">정리</h2>
<p>배열과 제네릭에는 매우 다른 타입 규칙이 적용되어서 둘을 섞어 쓰기란 쉽지 않다.<br />
배열은 공변, 제네릭은 불공변이다. <br />
이 말은 배열은 런타임 타입에 안전하지만 컴파일 타임에 안전하지 못하다.<br />
제네릭은 그 반대이다.</p>

<p>단순히 사이즈가 정적인지 동적인지의 차이 뿐만 아니라 배열과 리스트에는 이렇게 많은<br />
차이점이 존재하고 있었다.</p>

<p>만약 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 먼저 배열을 리스트로 대처하자!</p>

<h2 id="참고-자료">참고 자료</h2>
<ul>
  <li><a href="https://www.quora.com/What-is-the-difference-between-an-array-and-an-array-list#:~:targetText=First%20and%20Major%20difference%20between%20Array%20and%20ArrayList%20in%20Java,primitives%20and%20Objects%20in%20Java.">What is the difference between an array and an array list?
</a></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
