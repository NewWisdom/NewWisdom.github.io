<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>NewWisdom.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>I want to be a person who gives you new wisdom.</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>🕹 Level 1. 체스 미션 정리 - Service Layer, DAO와 Repository</title>
	  <link>//Level-1.-%EC%B2%B4%EC%8A%A4-%EB%AF%B8%EC%85%98-%EC%A0%95%EB%A6%AC-Service-Layer,-DAO%EC%99%80-Repository</link>
	  <author></author>
	  <pubDate>2021-04-10T19:18:00+09:00</pubDate>
	  <guid>//Level-1.-%EC%B2%B4%EC%8A%A4-%EB%AF%B8%EC%85%98-%EC%A0%95%EB%A6%AC-Service-Layer,-DAO%EC%99%80-Repository</guid>
	  <description><![CDATA[
	     <h2 id="mvc와-service">MVC와 Service</h2>

<p>이번 미션에서 DB를  적용하면서 MVC 패턴에 추가로 Service 레이어를 도입하였다.<br />
또한 DAO와 데이터 전달을 위한 DTO를 처음 사용했는데, DTO를 정리하고 DAO에 대해서도 새롭게 배운 부분이 많아 정리 ✍️</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114273538-6017c400-9a55-11eb-8ad4-3a62eb905948.png" alt="image" style="zoom:50%;" /></p>

<p>휴의 코멘트에 답변을 달다가 나의 코멘트 내용을 정정해주면서 같이 주신 참고자료가 있는데,<br />
<strong>서비스 계층과 비즈니스 로직</strong>이라는 개념이 다르다는 것을 제대로 인지하지 못하고 있었던 것 같다.</p>

<p>때문에 <a href="https://umbum.dev/1066">휴가 주신 MVC 패턴과 Service 레이어에 관한 글</a>을 읽고 간단히 정리해본다. <br />
<em>각 계층에 대한 개념은 조금씩 상이하니 일단 블로그 글은 서비스 계측과 비즈니스 로직에 대한</em>
<em>참고 정도만 한 수준에서 정리하고 다음 레벨에서 상세히 잡아가는 것이 좋겠다고 하셨다.</em></p>

<h3 id="layered-architecture">Layered Architecture</h3>

<p><img src="https://herbertograca.files.wordpress.com/2017/07/2010s-layered-architecture.png?w=640" alt="Layered Architecture – @hgraca" style="zoom: 67%;" /></p>

<p>일반적으로 사용하는 레이어를 구분한다면 위와 같이 나눌 수 있다.  MVC 패턴 또한 이 Layer를 잘 분리하기 위해 존재한다.</p>

<h4 id="layer-분리의-장점-">Layer 분리의 장점 ?</h4>

<ul>
  <li>각 계층이 애플리케이션 내에서 특정 역할만을 수행하게 나눔으로, 비즈니스 요청을 충족하기 위해 수행해야하는 작업에 대한 추상화를 이룬다.<br />
추상화가 잘 이루어진다면 서로 연결되어 있는 계층들이 독립적으로 계층에서 부품을 갈아끼우듯 변경할 수 있다.</li>
  <li>각 계층은 하위 계층에만 종속되고 상위 계층으로는 독립적으로 구성함으로, 위에서 아래로 떨어지는 간단한 구조로 만든다.<br />
이로써 각 Layer를 넘나들면서 꼬여있는 의존 관계를 만들지 않는다.</li>
</ul>

<h4 id="application-layer--service-layer">Application Layer (= Service Layer)</h4>

<p>도메인 모델을 묶어서 소프트웨어에서 사용 가능한 핵심 작업의 집합을 설정하는 계층이다.<br />
보통 도메인 모델 하나만으로는 소프트웨어에서 처리하고자 하는 복잡한 작업을 할 수 없다.<br />
때문에 여러 도메인 모델을 불러와 가공하고 비즈니스 로직을 호출해야하는데 이런 작업을 해주는 Layer가 필요하다.<br />
여기서 <strong>여러 비즈니스 로직들을 의미있는 수준으로 묶어서 추상화하는 것</strong>이 바로 Application Layer이다. <br />
만약 별도의 캡슐화가 필요하지 않은 경우에는 도메인 모델 그대로를 이 서비스로 만들 수 있다.</p>

<p><strong>❓ 추상화가 필요한 이유</strong> <br />
만약 UI, Gateway 같은 내부의 서비스 등 다양한 인터페이스로부터 작업을 요청 받는다면, <br />
각 인터페이스의 종류와 목적이 다르더라도 이를 통해 공통적으로 사용하는 작업이 있을 것이다.<br />
이 공통적인 작업이 각각에서 정의할 경우 중복이 발생하는데, 이를  Service Layer에서 인터페이스로 정의하여 중복을 제거한다.<br />
즉, <strong>핵심적인 API를 제공하는 계층</strong>이라고 할 수 있다.<br />
중요한 것은 Service Layer는 추상화 계층으로 두고, 핵심 로직은 Business Layer에 두는 것이 옳다.</p>

<h4 id="business-layer-domain-model">Business Layer (Domain Model)</h4>

<p>데이터와 이에 관련된 비즈니스 로직인 메서드를 가지고 있는 객체이다.<br />
Model 객체가 단순히 필드와 게터, 세터만을 가지고 있으면 DTO와 다를 것이 없다. (안티패턴)<br />
즉, 도메인 모델에서 해당 데이터에 대한 비즈니스 로직을 가지고 있어야 한다.</p>

<hr />

<h2 id="dao">DAO</h2>

<p>미션이 merge된 후, 미처 질문하지 못한 것이 있어 휴에게 DM으로 질문을 남겼다.<br />
현재 나의 로직에서는 chessGame 객체를 만들기 위해서 piece가 필요한데, 
chessgame 테이블과 piece 테이블 각각에서 쿼리를 날려 데이터를 받아오고<br />
이를 service에서 조합해(?) chessGame 객체를 만들고 있었다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114275347-32cf1400-9a5d-11eb-8961-2bca4de75df5.png" alt="image" /></p>

<p>하지만 사실 쿼리를 다음과 같이 join을 사용해서 chessGame 객체를 만들기 위한 데이터를 얻어올 수 있었다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">turn</span><span class="p">,</span> <span class="n">isFinish</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">position</span> <span class="k">FROM</span> <span class="n">chess_game</span> <span class="n">cg</span> <span class="k">inner</span> <span class="k">join</span> <span class="n">piece</span> <span class="n">p</span> <span class="k">WHERE</span> <span class="n">cg</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">chessGameId</span><span class="p">;</span>
</code></pre></div></div>

<p>사실 이렇게 join을 통해서 얻어오려 했지만, dao를 테이블 별로 만들었더니 이 쿼리를 어디서 수행해야할지 판단할 수 없었다. <br />
만약 chessGameDao에서 수행한다 하더라도 여기서piece 객체를 만드는 것도 아이러니하다고 생각도 들었다. <br />
때문에 이렇게 DB에서 받은 결과를 어디에서 조합해야하는가에 대한 질문을 남겼다.<br />
휴의 답변으로 Repository에 대한 것이 언급되었는데,<br />
사실 이 질문 전에도 크루들과 Repository가 도대체 무엇인가에 대해서 토론했었다.<br />
휴의 답변과 보내주신 참고 링크 덕분에 Repository가 어떤 역할을 하는 것인지 명확히 파악할 수 있었다.</p>

<blockquote>
  <p><a href="http://egloos.zum.com/aeternum/v/1160846">DAO와 REPOSITORY 논쟁</a></p>
</blockquote>

<h3 id="dao와-reposotory의-차이점">DAO와 Reposotory의 차이점</h3>

<h4 id="dao-1">DAO</h4>

<ul>
  <li>DAO 인터페이스는 DB의 CRUD 쿼리와 1:1 매칭되는 세밀한 단위의 오퍼레이션을 제공한다.</li>
  <li>테이블 별로 하나의 DAO를 만든다.</li>
  <li>RANSACTION SCRIPT 패턴과 함께 사용된다.</li>
  <li>Persistence Layer에 속한다.</li>
</ul>

<h4 id="repository">Repository</h4>

<ul>
  <li>Repository는 다수의 DAO를 호출하는 방식으로 구성된다.</li>
  <li>Repository에서 제공하는 한 오퍼레이션이 DAO의 여러 오퍼레이션에 맵핑되는 것이 일반적이다.</li>
  <li>DOMAIN MDOEL 패턴과 함께 사용된다.</li>
  <li>Domain Layer에 속한다.</li>
  <li>객체 컬렉션 처리에 관한 책임만을 가지고 있다. 외부 시스템과의 상호작용은 별도의 Service가 담당한다.</li>
</ul>

<p>따라서 현재 나의 질문 같은 경우는 <strong>Repository</strong>를 통해 ChessGameDao와 PieceDao로부터<br />
가져온 <strong>데이터에 대한 집합 처리</strong>를 함으로 해결할 수 있다. <br />
이 둘의 차이에 대해서는 지금 단계에서 이정도로 잡고 가자 !</p>


	  ]]></description>
	</item>

	<item>
	  <title>🕹 Level 1. 체스 미션 정리 - JDBC</title>
	  <link>//Level-1.-%EC%B2%B4%EC%8A%A4-%EB%AF%B8%EC%85%98-%EC%A0%95%EB%A6%AC-JDBC</link>
	  <author></author>
	  <pubDate>2021-04-10T19:18:00+09:00</pubDate>
	  <guid>//Level-1.-%EC%B2%B4%EC%8A%A4-%EB%AF%B8%EC%85%98-%EC%A0%95%EB%A6%AC-JDBC</guid>
	  <description><![CDATA[
	     <h2 id="jdbc-java-database-connectivity">JDBC (Java DataBase Connectivity)</h2>

<p><img src="https://images.velog.io/images/new_wisdom/post/b50e0a8b-eed6-46bd-912e-bd975a37d2de/image.png" alt="" /></p>

<p>JDBC는 DB에 접근할 수 있도록 Java에서 제공하는 API로, 모든 Java의 Data Access 기술의 근간이다.<br />
모든 Persistence Framework는 내부적으로 JDBC API를 이용한다.</p>

<h3 id="jdbc를-통한-db-연결">JDBC를 통한 DB 연결</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/1d634167-9324-4c86-abdb-023383bb3af8/image.png" alt="" /></p>

<h4 id="1-드라이버-로드">1. 드라이버 로드</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
  <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"com.mysql.cj.jdbc.Driver"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">" !! JDBC Driver load 오류: "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>제공되는 클래스를 인스턴스화해서 내부적으로 저장해 메모리에 드라이버를 사용할 수 있게한다.<br />
이 메소드를 통해 드라이버를 사용할 수 있도록 초기화 한다. <br />
생성자를 통한 인스턴스 생성과 같다고 볼 수 있다.</p>

<h4 id="2-connection-객체-생성">2. Connection 객체 생성</h4>

<p>DriverManager 클래스는 드라이버를 통해 Conection 객체를 만든다.<br />
Connection은 DB와 연결하는 객체로 DB와 연결하는 통로이며, 이를 통해 쿼리를 전달하고 결과값을 반환받는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
  <span class="n">con</span> <span class="o">=</span> <span class="n">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="s">"jdbc:mysql://"</span> <span class="o">+</span> <span class="n">server</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">database</span> <span class="o">+</span> <span class="n">option</span><span class="o">,</span> <span class="n">userName</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"정상적으로 연결되었습니다."</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"연결 오류:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-statement--preparedstatement-객체-생성">3. Statement / PreparedStatement 객체 생성</h4>

<p><strong>Statement</strong> 객체를 통해 insert 쿼리를 작성하면 아래와 같이 각각의 값을 콤마와 따옴표로 구별해야하기 때문에<br />
가독성도 떨어지고 잘못 입력할 확률도 커진다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">statement</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">createStatement</span><span class="o">();</span>
<span class="n">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"INSERT INTO piece(color, name, position, chessGameId) VALUE ('"</span> <span class="o">+</span> <span class="n">color</span> <span class="o">+</span> <span class="s">"','"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span>  <span class="s">"','"</span> <span class="o">+</span> <span class="n">position</span> <span class="o">+</span> <span class="s">"','"</span> <span class="o">+</span> <span class="n">chessGameId</span> <span class="s">"')"</span><span class="o">;</span>
<span class="n">resultCount</span> <span class="o">=</span> <span class="n">statement</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">(</span><span class="n">insertQuery</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>PreparedStatement</strong> 객체를 사용하면 다음과 같이 속성 값을 ?로 설정하고 set을 통해 설정하면, 자동으로 쿼리를 완성시켜준다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"INSERT INTO piece(color, name, position, chessGameId) VALUE (?, ?, ?, ?)"</span><span class="o">;</span>
<span class="k">try</span> <span class="o">(</span><span class="n">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">dbManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
     <span class="n">PreparedStatement</span> <span class="n">pstmt</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">query</span><span class="o">))</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">Piece</span> <span class="n">piece</span> <span class="o">:</span> <span class="n">pieces</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">piece</span><span class="o">.</span><span class="na">color</span><span class="o">().</span><span class="na">name</span><span class="o">());</span>
    <span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">piece</span><span class="o">.</span><span class="na">name</span><span class="o">());</span>
    <span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">piece</span><span class="o">.</span><span class="na">position</span><span class="o">().</span><span class="na">key</span><span class="o">());</span>
    <span class="n">pstmt</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">chessGameId</span><span class="o">);</span>
    <span class="n">pstmt</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">executeQuery()</code> : select를 통한 정보를 조회하고, 쿼리를 전송 후 결과 객체 반환한다.</li>
  <li><code class="highlighter-rouge">executeUpdate(String query)</code> : Insert, Update, Delete 쿼리를 전송하고 변경된 레코드 수를 반환한다.</li>
</ul>

<h4 id="4-resultset-객체-반환">4. ResultSet 객체 반환</h4>

<p>ResultSet 객체는 select 쿼리의 결과값을 모두 가지고 있는 객체이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">Piece</span> <span class="n">piece</span> <span class="o">=</span> <span class="n">PieceFactory</span><span class="o">.</span><span class="na">findByInfo</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"color"</span><span class="o">),</span>
                        <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"name"</span><span class="o">),</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"position"</span><span class="o">));</span>
                <span class="n">pieces</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">piece</span><span class="o">);</span>
            <span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">boolean next()</code> : 결과 레코드가 존재하면 true, 없으면 false</li>
  <li><code class="highlighter-rouge">boolean previous()</code> : 이전 레코드로 이동 (가장 첫 행이면 false)</li>
  <li><code class="highlighter-rouge">boolean first()</code> : 처음 위치로 이동 (레코드가 없으면 false)</li>
  <li><code class="highlighter-rouge">boolean last()</code> : 마지막 위치로 이동 (레코드가 없으면 false)</li>
  <li><code class="highlighter-rouge">String getString(String colLabel)</code> : 현재 커서 위치의 컬럼명에 해당하는 문자열 반환</li>
  <li><code class="highlighter-rouge">int getInt(String colLabel)</code> :  현재 커서 위치의 컬럼명에 해당하는 정수값 반환</li>
  <li><code class="highlighter-rouge">String getString(int colIndex)</code> : 컬럼 인덱스에 해당하는 문자열 반환 (1부터 시작)</li>
  <li><code class="highlighter-rouge">int getInt(int colIndex)</code> : 컬럼 인텍스에 해당하는 정수값 반환 (1부터 시작)</li>
</ul>

<h4 id="5-자원-해제">5. 자원 해제</h4>

<p>DB 관련 작업을 하면서 <strong>Connection, Statement / PreparedStatement, ResultSet</strong> 객체를 사용했다.<br />
DB 관련 처리 작업이 완료되었다면, 사용했던 객체들을 메모리에서 해제해주어야 한다.<br />
만약 해당 자원들을 해제해주지 않으면 다음과 같은 문제점이 발생할 수 있다.</p>

<ul>
  <li>Connection pool을 사용하지 않은 상태에서 Connection을 닫지 않으면 DBMS에 연결된 새로운 Connection을 생성할 수 없다.</li>
  <li>Statement / PreparedStatement를 해제하지 않으면, 생성된 갯수가 증가하면서 더 이상 새로운 Statement / PreparedStatement를 생성할 수 없다.</li>
</ul>

<p>이번 미션에서는 <strong>try-with-resource</strong>를 통해 자원 close 처리 개선을 하였다.
이는 try 블록의 소괄호 안에서 자원 해제가 필요한 객체를 할당하면 try catch 절이 종료되면서 <br />
자원 해제가 필요한 connection과 preparedstatement를 자동으로 close되는 try-catch 문이다.<br />
preparedstatement를 해제하면 현재(가장 최근에 생성한) ResultSet도 자동으로 해제된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Piece</span><span class="o">&gt;</span> <span class="nf">findAllByChessGameId</span><span class="o">(</span><span class="kt">int</span> <span class="n">chessGameId</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Piece</span><span class="o">&gt;</span> <span class="n">pieces</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="n">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"SELECT color, name, position FROM piece WHERE chessGameId = ?"</span><span class="o">;</span>
  <span class="k">try</span> <span class="o">(</span><span class="n">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">dbManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
       <span class="n">PreparedStatement</span> <span class="n">pstmt</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">query</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">pstmt</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">chessGameId</span><span class="o">);</span>
    <span class="n">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">pstmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">();</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">Piece</span> <span class="n">piece</span> <span class="o">=</span> <span class="n">PieceFactory</span><span class="o">.</span><span class="na">findByInfo</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"color"</span><span class="o">),</span>
                                            <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"name"</span><span class="o">),</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"position"</span><span class="o">));</span>
      <span class="n">pieces</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">piece</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">pieces</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="sql-exception에-대하여">SQL Exception에 대하여</h3>

<p><img src="https://user-images.githubusercontent.com/43840561/114271267-8173b280-9a4b-11eb-926a-88e6447a527d.png" alt="image" style="zoom:50%;" /></p>

<p>checked exception인 SQLException에 대해 어떻게 처리를 할지 고민하다가 결국 외부로 던져주기만 했었다.<br />
휴의 피드백대로 지금은 DAO에서 stacktrace만 출력하도록 변경하였다. <br />
추후에 휴가 SQLException에 대한 참고 자료를 보내주셨다.</p>

<p>[<a href="http://wonwoo.ml/index.php/post/878">Toby spring] 사라진 SQLException</a>에 따르면 DAO에서 발생하는 예외를 계속해서 외부로 던져주는 것도 하나의 방법이지만,<br />
이렇게 되면 예외가 발생한 DAO를 사용한 Service에서 왜 SQLException이 발생했는지 알 수 없기 때문에 <br />
아래와 같이 SQLException을 포장한 예외의 의미를 담은 커스텀 예외를 만들어 던져주는 것도 하나의 방법이 될 수 있다.  <br />
이렇게 되면 의미가 분명한 예외로 전달해서 처리할 수 있게 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
  <span class="c1">//...</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">throw</span> <span class="nf">DuplicatePieceIdException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>

<span class="k">try</span> <span class="o">{</span>
  <span class="c1">//...</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">throw</span> <span class="nf">DuplicatePieceIdException</span><span class="o">().</span><span class="na">initCause</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>또 자료에 따르면 JDBCTemplate을 사용하면 이 내부에서 SQLException을 처리해준다고 하니 차차 개념을 알아가자.</p>

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://codevang.tistory.com/205">JDBC를 이용한 DB작업_DB 연동 및 데이터 작업 2/3</a></li>
  <li><a href="https://javacan.tistory.com/entry/78">개발자의 실수를 줄여주는 java.sql.Connection 만들기</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>🕹 Level 1. 체스 미션 정리 - DTO</title>
	  <link>//Level-1.-%EC%B2%B4%EC%8A%A4-%EB%AF%B8%EC%85%98-%EC%A0%95%EB%A6%AC-DTO</link>
	  <author></author>
	  <pubDate>2021-04-09T19:18:00+09:00</pubDate>
	  <guid>//Level-1.-%EC%B2%B4%EC%8A%A4-%EB%AF%B8%EC%85%98-%EC%A0%95%EB%A6%AC-DTO</guid>
	  <description><![CDATA[
	     <p>이번 체스 미션에서는 웹 적용을 하면서 새롭게 배운 개념들이 너무 많았다.<br />
때문에 이번 미션을 진행하면서 새로 배운 개념들과, 휴가 주신 피드백을 정리하는 방안으로 기록해야겠다 ✍️</p>

<h2 id="step1에서의-dto">step1에서의 DTO</h2>

<p><img src="https://user-images.githubusercontent.com/43840561/114128924-72e8a680-9938-11eb-920c-449d58edf7a8.png" alt="image" style="zoom:50%;" /></p>

<p>사실 DTO의 개념은 대략 알고 있으나,<br />
전 미션까지는 DTO의 필요성을 잘 못느끼고 있어서 사용하지는 않았었다.<br />
이때 같은 경우는 현재 기물들을 나타내는 Pices 객체들만이 존재할 뿐인데 View에서는 64개의 position에 대한 정보를 출력하기 위해 <br />
Pieces의 메소드를 통해<code class="highlighter-rouge">pieces.findByPosition(CACHE.get(xy));</code> 로 도메인에 대한 의존성이 생기고 있었다.<br />
그래서 이를 제거하기 위해 휴의 리뷰대로 DTO를 만들어 View에 필요한 데이터들을 전달해주기로 하고<br />
이 방법에 대한 확신을 얻기 위해 휴에게 질문을 했었다.<br />
하지만 질답을 하다가 이번 단계에서 DTO를 사용하는 것 보다 다음 단계 웹 UI를 적용하면서<br />
DTO의 필요성을 뼈저리게 느끼기로 했다. <br />
사실 지금 시점에서 돌이켜보면 piecesDto를 만들면 해결될 일인것 같지만, 말씀대로 꼭 DTO가 필요했던 시점이 아니였던 것 같다.<br />
일단 휴와의 질답을 통해 얻은 DTO에 관한 이야기는 다음과 같다.</p>

<ul>
  <li>DTO는 데이터를 전송하기 위한 객체로서 로직이 없어야 한다.<br />
대신 model -&gt; modelDto로 변환하는 과정에서 필요한 작업을 모두 수행하여 View에 필요한 데이터를 세팅할 수 있다.</li>
  <li>DTO의 데이터를 사용할 때 로직을 수행하는게 아닌 생성 하는 시점에 미리 데이터를 다 세팅하고 DTO를 사용하는 시점엔 데이터로서만 사용한다. 
(이 부분이 dto 생성자에서 필요한 값 세팅을 마친다는 의미)</li>
  <li>값에 대한 표현을 어떻게 할지에 대한 ui 로직은 View에서 자체적으로 판단해도 된다.</li>
</ul>

<p>또한 DTO를 적용하기 전 DTO에 관해 알아보고 약간의 정리를 했다.</p>

<hr />

<h3 id="-dto-vs-vo-간단-정리">📝 DTO vs VO 간단 정리</h3>

<h4 id="dto-vo-혼동의-이유">DTO VO 혼동의 이유</h4>

<p>데이터 전달용 객체를 VO에서 TO로 변경되었기 때문에 혼동이 온다.</p>

<h4 id="dto--data-transfer-object">DTO = Data Transfer Object</h4>

<p>“계층 간” 데이터를 전달하기 위한 객체로, 데이터를 담아서 전달하는 바구니 역할을 한다.</p>

<ul>
  <li>용도 : 레이어 간 데이터 전달</li>
  <li>동등 결정 : 속성 값이 모두 같다고 해서 같은 객체는 아니다.</li>
  <li>가변 / 불변 : setter 존재 시 가변, setter 비 존재 시 불변</li>
  <li>로직 : getter / setter 외의 로직을 가지지 않는다.</li>
</ul>

<p>getter/setter 메서드만을 갖는다. <br />
보내는 쪽에서 setter를 사용해 값을 설정하고 getter를 사용해 값을 받는다.</p>

<p>setter 메소드를 가질 경우 데이터가 가변이기 때문에 필드를 final 로 하고 생성자를 통해 set을 하면 더 안정적이다.</p>

<h4 id="-entity">➕ Entity</h4>

<p>엔티티 클래스는 요청이나 응답 값을 전달하는 클래스가 아닌 데이터베이스와 매핑된 핵심 클래스다.<br />
이 엔티티 클래스를 기준으로 테이블이 생성된다. <br />
뷰와 엔티티가 직접 연결되어 있으면 엔티티에 변경이 일어날 때, 뷰의 모든 부분을 수정해주어야 한다.</p>

<h4 id="vo--value-object">VO = Value Object</h4>

<p>값 그 자체를 표현하는 객체로 불변이어야 한다.</p>

<p>값으로만 비교되는 객체로 equals / hashCode 오버라이딩이 핵심이다. <br />
생성자를 통해서만 값을 초기화해야 한다.</p>

<ul>
  <li>용도 : 값 자체 표현</li>
  <li>속성 값이 모두 같으면 같은 객체</li>
  <li>가변 / 불변 : 불변</li>
  <li>로직 : getter / setter 외의 로직을 가질 수 있다.</li>
</ul>

<hr />

<h2 id="step2에서의-dto">step2에서의 DTO</h2>

<h3 id="view에-데이터를-전달하는-목적">View에 데이터를 전달하는 목적</h3>

<p>4, 5단계를 진행하면서 웹 UI를 그리기 위해 Gson을 사용하였고, 이로 뷰에 보내줄 데이터를 Json으로 만들 수 있었다.<br />
<code class="highlighter-rouge">String chessGameListJson = gson.toJson(chessGameList);</code> <br />
이렇게 Gson 객체를 통해 string 형태의 json을 만들고 spark java에서 다음과 같이 res 객체의 body에 이 json을 담아 보낸다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span><span class="o">(</span><span class="s">"/chess-game-list"</span><span class="o">,</span> <span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">res</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">chessGameList</span> <span class="o">=</span> <span class="n">chessService</span><span class="o">.</span><span class="na">getAllChessGameId</span><span class="o">();</span>
  <span class="k">return</span> <span class="n">gson</span><span class="o">.</span><span class="na">toJson</span><span class="o">(</span><span class="n">chessGameList</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>

<p>➕ 잠깐 Gson에 대해 좀 더 언급하면, <br />
json의 키 값과 객체의 필드를 매칭 시키면 다음과 같이 req로 날아온 json 데이터를 객체로 쉽게 생성할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MoveRequestDto</span> <span class="n">moveRequestDto</span> <span class="o">=</span> <span class="n">gson</span><span class="o">.</span><span class="na">fromJson</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">body</span><span class="o">(),</span> <span class="n">MoveRequestDto</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>

<p>Gson을 통해서 객체를 json으로 변경할 때에 gson이 객체의 필드에 있는 값들을 자동으로 key-value의 json으로 만들어 준다.<br />
그런데, 객체 자체를 Gson을 통해 json으로 만들면<br />
View에서 원하는 데이터 양식을 맞출 수 없고, 또 View에서 원하지 않는 데이터도 함께 들어가게 된다.</p>

<p>그래서 이때 필요한 것이 바로 DTO 였다.<br />
View에 필요한 데이터를 원시값 필드로 가진 DTO를 만들고 View에게 데이터 전송을 위해 이를 사용하는 것이다.<br />
이 경험 덕분에 휴가 step1에서 언급했던 DTO의 찐 필요성을 느낄 수 있었다.</p>

<h3 id="dao에서-잘못된-dto-사용">DAO에서 잘못된 DTO 사용</h3>

<p>DTO에 대한 개념을 살펴보면서 <strong>계층 간 데이터를 전달하기 위한 객체</strong>라는 사실에 집중하여 <br />
맨 처음에는 DAO와 Service 레이어가 주고 받는 데이터에서도 DTO를 사용하였었다. <br />
이에 대해서는 다음과 같은 피드백을 받았다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114265815-dd2f4300-9a2d-11eb-919e-40acacb82a98.png" alt="image" style="zoom:50%;" /></p>

<p>dao로 데이터를 전달하기 위해 서비스에서 dto로 싸고, dao에서 dto로 반환하여 서비스 레이어에서 꺼내 쓰는 이 과정이,<br />
돌이켜보니 도메인에서 꺼내 쓸 수 있는 값들을 굳이 dto로 전달하면서 불필요한 dto 객체 생성과 코드만 늘어나고 있었다.<br />
뷰에서는 gson을 사용해 json으로 만들기 위해 dto의 필요성을 절실히 느낄 수 있었지만,
 dao에서 불필요한 dto들을 제거했더니 dto를 불필요하게 사용하고 있었구나를 느꼈다.</p>

<h3 id="데이터-전달-목적">데이터 전달 목적</h3>

<p><img src="https://user-images.githubusercontent.com/43840561/114266098-51b6b180-9a2f-11eb-89ca-721d3c9804cd.png" alt="image" style="zoom:50%;" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/114266117-7448ca80-9a2f-11eb-965d-dbc7e76d3681.png" alt="image" style="zoom:50%;" /></p>

<p>휴의 말대로 나의 구조에서, ChessGame 객체와 chess_game 테이블 간의 불일치는 명확히 존재했다.<br />
사실 DB 연동 경험이 있지만 이번 미션에서 DB를 연동하는데 왜이렇게 막막할까 많이 고민이 되었는데,<br />
객체를 테이블로 1:1 맵핑을 하려하다 보니 생긴 문제였다.<br />
(휴의 말대로 나중에는 ORM을 통해 해결이 되겠지..!) <br />
이번 단계에서는 객체와 테이블 간의 불일 치 문제를 DTO로 해결할 것을 제시해주셨고,<br />
ChessGame에 대해서는 DAO와 Service 간에 데이터 전달에서 DTO를 사용하여 저장할 데이터를 주고 받도록 하였다.</p>

<ul>
  <li><strong>ChessGameDao 일부</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">ChessGameStatusDto</span> <span class="nf">findChessGameStateById</span><span class="o">(</span><span class="kt">int</span> <span class="n">chessGameId</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"SELECT turn, IF(isFinish, 'true', 'false') isFinish FROM chess_game WHERE id = ?"</span><span class="o">;</span>
  <span class="k">try</span> <span class="o">(</span><span class="n">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">dbManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
       <span class="n">PreparedStatement</span> <span class="n">pstmt</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">query</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">pstmt</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">chessGameId</span><span class="o">);</span>
    <span class="n">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">pstmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">ChessGameStatusDto</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"turn"</span><span class="o">),</span> <span class="n">rs</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="s">"isFinish"</span><span class="o">));</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong>ChessService 일부</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">ChessGame</span> <span class="nf">findChessGameById</span><span class="o">(</span><span class="kt">int</span> <span class="n">chessGameId</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">ChessGameStatusDto</span> <span class="n">chessGameStatusDto</span> <span class="o">=</span> <span class="n">chessGameDao</span><span class="o">.</span><span class="na">findChessGameStateById</span><span class="o">(</span><span class="n">chessGameId</span><span class="o">);</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">Piece</span><span class="o">&gt;</span> <span class="n">pieces</span> <span class="o">=</span> <span class="n">pieceDao</span><span class="o">.</span><span class="na">findAllByChessGameId</span><span class="o">(</span><span class="n">chessGameId</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">ChessGameFactory</span><span class="o">.</span><span class="na">loadChessGameByInfo</span><span class="o">(</span><span class="n">pieces</span><span class="o">,</span> <span class="n">chessGameStatusDto</span><span class="o">.</span><span class="na">getTurn</span><span class="o">(),</span> <span class="n">chessGameStatusDto</span><span class="o">.</span><span class="na">isFinish</span><span class="o">());</span>
<span class="o">}</span>

</code></pre></div></div>

<p><em>이에 대한 휴의 피드백은 OK 였지만 DTO에 대해서 리뷰어마다 다른 관점을 가지고 있을 것이라 하였다.</em></p>

<hr />

<h2 id="dto에-대한-결론">DTO에 대한 결론</h2>

<p>DTO에 대해서 휴가 주신 참고 자료를 읽고, 이번 미션에서 경험한 DTO를 간략히 정리하고 마무리한다.</p>

<blockquote>
  <p><a href="https://www.slipp.net/questions/22">혹시 DTO(VO) 작성하시나요?</a></p>
</blockquote>

<p>객체를 자동으로 Json으로 변경할 경우 객체에 존재하는 모든 속성과 조합 관계에 있는 객체의 속성까지 Json으로 자동으로 변환된다.<br />
이 경우 View에서 불필요한 속성까지 Json으로 변환된다.<br />
이 문제를 해결하기 위해서 객체에서 View에서 필요한 속성만을 뽑아서 DTO로 만들어 계층 간 데이터를 전달한다.</p>

<p><em>하지만 도메인에서 특정 속성만을 뽑아 데이터를 전달하고 싶다면, 추후에 Lombok을 통해 필요한 속성만을 전달할 수 있다.</em></p>

	  ]]></description>
	</item>

	<item>
	  <title>📝 객체지향 설계 강의 노트</title>
	  <link>//%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-%EA%B0%95%EC%9D%98-%EB%85%B8%ED%8A%B8</link>
	  <author></author>
	  <pubDate>2021-03-23T19:18:00+09:00</pubDate>
	  <guid>//%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-%EA%B0%95%EC%9D%98-%EB%85%B8%ED%8A%B8</guid>
	  <description><![CDATA[
	     <p><img src="https://user-images.githubusercontent.com/43840561/114287351-1fde3300-9aa1-11eb-851c-61060904867d.png" alt="image" style="zoom: 67%;" /></p>

<p>랜덤넘버는 구현체이니까  Number로 받자</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287370-38e6e400-9aa1-11eb-94d8-e5f4a08b1f16.png" alt="image" style="zoom:67%;" /></p>

<p>이러면 모두가 움직이는데 ?</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287377-4bf9b400-9aa1-11eb-9bec-94738f02d078.png" alt="image" style="zoom:67%;" /></p>

<h3 id="의존성-주입-di">의존성 주입 DI</h3>

<p>스프링 프레임 워크는 DI를 구현하도록 강제되어 있다.<br />
의존성 주입을 위해서는 스프링을 써야한다는 말이 있는데 그렇지 않다.</p>

<p>스프링 프레임 워크를 쓰지 않은 채로 DI를 해본 적이 있습니까 ?</p>

<h4 id="생성자-의존성-주입">생성자 의존성 주입</h4>

<p>❓ randomNumbers를 객체의 변수로 두고있는데, move()의 인수로 넘겨받는 것은 어떨까요?<br />
-&gt; 상관 없음</p>

<p>move 메서드를 사용할 때마다 객체를 생성해야하니</p>

<p>인자가 많아졌을 떄는 생성자를 전달하는 것이 좋을 수도..</p>

<p>❓ 의존성 주입을 위한 setter는 괜찮나요 ?<br />
-&gt; 어떤 객체냐에 따라 다른데, 지금은 Cars의 상태 데이터를 가지고 있는 현제 예시에서는 
final로 선언해주는 것이 좋다.  setter 써도 상관은 없다.</p>

<p>Dependency Injection인데 객체가 다른 객체에 의존하는 것을 외부에서 주입하는 경우를 DI라고 하지 않을까여..?</p>

<p>setter를 사용하는 부분은 전략패턴이 좋은 예시가 되지않을까요?</p>

<p>저는 내부 로직을 객체로 추출할 수 있을때 추출한 후 주입받아 사용하는 식으로 변경할 때  ‘DI한다’ 하는거 같아요</p>

<p>객체지향적 설계는 기본적으로 객체간의 협력을 만들어내는 일이고, 이를 가능하게 하기 위해서는 객체간의 의존성이 필요해요.<br />
-&gt; 그럼 setter를 활용할 수 있지않을까용</p>

<p>의존성을 DI가 아닌 내부에서 만들어 줄 수도 있지만, 이렬 결우 강한 결합성을 가지기 때문에 변경에 자유롭지 않아 DI가 필요하다고 생각해요</p>

<h3 id="유지보수하기-좋은-코드">유지보수하기 좋은 코드</h3>

<p>작은 코드가 유지보수하기 쉽다.<br />
클래스가 작으면 메서드와 프러퍼티가 더 가까이 있을 수 있기 때문에 응집도가 높아진다.<br />
간단히 말해 각각 메서드가 모든 필드를 사용한다.</p>

<h3 id="불변-객체로-만드세요">불변 객체로 만드세요</h3>

<p>함수형 프로그래밍은 side eggect를 만들지 않는다.<br />
가변 객체는 말고 불변 객체를 만들어야 side effect가 생기지 않는다.<br />
불변 객체로 만들다보면 인스턴스가 많아져서 성능이 떨어진다 .</p>

<p>-&gt; 이는 캐싱 전략을 통해 해소하자</p>

<p>불변 객체로 만들다 성능 이슈가 생기면 가변 객체나 캐싱을 사용해라</p>

<p>모든 클래스를 불변으로 만들면 유지보수가 쉽다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287403-7fd4d980-9aa1-11eb-9ad9-fb92c32a2374.png" alt="image" style="zoom:67%;" /></p>

<p>현재 불변 객체가 아니다. <br />
Position이 final이 아니다. <br />
c메소드들이 car를 리턴하도록 변경한다  ?</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287412-8f542280-9aa1-11eb-9727-f9e93b5a60a3.png" alt="image" style="zoom:67%;" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287413-9418d680-9aa1-11eb-9567-4f945bf8cc3d.png" alt="image" style="zoom:67%;" /></p>

<p>요거는 가변 객체</p>

<p>사이드 이펙트가 밝생할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287422-a72ba680-9aa1-11eb-85b9-2b8b618d9288.png" alt="image" style="zoom:50%;" /></p>

<p>값을 바꾸면 계속 새로운 객체를 만들죠 ?</p>

<p>무슨 개소리야 할 수 있지만 분명히 다르다.  근데 계속 객체를 할당 받아야 하네</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287441-bca0d080-9aa1-11eb-8e21-85791e04d06c.png" alt="image" style="zoom: 67%;" /></p>

<p>상태가 바뀌면 계속 새로운 것을 반환해주어야 하니…</p>

<p>불변 객체는 list 내부의 상태 데이터를 추가하고 뺴는 것도 불변 객체 이다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287451-d510eb00-9aa1-11eb-97a0-e90cf46af43a.png" alt="image" style="zoom:67%;" /></p>

<p>이렇게 clear하는 것도 허용이다.</p>

<p>❓그렇다면, 메모리의 주솟값이 불변이면, 메모리의 주솟값이 참조하고 있는 값이 변경되도 불변이다 라고 보는 건가요?<br />
-&gt; 그렇다.</p>

<h4 id="불변-객체와-상수-객체의-차이에-대해-공부해-보세요">불변 객체와 상수 객체의 차이에 대해 공부해 보세요.</h4>

<h3 id="불변-객체로-구현하면-좋은-점">불변 객체로 구현하면 좋은 점</h3>

<ul>
  <li>식별자 가변성 문제가 없다.</li>
  <li>실패 원자성이 있다 - 완전하고 견고한 상태의 객체를 가지거나, 실패하거나 둘 중 하나만 가능하다.</li>
  <li>시간적 결합을 제거할 수 있다. - 가변 객체가 많은 경우 연산들의 순서를 일일이 기억해야한다.</li>
  <li>사이드 이펙트를 제거할 수 있다.</li>
  <li>null 참조를 없앨 수 있다.</li>
  <li>스레드 세이프하다.</li>
  <li>더 작고 더 단순한 객체를 구현할 수 있다.</li>
</ul>

<h3 id="public-상수를-사용하지-마세요-">public 상수를 사용하지 마세요.. ?</h3>

<p>상수라고 불리는 <code class="highlighter-rouge">public static final</code> 프로퍼티는 객체 사이의 데이터를 공유하기 위해 사용한다.<br />
사용하지 말라는 이유는 객체들은 어떤 것도 공유해서는 안되기 때문이다.<br />
독립적이어야 하며, 닫혀 있어야 한다.</p>

<p>하지만 일반적으로는 public 상수를 쓰는게 관례이다.</p>

<p><strong>상수를 쓸거면 객체로 만들어라??</strong><br />
OOP에서 퍼블릭 상수를 절대로 사용하지 말라고 한다.<br />
사소한 상수라도 항상 작은 클래스를 이용해 대체할 것을 추천한다. <br />
enum도 public static final을 쓰는 건데 쓰지 마라!</p>

<p><strong>그냥 설계가 완벽하다 싶을 때 도전해라 ^^</strong></p>

<p>인스턴스 변수는 4개 이하로… 근데. 
번외로 데코레이터 필드는 허용된다고 생각합니다.</p>

<p>position, name의 클래스 접근자를 없애는 것은 ??<br />
그러면 패키지 내부의 결합도를 낮출 수 있고, 인터페이스로 다 만들려면 너무 많아지는 문제점 해결</p>

<p>스프링 프레임 뭐크는 객체들의 의존성을 없앤다.</p>

<p>스프링 프레임워크를 위한 강의였따.</p>

	  ]]></description>
	</item>

	<item>
	  <title>💡 위클리 회고 7 주차</title>
	  <link>//%EC%9C%84%ED%81%B4%EB%A6%AC-%ED%9A%8C%EA%B3%A0-7-%EC%A3%BC%EC%B0%A8</link>
	  <author></author>
	  <pubDate>2021-03-21T19:18:00+09:00</pubDate>
	  <guid>//%EC%9C%84%ED%81%B4%EB%A6%AC-%ED%9A%8C%EA%B3%A0-7-%EC%A3%BC%EC%B0%A8</guid>
	  <description><![CDATA[
	     <h2 id="무슨일이-있었나">무슨일이 있었나?</h2>

<ul>
  <li>모각코를 계속 했다.</li>
  <li>내가 데일리 마스터로 윷놀이를 준비했다.</li>
  <li>스트림에 대한 강의를 들었다.</li>
  <li>레벨 1 마지막 미션인 체스 미션이 시작되었다.</li>
  <li>새로운 페어인 오즈를 첫날은 온라인으로, 이후는 오프라인으로 만나서 진행했다.</li>
  <li>이번 체스 미션 난이도는 극악이었다.</li>
  <li>미션 시작 금요일 새벽에 3단계까지 구현했다.</li>
  <li>이주동안 핸드폰을 거의 안봐 개인적으로 몇몇 중요한 연락을 놓쳤다.</li>
  <li>즐거운 하루들이었으나 스스로는 정신이 없었다.</li>
  <li>데일리에서 멤수타2를 했다.</li>
  <li>집 서류 문제로 7주차, 집주인에게 며칠동안 시달렸다. 꽤 스트레스였다.</li>
  <li>엘레강트 오브젝트 강의를 들었다.</li>
  <li>웹 미션이 주어졌다.</li>
  <li>교육장에서 다같이 재밌게 얘기하면서 미션을 진행했다.</li>
</ul>

<hr />

<h2 id="아쉬운-것은-무엇인가">아쉬운 것은 무엇인가?</h2>

<h3 id="미션에-대한-조급함">미션에 대한 조급함</h3>

<p>맨 처음 미션 때 완벽한 설계를 꿈꾸지 말고 일단 구현부터 시작해야한다는 교훈을 얻었기에,<br />
이번 미션도 그렇게 라이브하게 구현하려하였다.<br />
또 이번 미션은 어렵다 보니 구현을 생각해내는데 정말 어려웠는데, 기간 내에 끝낼 수 있을까하는 걱정때문에 스스로는 조금 조급했다.<br />
그러다 보니 여러 객체가 얽히고 섥히고 . . .  한 클래스가 엄청 장황해지며 무수한 인덴트가 나오는 불상사를 겪었다. <br />
교육장에서 늦게까지 남은 크루들이랑 이야기를 하다가 우리 코드는 웃음 거리가 되기도 했다 ㅎㅎ</p>

<p>미션을 끝낸 후, 페어와 회고를 하면서 이번 미션을 돌이켜 보았다.<br />
둘 다 구체적인 설계없이 구현을 하려다 보니 객체의 책임을 명확히 분리하지 못했다고 느꼈다.<br />
미션을 완료해놓고 주말에 각자 리팩토링을 진행하고 다시 이야기를 나누어봤는데,<br />
이미 메서드를 만들어놓고 쓰지 않은 부분도 수두룩 했다. <br />
설계를 해놓지 않고 구현에 들어간 문제라고 생각했다.<br />
근데 또 돌이켜 보면 이번 체스 미션은 너무 장황해서 구현이 없이는 어떻게 객체를 분리해야할지 감이 안왔을 것 같다.</p>

<p>그래서 얻은 교훈은 적당한 가벼운 설계와 구현 방향을 이야기 나눈 후 구현부터 들어가자!이다.</p>

<p>또 미션에 대한 조급함 때문에 스스로 구현이 급급했고,<br />
미션 도중에 구현에 대해 서로 어떻게 생각하는지 페어와 많은 이야기를 나누지 못했던 부분이 아쉽다.<br />
회고 하면서 내가 너무 조급해서 페어의 의견을 여러번 묻지 못했다고 스스로 생각했다고 말했다.<br />
페어는 그렇게 느끼지 못했다고는 하지만, 나는 이번 미션에서 나의 조급함 때문에 제대로 소통하지 못하는 나의 문제점을 발견했다.</p>

<h3 id="우선-순위-설정을-하지-못했다">우선 순위 설정을 하지 못했다</h3>

<p>8주차에는 정말 많은 과제들이 쏟아졌다.<br />
자스부터 SQL, 글쓰기, 리팩토링 등… 또 개인적인 할일들이 넘쳐났다.<br />
정신이 없어서, 그리고 내 주변 크루들은 지금 ‘이걸’하니까 나도 거기에 맞춰 내 할일들을 진행했다.<br />
그랬더니 리팩토링이 많이 늦어졌다.<br />
또한 리팩토링이 늦어져 PR이 늦어지니 조급함이 들기도 했다.<br />
이번주 나는 왜이렇게 조급했나를 돌이켜보니 우선순위를 설정하지 않고 손에 잡히는 일들을 먼저 끝내려 했다는 것이다.</p>

<h3 id="선택과-집중을-하지-못했다">선택과 집중을 하지 못했다.</h3>

<p>크루들이랑 농담 삼아 ‘선집(선택과 집중)’ 하자라는 말을 하는데,<br />
2주 동안 선택과 집중을 제대로 하지 못했다.<br />
글쓰기를 조금 하다가 자스르 조금 하다가, 리팩토링을 조금 하다가, 퀴즈를 풀다가… 
조급해서 여기 저기에 손을 댔던 것들이 나의 한 가지 일에 대한 집중을 떨어뜨렸고, 결국 비효율적인 시간 관리가 되었다.</p>

<h3 id="스스로를-돌아보지-못했다">스스로를 돌아보지 못했다</h3>

<p>바쁜 나날들을 살고, 또 계속해서 사람들을 만나면서 스스로 어떤 감정을 느끼고 있고 어떤 상태인지 돌아보지 못했다.<br />
주말에 예은 언니를 만나 이런 저런 이야기를 하고 여러 일을 겪으면서 아 내가 지금 꽤 지쳐있구나를 느꼈다.<br />
공부하기 급급하고 일정을 소화해야한다는 욕심 때문에 2주동안 나를 챙기지 못했다.<br />
나 정말 지쳐있구나를 느끼고 나서 혼자만의 시간을 가지고, 잠시 쉼을 가졌다.<br />
잠깐이었지만 이런 시간이 필요하구나를 느꼈다.</p>

<p>사실 전반적으로 아쉬운 부분이 많았던 2주였다.<br />
제일 큰 문제는 내게 주어진 일정들을 우선순위를 매기지 않고 일정관리를 하지 못함이라고 생각했다.<br />
이로 인해 부수적인 문제들이 생겼고.</p>

<hr />

<h2 id="잘한-것은-무엇인가">잘한 것은 무엇인가?</h2>

<h3 id="나의-문제점을-많이-발견했다">나의 문제점을 많이 발견했다</h3>

<p>사실 전반적으로 아쉬운 부분이 많았던 2주였다.<br />
제일 큰 문제는 내게 주어진 일정들을 우선순위를 매기지 않고 일정관리를 하지 못함이라고 생각했다.<br />
이로 인해 부수적인 문제들이 생겼고.<br />
그래도 이런 시행착오를 겪으면서 내가 앞으로 변해야할지 깨달을 수 있는 좋은 시간들이었다.<br />
회고하면서 여러가지 중요성을 깨달을 수 있다는 것은 큰 깨달음이다.</p>

<hr />

<h2 id="어떻게-달라질-것인가">어떻게 달라질 것인가</h2>

<h3 id="미션에-대한-조급함을-버리기">미션에 대한 조급함을 버리기</h3>

<p>미션의 목적은 완성이 아니라 성장임을 다시한번 되새겨야겠다.<br />
미션을 진행하면서 얻을 수 있는 성장을 제대로 누려보자.</p>

<h3 id="우선-순위-설정">우선 순위 설정</h3>
<p>내가 해야할 일 중 가장 중요한 일 순서대로 우선순위를 설정하고 차근 차근 해나가자.<br />
‘다른 사람들이 지금 이걸 하니까’가 아니라 내게 중요한 순서대로 해나가자.</p>

<h3 id="선택과-집중">선택과 집중</h3>

<p>우선 순위를 정한 후 그 일을 선택했다면 그 일에만 집중하자.</p>

<h3 id="자기관리">자기관리</h3>

<p>미션, 공부도 중요하지만 이 열정을 꾸준히 이어나갈 수 있는 것은 나를 계속해서 돌아보고<br />
지치지 않도록 관리하는 것이다. 체력이나 멘탈이나 뭐든.<br />
가끔은 쉬기도 하고 혼자만의 시간을 가지면서 힐링해야겠다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📝 엘레강트 오브젝트 뽀개기 1 강의 정리</title>
	  <link>//%EC%97%98%EB%A0%88%EA%B0%95%ED%8A%B8-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%BD%80%EA%B0%9C%EA%B8%B0-1-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</link>
	  <author></author>
	  <pubDate>2021-03-20T19:18:00+09:00</pubDate>
	  <guid>//%EC%97%98%EB%A0%88%EA%B0%95%ED%8A%B8-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%BD%80%EA%B0%9C%EA%B8%B0-1-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</guid>
	  <description><![CDATA[
	     <p>강의를 들으며 정리하기 ✍️</p>

<h2 id="엘레강트-오브젝트">엘레강트 오브젝트</h2>

<p><img src="https://user-images.githubusercontent.com/43840561/111856837-ca66a880-8970-11eb-903f-b93200975d2e.png" alt="image" style="zoom:50%;" /></p>

<ul>
  <li>
    <p>문자열과 원시값을 포장해라</p>
  </li>
  <li>
    <p>반환 값은 모두 일급 컬렉션</p>

    <p><img src="https://user-images.githubusercontent.com/43840561/111856864-fc780a80-8970-11eb-9ada-2c99c659bcfd.png" alt="image" style="zoom:50%;" /></p>
  </li>
</ul>

<h3 id="인자의-값으로-null을-절대-허용하지-마세요">인자의 값으로 null을 절대 허용하지 마세요</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="nf">find</span><span class="o">(</span><span class="n">String</span> <span class="n">mask</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mask</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// .</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
<span class="c1">// .</span>
<span class="o">}</span> <span class="o">}</span>
</code></pre></div></div>

<p>null을 체크하는 로직을 구현하는 것은 객체를 무시하는 것이다.<br />
mask 객체를 존중했다면 조건의 존재 여부를 객체 스스로 결정하게 했을 것이다.<br />
이를 위해 <strong>원시 값과 문자열을 포장</strong>하면 null을 허용하지 않을 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857492-216e7c80-8975-11eb-8c28-ef1e68a6c3ba.png" alt="image" /></p>

<p>이 부분이 randomNumber를 무시하는 것이 아닌가.<br />
randomNumber를 객체로 만든다. (원시값 포장).</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857526-77432480-8975-11eb-92c2-3abaeb7ccbd3.png" alt="image" style="zoom:50%;" /></p>

<p>객체에게 메시지를 보내도록 리팩토링한다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857586-e02a9c80-8975-11eb-84d0-74f7930af1bc.png" alt="image" style="zoom:50%;" /></p>

<p>테스트 가능하게 오버라이딩.</p>

<p>RandomNumber의 null 체크 안해줘도 되나 ? <br />
이 메서드가 외부에 쓰인다면 고민해봐야하지만, 내부에서만 move가 호출되면 
null 체크를 굳이 안해줘도 좋다. 
내가 컨트롤할 수 있는 범위라면 안해도 될 것 같다.<br />
<code class="highlighter-rouge">move()</code> 를 사용하는 범위가 어디까지인지에 따라 null 체크 여부가 달린 것 같다.</p>

<h3 id="final이거나-abstract-이거나">final이거나 abstract 이거나</h3>

<p>상속은 객체들의 관계를 복잡하게 만드니 최대한 자제하고,<br />
final이나 abstract로 만들어라</p>

<p>변수에 <code class="highlighter-rouge">final</code> 을 붙이면 재할당이 불가능하지만, 메서드에 붙이면 오버라이딩이 불가하다.<br />
클래스에 <code class="highlighter-rouge">final</code> 은 상속을 불가능하게 한다.</p>

<p>final 클래스가 테스트 가능하도록 하는 법.
인터페이스로 만든다.</p>

<p>RandomNumber 클래스를 final로 만들고 Number 인터페이스를 만든다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857934-5e883e00-8978-11eb-8472-ac523772cb3b.png" alt="image" style="zoom:67%;" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857943-7069e100-8978-11eb-8e53-dd4b5f7d6b2c.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/111858087-862bd600-8979-11eb-91b5-49a3004f38d8.png" alt="image" style="zoom:50%;" /></p>

<p>그러면 이렇게 Number 인터페이스와 의존 관계를 맺는다. <br />
인터페이스와 의존 관계를 맺는게 final 클래스와 의존 관계를 맺는 것 보다 테스트가 더 용이하다.</p>

<p>클래스에 final을 붙이는 것은 좋은 습관이다.<br />
final을 테스트하고 싶으면 인터페이스를 추출하면 된다.</p>

<p>인터페이스 구현체가 여러개가 되면 중복들이 많아지는데, 
이 중복을 어떻게 없애나 ?<br />
인터페이스 구현체 중간에 추상 클래스를 둔다.<br />
Car - 인터페이스 <br />
AbstractCar - 추상 클래스<br />
Sonatar - 클래스</p>

<p>이러면 추상 클래스의 필요성을 느낄 수 있을 것이다.</p>

<p>근데 default 메소드를 사용하면 안되나 ?</p>

<p>포비는 default 를 남용하지 않는다.  추상 클래스를 쓰는게 더 좋다.</p>

<p>중복을 제거할 때 추상 클래스의 인스턴스 변수, 즉 인스턴스에 종속된 메서드면 default 메서드를 만들기 어려울 수 있다.  default 메서드를 만들 수 있는 경우, 없는 경우가 있으니 잘 구별.<br />
추상 클래스는 상태를 가지니 상태를 활용할 수 있다.</p>

<p>상속 때 부모 클래스에 있는 인스턴스 변수를 private로 막아라 ! <br />
그래야 캡슐화가 잘 되었다고 한다. <br />
접근할 때는 메서드를 통해 접근해라</p>

<h3 id="-er로-끝나는-이름을-사용하지-마세요">-er로 끝나는 이름을 사용하지 마세요</h3>

<p>클래스 이름을 지을 때 좋은 가이드.</p>

<p>클래스는 객체를 만들어 내는 역할일 뿐이다 (객체의 Factory).<br />
클래스는 객체를 만들고, 추적하고, 적절한 시점에 파괴한다 (라이프 사이클 관리).</p>

<p>클래스를 객체의 템플릿으로 바라보는 것은 클래스를 수동적인 존재로 만드는 것이다.<br />
클래스는 객체의 능동적인 관리자이다.<br />
객체를 꺼내거나 반환하는 저장소이다.</p>

<h4 id="클래스-이름을-짓는-방식">클래스 이름을 짓는 방식</h4>

<p>클래스의 객체들이 <strong>무엇을 하는지</strong> 가 아닌, <strong>무엇인지</strong> 에 기반해 지어라.</p>

<ul>
  <li><strong>무엇을 하는지</strong>로 이름을 지은 잘못된 예</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CashFormatter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">CashFormatter</span><span class="o">(</span><span class="kt">int</span> <span class="n">dollars</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">format</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"$ %d"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">dollars</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>무엇인지를 기반으로 객체의 역량을 나타내도록 이름을 지어야 한다.</p>

<ul>
  <li><strong>무엇인지</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="kt">int</span> <span class="n">dollars</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">usd</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"$ %d"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">dollars</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>객체는 객체의 외부 세계와 내부 세계를 이어주는 연결장치가 아니고,<br />
내부에 캡슐화된 데이터를 다루기 위해 요청할 수 있는 절차의 집합도 아니다.<br />
객체는 <strong>캡슐화된 데이터의 대표자</strong>이다.</p>

<p>무엇인지로 객체를 추출하면 무엇을 하는지까지 포괄하는 것이 아닌가. <br />
무엇을 하는지는 수동적인 존재가 된다.</p>

<p>메서드에서는 protected를 사용할 수 있는데 변수에는 사용하지 않는 것이 좋다.<br />
DTO는 모르겠는데 도메인 객체에서는 무조건 인스턴스 변수는 private여야 한다.</p>

<p>“무엇인지” 생각하지 않고 “무엇을 하는지”를 먼저 생각하고 설계하지 말라</p>

<p>처음에 메세지를 정하고 객체의 협력을 구상해야하는데 이를 하기 위해는 “무엇을 하는지”가 아니라 객체가 “무엇인지” 부터 생각을 해야하는 것 같아요. 객체가 무엇인지 생각하고 책임을 부여하면서 “무엇을 하는지” 가 된다.</p>

<p>이미 er과 or을 가지고 있는 것들은 써도 되지만, 나머지는 자제하라</p>

<p>CashFormatter가 아닌 FomattedCash는 어때 ?<br />
CashFormatter는<code class="highlighter-rouge">format()</code> 이외의 기능을 가지면 부자연스럽기 때문이다.</p>

<h3 id="메서드-이름을-신중하게-선택하세요">메서드 이름을 신중하게 선택하세요</h3>

<p>메서드 명은 무조건 동사가 아니다.</p>

<h4 id="빌더builder의-이름은-명사로">빌더(builder)의 이름은 명사로</h4>

<p>반환타입이 void가 아닌 메서드로, 무언가를 만들어 새로운 객체를 반환한다.<br />
이 메서드의 명은 항상 <strong>명사</strong>여야 한다.<br />
형용사를 덧붙여 메서드의 의미를 좀 더 풍부하게 설명하는 명사로 나타낼 수도 있다.</p>

<p>Ex) float speed(), Employee employee(), String parsedCell()</p>

<h4 id="조정자manipulator의-이름은-동사로">조정자(manipulator)의 이름은 동사로</h4>

<p>반환타입이 void인 메서드로 엔티티를 수정하는 메서드이다.<br />
이 메서드 명은 항상 <strong>동사</strong>여야 한다.<br />
부사를 덧붙여 메서드의 문맥과 목적에 관한 풍부한 정보를 제송하는 동사로 나타낼 수 있다.</p>

<p>ex) void save(String content), void quicklyPrint(int id);</p>

<h4 id="잘못된-예시">잘못된 예시</h4>

<p>boolean put(String key, Float value);</p>

<p>이 메서드는 <code class="highlighter-rouge">PutOperation</code> 과 같은 클래스를 추가해 <code class="highlighter-rouge">save()</code> , <code class="highlighter-rouge">success()</code> 메서드로 분리한다.</p>

<h4 id="빌더와-조정자로-분리---빌더는-명사다">빌더와 조정자로 분리 - 빌더는 명사다</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Bakery</span> <span class="o">{</span>
    <span class="n">Food</span> <span class="nf">cookBrownie</span><span class="o">();</span>
    <span class="n">Drink</span> <span class="nf">brewCupOfCoffee</span><span class="o">(</span><span class="n">String</span> <span class="n">flavor</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">cookBrownie()</code> , <code class="highlighter-rouge">brewCupOfCoffee()</code> 는 실제로는 객체의 메서드가 아니고, 프로시저이다.<br />
객체는 자신의 의무를 수행하는 방법을 알고 있고, 존중해줘야하는 살아있는 유기체이다.<br />
단순한 명령에 따르지 않고, 계약에 기반해 일하고 싶어한다.</p>

<p>하지만 관념적인 부분은 포기해도 괜찮다 !</p>

<p>getXxx()는 내부적으로 xxx를 가지고 있을 것이라는 것을 드러내지만,<br />
명사를 사용하면 그 메서드 내부에 로직이 있는지를 숨길 수 있다.</p>

<h4 id="빌더와-조정자로-분리---조정자는-동사다">빌더와 조정자로 분리 - 조정자는 동사다</h4>

<p>ex) DJ에게 음악을 틀어달라고 요청할 때</p>

<ul>
  <li>방법 1. 음악을 틀어주세요.</li>
  <li>방법 2. 음악을 틀고, 현재 볼륨 상태를 말해주세요.</li>
</ul>

<p>이 중 방법 1가 더 객체를 존중하고 있다.<br />
그 객체가 알아서 하겠지 ! 를 생각해라. 객체를 믿어라.</p>

<p>print도 매개변수가 다르니 <code class="highlighter-rouge">print()</code> 로 통일할 수 있다.</p>

<h4 id="빌더와-조정자로-분리-3---빌더와-조정자-혼합하기">빌더와 조정자로 분리 3 - 빌더와 조정자 혼합하기</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Document</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">write</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">content</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>값을 반환하고 있는 write를 빌더와 조정자로 분리한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Document</span> <span class="o">{</span>
    <span class="n">OutputPipe</span> <span class="nf">output</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">OutputPipe</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">content</span><span class="o">);</span>
    <span class="kt">int</span> <span class="nf">bytes</span><span class="o">();</span>
    <span class="kt">long</span> <span class="nf">time</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="빌더와-조정자로-분리---boolean-값을-반환하는-경우-형용사로-지어라">빌더와 조정자로 분리 - Boolean 값을 반환하는 경우 형용사로 지어라</h4>

<p>빌더이지만, 가독성을 위해 형용사로 지어라.</p>

<h3 id="생성자-하나를-주-생성자로-만드세요">생성자 하나를 주 생성자로 만드세요</h3>

<p><strong>클래스는 2~3개의 메서드와 5~10개의 생성</strong>자를 포함해야한다.</p>

<p>생성자가 많고 메서드가 적을 수록 응집도가 높고 견고한 클래스가 된다.<br />
생성자가 많을 수록 클라이언트가 클래스를 더 편하게 사용할 수 있다.</p>

<ul>
  <li>주 생성자 : 프로퍼티를 초기화한다. 오직 주 생성자만 담당한다.</li>
  <li>부 생성자 : 주 생성자를 호출한다.</li>
</ul>

<p>인자수가 적은 수부터 많은 순으로, 주 생성자는 마지막에 둔다.</p>

<p>테스트를 위한 생성자는 좋다 ! 하지만 메서드 추가는 옳지 않다 !
생성자 여러개를 테스트 할 때 다른 타입 매개변수의 생성자 동등성을 테스트 하면 된다.</p>

<p><em>뷰에서 List 정도로 가공은 할 수 있을 것 같다.</em></p>

<p>좋은 객체는 모든 메서드가 각각 모든 인스턴스 변수를 사용하고 있다 (100%는 어렵다).</p>

<h3 id="문서를-작성하는-대신-테스트를-만들어라">문서를 작성하는 대신 테스트를 만들어라</h3>

<p>주석이 없어도 클래스명과 메서드만을 봐도 무슨일을 하는지 알 수 있게,<br />
테스트를 통해  메서드의 의도를 알도록 하라.</p>

<p>깔끔하게 만든다라는 것은 단위 테스트도 만든다는 의미이다.<br />
단위 테스트는 클래스의 일부이고 독립적인 개체가 아니다.</p>

<h3 id="생성자에-코드를-넣지-마세요">생성자에 코드를 넣지 마세요</h3>

<p>인자에 손을 대지 말라는 의미이다.</p>

<ul>
  <li>잘못된 예시</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">dlr</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>생성자에 코드가 있을 경우 객체 변환과 관련한 예외를 제어할 수 없다.</p>

<ul>
  <li>좋은 예시</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringAsInteger</span><span class="o">(</span><span class="n">dlr</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringAsInteger</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">source</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">StringAsInteger</span><span class="o">(</span><span class="n">String</span> <span class="n">txt</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">source</span> <span class="o">=</span> <span class="n">txt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">intValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">source</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>이렇게 리팩토링을 하면 실제로 객체를 사용하는 시점까지의 객체 변환 작업은 연기된다.<br />
생성자에 코드가 없을 경우 성능 최적화가 더 쉬워 실행 속도가 더 빨라진다.</p>

<p>진정한 객체지향에서 인스턴스화란 더 작은 객체들을 조합해서 더 큰 객체를 만드는 것이다.</p>

<p>객체의 변환을 뒤로 미뤄 파싱이 여러번 실행되지 않도록  데코레이터(decorator)를 추가해 파싱 결과를 캐싱할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CachedNumber</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">origin</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cached</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">);</span>
    <span class="kd">public</span> <span class="nf">CachedNumber</span><span class="o">(</span><span class="n">Number</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>
<span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">intValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">intValue</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CachedNumber</span><span class="o">(</span><span class="k">new</span> <span class="n">StringAsInteger</span><span class="o">(</span><span class="n">dlr</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>


	  ]]></description>
	</item>

	<item>
	  <title>📝 Java8 Lambda, Stream API 강의 정리</title>
	  <link>//Java8-Lambda,-Stream-API-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</link>
	  <author></author>
	  <pubDate>2021-03-16T19:18:00+09:00</pubDate>
	  <guid>//Java8-Lambda,-Stream-API-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</guid>
	  <description><![CDATA[
	     <h2 id="함수형-프로그래밍의-장점-">함수형 프로그래밍의 장점 ?</h2>

<h3 id="관심사의-분리">관심사의 분리</h3>

<p>관심사의 분리란 무엇일까? 예제를 들어보자.</p>

<p><code class="highlighter-rouge">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);</code> 리스트에 있는 <strong>원소마다 콜론을 추가</strong>하려 한다.</p>

<h4 id="이때-foreach-를-사용한다면-">이때 <code class="highlighter-rouge">forEach()</code> 를 사용한다면 ?</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">ForEach</span><span class="err">를</span><span class="n">_</span><span class="err">활용하여</span><span class="n">_</span><span class="err">콜론을</span><span class="n">_</span><span class="err">추가하는</span><span class="n">_</span><span class="err">문자열</span><span class="n">_</span><span class="err">작성</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">StringBuilder</span> <span class="n">stringBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="n">Integer</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">number</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">" : "</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">3</span><span class="o">,</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>나는 <strong>원소마다 콜론 추가하는 것</strong>을 원하는데, forEach문을 작성하니 이를 어떻게(How) 구현할지에 집중하고 있는 것 같다.</p>

<h4 id="그렇다면-함수형-프로그래밍의-일종인-stream을-사용한다면-">그렇다면 함수형 프로그래밍의 일종인 Stream을 사용한다면 ?</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="n">Stream</span><span class="err">을</span><span class="n">_</span><span class="err">활용하여</span><span class="n">_</span><span class="err">콜론을</span><span class="n">_</span><span class="err">추가하는</span><span class="n">_</span><span class="err">문자열</span><span class="n">_</span><span class="err">작성</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">valueOf</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">joining</span><span class="o">(</span><span class="n">COLON_DELIMITER</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>요소마다 콜론을 결합하는 것</strong>을 메소드를 사용함으로서 개발자인 내가 무엇을(What)을 수행할 것인지에 집중할 수 있다.</p>

<h3 id="side-effect가-발생하지-않는다">Side Effect가 발생하지 않는다.</h3>

<ul>
  <li>Side Effect란 ? 함수 내의 실행으로 인해 함수 외부가 영향을 받는 것</li>
</ul>

<p>함수형 프로그래밍의 특징은 지역 변수만을 변경할 수 있고, 매개변수를 변경하지 않는다. <br />
즉, 함수는 같은 인수값으로 함수를 호출했을 때 항상 같은 값을 반환한다. (이 때 다른 값을 반환하는 Random, Scanner 등은 함수가 아니다).<br />
만약 함수에 참조하는 객체가 있다면 그 객체는 불변이어야 하며, 해당 객체의 모든 참조 필드도 불변 객체를 직접 참조해야 한다. <br />
함수 내에서 생성한 객체의 필드는 갱신할 수 있지만, 새로 생성한 필드의 갱신은 외부에 노출되면 안된다. <br />
또한 다음에 메서드를 다시 호출한 결과에 영향을 미치지 않으며, 어떠한 예외도 일으키지 않아야 한다. <br />
값이 변경되는 것을 허용한 객체를 멀티 스레드 프로그램에서 접근한다면, 값이 일정하지 않을 것이다.</p>

<p>하지만 단순히 구조만으로 순수성이 보장되지는 않고, 입력에 참조값이 오는 경우는 Side-Effect가 생긴다. 
이에 대한 내용은 <strong>참조 투명성</strong>을 살펴보자.</p>

<h4 id="참조-투명성">참조 투명성</h4>

<p>참조 투명성은 함수가 함수 외부의 영향을 받지 않는 것을 의미한다.<br />
또, 함수의 결과는 입력 파라미터에만 의존하고, 함수 외부 세계(입력 콘솔, 파일, 데이터 베이스 등)에서 데이터를 읽지 않는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">a</span><span class="o">++;</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 예제의 경우 원시 타입인 a의 값을 바꾸었는데, 자바의 원시타입의 매개변수는 call by value (메서드 호출 시 기본 자료형의 값을 인자로 전달하는 방식) 형태로 전달이 되어, 함수를 벗어나도 a에는 영향이 없다.<br />
여기서 인자로 참조 변수를 넣어주면 어떤 일이 발생할 수 있을까?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">position</span><span class="o">(</span><span class="n">Position</span> <span class="n">a</span><span class="o">,</span> <span class="n">Position</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">a</span><span class="o">.</span><span class="na">setX</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">getX</span><span class="o">())</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 참조 변수를 넘겨주면 함수 안에서 참조 변수의 값을 바꿀 수도 있기 때문에 side effect가 발생할 수 있다.<br />
함수형 프로그래밍은 이런 Side Effect가 발생하지 않는, 참조 투명성이어야 한다.</p>

<h3 id="일급-객체">일급 객체</h3>

<p>함수형 프로그래밍은 함수인 메서드가 일급 객체임을 말하는데, 일급 객체는 다음과 같은 특성을 가진다.</p>

<ul>
  <li>변수나 데이터에 할당할 수 있어야 한다.</li>
  <li>객체의 매개변수로 넘길 수 있어야 한다.</li>
  <li>객체의 반환 값으로 리턴할 수 있어야 한다.</li>
</ul>

<p>자바8 이전까지, 메서드는 일급 객체가 아니었지만, 자바8의 익명 함수의 등장으로 메서드도 일급 객체로 다룰 수 있게 되었다.<br />
또 이 익명 함수를 좀 더 단순화 한 것이 바로 람다 표현식(lambda expression)이다.</p>

<h3 id="boxing과-unboxing">Boxing과 UnBoxing</h3>

<p>원시 타입이 래퍼 클래스로 변환하는 것을 Boxing이라고 하며,<br />
래퍼 클래스를 원시 타입으로 형변환 하는 것을 UnBoxing이라고 한다. <br />
JDK1.5부터는 래퍼 클래스와 기본 자료형 사이의 변환을 자동으로 해주는 Auto Boxing과 Auto UnBoxing 기능을 지원한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">Integer</span> <span class="n">integer</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// Auto Boxing</span>
<span class="n">Integer</span> <span class="n">integer1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">777</span><span class="o">);</span> <span class="c1">// 명시적 Boxing</span>

<span class="kt">int</span> <span class="n">primitive</span> <span class="o">=</span> <span class="n">integer</span><span class="o">;</span> <span class="c1">// Auto UnBoxing</span>
</code></pre></div></div>

<p>#### Auto Boxing이 일어나는 예</p>

<p>자바에서는 래퍼 클래스에 대한 연산이 시도될 때, 연산을 하려는 두 객체를 Auto Unboxing을 하여 원시타입으로 변환 후,<br />
연산을 수행하게 된다. 래퍼 클래스와 원시 타입 간 연산도 동일하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="n">Integer</span> <span class="n">integer127</span> <span class="o">=</span> <span class="mi">127</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
  <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">127</span><span class="o">)</span>
  <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">integer127</span><span class="o">)</span>
  <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
<span class="o">);</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
  <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">128</span><span class="o">)</span>
  <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">integer127</span><span class="o">))</span>
  <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
<span class="o">);</span>
</code></pre></div></div>

<p>두 스트림 연산에서 원시 타입 <code class="highlighter-rouge">int</code> 인 값들의 Stream을 만들고 각각 래퍼 클래스 <code class="highlighter-rouge">Integer</code> 와 비교를 할 때 Auto Boxing이 일어난다.<br />
이때, <code class="highlighter-rouge">findFirst().get()</code> 을 하게 된다면 래퍼 클래스가 반환된다.<br />
이렇게 되면 각각 원시 타입에 Auto Boxing이 일어나니, <br />
원시 타입에 대한 스트림은 기본형 특화 스트림 (IntStream, LongStream, DoubleStream)을 사용하는 것이 성능상 좋다.</p>

<p>➕ 수업 예제에서 이 부분이 왜 127과 128로 나누었을까 크루들이랑 이야기를 했다.<br />
Integer 래퍼 클래스는 127까지 인스턴스를 미리 생성해 두기 때문에 <code class="highlighter-rouge">==</code> 연산자로도 비교가 가능하지만 (주소값을 비교하는 것이다),<br />
128부터는 새로운 인스턴스를 반환하기 때문에 동일성 검사인 <code class="highlighter-rouge">equals()</code> 를 사용해 반환한다.</p>

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://jinwooe.wordpress.com/2017/12/21/%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC-side-effect-%EC%B0%B8%EC%A1%B0-%ED%88%AC%EB%AA%85%EC%84%B1-referential-transparency/">부수 효과 (Side Effect), 참조 투명성 (Referential Transparency)</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>🕹 Level 1. 블랙잭 미션 코드 리뷰 정리</title>
	  <link>//Level-1.-%EB%B8%94%EB%9E%99%EC%9E%AD-%EB%AF%B8%EC%85%98-%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0-%EC%A0%95%EB%A6%AC</link>
	  <author></author>
	  <pubDate>2021-03-15T19:18:00+09:00</pubDate>
	  <guid>//Level-1.-%EB%B8%94%EB%9E%99%EC%9E%AD-%EB%AF%B8%EC%85%98-%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0-%EC%A0%95%EB%A6%AC</guid>
	  <description><![CDATA[
	     <h2 id="-코드-리뷰-정리">💾 코드 리뷰 정리</h2>

<h3 id="controller에-있는-도메인-로직">Controller에 있는 도메인 로직</h3>
<p><img src="https://images.velog.io/images/new_wisdom/post/56c51213-0e01-48f5-ac72-8e76e77f73f1/image.png" style="zoom:50%;" /></p>

<p>게임 진행을 위해 Controller에 많은 역할을 구현했었다.<br />
위 피드백을 받고 BlackjackGame이라는 객체를 만들어 게임의 진행을 하도록 구현했다.<br />
각각의 플레이어들의 게임을 진행에 Input과 Output이 연결되어 있어서</p>

<p>처음 리팩토링에서는 BlackjackGame에서 플레이어들을 꺼내오고, 플레이어 하나 하나마다 게임을 진행하게 되었다.</p>

<p><strong>BlackjackController 일부</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">askWantToHit</span><span class="o">(</span><span class="n">Player</span> <span class="n">player</span><span class="o">,</span> <span class="n">BlackjackGame</span> <span class="n">blackjackGame</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">isAbleToAskHit</span><span class="o">(</span><span class="n">player</span><span class="o">,</span> <span class="n">blackjackGame</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">Answer</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">InputView</span><span class="o">.</span><span class="na">inputDrawAnswer</span><span class="o">()).</span><span class="na">isYes</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">blackjackGame</span><span class="o">.</span><span class="na">hit</span><span class="o">(</span><span class="n">player</span><span class="o">);</span>
        <span class="n">OutputView</span><span class="o">.</span><span class="na">printPlayerCards</span><span class="o">(</span><span class="n">player</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isAbleToAskHit</span><span class="o">(</span><span class="n">Player</span> <span class="n">player</span><span class="o">,</span> <span class="n">BlackjackGame</span> <span class="n">blackjackGame</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">blackjackGame</span><span class="o">.</span><span class="na">isNotGameOver</span><span class="o">(</span><span class="n">player</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">OutputView</span><span class="o">.</span><span class="na">printAskOneMoreCard</span><span class="o">(</span><span class="n">player</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://images.velog.io/images/new_wisdom/post/ed3abe31-8b66-4a6d-8a51-5f87404c2b83/image.png" style="zoom:50%;" /></p>

<p>하지만 결국 BlackjackGame에서 플레이어를 <code class="highlighter-rouge">get</code>해와 값을 조회하고,<br />
해당 값에 대한 로직이 Controller에서 처리되고 있었다.</p>

<p>게이츠의 말씀대로 도메인에 있어야 할 로직이 외부인 
Controller에서 처리되고 있는 것이다.
페어인 다니도 비슷한 리뷰를 받았는데, BlackjackGame 객체를 통해 게임 진행 과정을 캡슐화하라 하셨고,
이에 대해서는 <strong>출력을 제외하고 getter가 사용되는 부분이 하나도 남아있지 않아야 
캡슐화가 잘 진행되었다고 볼 수 있다</strong>고 하였다.</p>

<p>위 피드백들로 <strong>게임을 진행하는 역할</strong>을 완전히 BlackjackGame으로 옮기기 위해 
현재 게임이 끝나지 않은 플레이어들을 BlackjackGame에서 관리하도록 하고
(<code class="highlighter-rouge">getCurrentPlayer()</code>), BlackjackGame에서도 Players에게 현재 게임을 
진행해야 하는 Player를 얻어오도록 구현했다.</p>

<p>내가 적용한 부분은 다음과 같다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/88b9a4cc-0474-44a4-97b1-4832858046c9/image.png" style="zoom:50%;" /></p>

<hr />

<h3 id="테스트-코드의-가독성">테스트 코드의 가독성</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/a30b0ff5-2286-4a1e-819c-8073d35f97f0/image.png" style="zoom:50%;" /></p>

<p>리뷰어님께서 테스트 코드의 가독성을 위해 given, when, then으로 
줄바꿈 할 것을 권해주셨는데, 찾아보니 테스트 코드를 작성할 때 주로 사용하는
<a href="https://brunch.co.kr/@springboot/292">Given-When-Then Pattern</a>을 발견하였다.</p>
<ul>
  <li>
    <p>Given<br />
테스트를 위해 준비를 하는 과정
테스트에 사용하는 변수, 입력 값 등을 정의하거나, Mock 객체를 정의하는 구문 포함</p>
  </li>
  <li>
    <p>When<br />
실제로 액션을 하는 테스트를 실행하는 과정</p>
  </li>
  <li>
    <p>Then <br />
마지막은 테스트를 검증하는 과정
예상한 값, 실제 실행을 통해서 나온 값을 검증</p>
  </li>
</ul>

<p>사실 지금껏 테스트 코드를 짜는 것에만 집중을 하고 가독성은 고려하지 못했던 것 같다.
올바르게 적용한 것인지 확신은 없으나, 
앞으로 테스트 코드를 작성할 때 위 패턴을 지키려 노력해야겠다.</p>

<hr />

<h3 id="추상-메서드로-공통-기능을-선언하고-각각-구현하기">추상 메서드로 공통 기능을 선언하고 각각 구현하기</h3>

<p><img src="https://user-images.githubusercontent.com/43840561/111168509-79a82600-85e5-11eb-8143-e030459f1915.png" alt="image" style="zoom:50%;" /></p>

<p>기능 요구사항에서 초기 카드를 보여주는 로직이 딜러와 플레이어마다 달랐다. 딜러는 처음에 한장만 보여주고, 플레이어는 두장을 보여주어야 한다. 이를 처음 구현했을 때는 User 추상 클래스에 <code class="highlighter-rouge">public final Cards getCards()</code> 를 두고 플레이어는 초기에 이 메서드를 통해 카드를 2장인 Cards를 (사실은 전부) 반환하고, 딜러는 딜러만의 <code class="highlighter-rouge">Card showOneCard()</code> 를 통해 Card 객체를 반환한다. 반환 타입도 달라서 딜러와 플레이어들의 카드를 출력하기 위해서는 매개변수가 다른 출력 메서드들도 필요했다. 때문에 BlackjackGame 객체에서도 출력만을 위한 비슷한 <code class="highlighter-rouge">get()</code> 들이 생겨났다. 게이츠의 말씀대로 이렇게 추상 클래스인 User에 <code class="highlighter-rouge">Cards showInitialCard();</code>를 만들고 딜러와 플레이어 각각이
<code class="highlighter-rouge">getCardsByCount(int count)</code>에 각자 맞는 개수로 카드를 가져올 수 있도록 리팩토링 해보았다.</p>

<hr />

<h3 id="캐시-적용">캐시 적용</h3>

<p><img src="https://user-images.githubusercontent.com/43840561/111397796-7e63fb80-8705-11eb-9427-2ae8125ae479.png" alt="image" style="zoom:50%;" /></p>

<p>처음 로직 구현 때는 Deck 객체 자체를 static으로 만들어서 캐싱하는 방법으로 구현하였다.<br />
하지만 static은 메모리 주소를 하나만 가지기 때문에, 해당 게임을 여러 스레드에서 진행한다면 카드 배분에 문제가 생길 것이다.<br />
때문에 Deck을 그냥 인스턴스로 생성하게 하였는데, Deck에 들어갈 카드를 캐싱하는 부분을 생각하지 못했었다.<br />
처음에는 LottoNumber 때를 생각하고 of로 객체 하나하나를 반환해주어야 하나 고민을 했는데, 그냥 <code class="highlighter-rouge">List&lt;Card&gt;</code> 를 미리 생성하면 되었다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111396928-6e4b1c80-8703-11eb-819b-388d0ac6be20.png" alt="image" style="zoom:50%;" /></p>

<hr />

<h3 id="ui와-관련된-로직">UI와 관련된 로직</h3>

<p><img src="https://user-images.githubusercontent.com/43840561/111469846-85712500-876a-11eb-988b-b8933870fd5b.png" alt="image" style="zoom:50%;" /></p>

<p>BlackjackGame 객체에서 카드를 더 받기 원하는지에 대한 대답을 받아야 했는데, 스스로는 BlackjackGame 객체가 게임 진행을 담당하고 있으니, yes / no 에 대한 정보는 yes인지 no인지에 따라 게임 진행 여부가 다르니, 게임 객체가 알아야 한다고 생각했다. 이에 대해 내 생각을 전달하고 의견을 물어보았는데, “BlackjackGame 객체가 블랙잭 게임 역할을 담당하고 있으니 yes no에 대한 정보를 가지고 있어도 괜찮지만 yes, no에 대한 정보는 UI 요구사항이라 추후에 예, 아니오로 변경됏을 때 도메인 객체까지 영향 범위가 갈 것 같다”라고 말씀하셨다. <strong>View의 요구사항이 변경되었을 때 도메인 객체까지 영향이 갈 것 같다</strong>는 부분은 생각하지 못했던 것 같다. 이 피드백에서 많은 인사이트를 얻었는데, 체스 게임 미션에서 사용자의 대답을 입력 받는 부분에 있어서 대답에 대한 검증을 어디에서 취해줄까를 계속 토론하다 게임 객체에서 해주었었는데, 이 답변을 받고 도메인 밖으로 대답 검증을 뺄 수 있었다.</p>

<h2 id="-미션-정리">💾 미션 정리</h2>

<h3 id="상태-패턴-적용기">상태 패턴 적용기</h3>
<p>0309 강의에서 이번 미션에 상태 패턴을 적용하여 구현하는 법에 대해 배웠다.
이번 미션을 진행하면서 스스로 제일 이슈라고 생각했던 부분은 
<strong>딜러와 플레이어의 점수만을 가지고 결과를 계산하는 것이 아니라,
딜러와 플레이어의 상태별로 결과를 계산하는 분기처리였다.</strong></p>

<p>이 부분에 대한 처리를 이번 미션동안 많이 고민해보았었고,
나의 삽질의 과정들을 함께 기록해보려 한다.</p>

<h4 id="1-if-문을-통한-처리">1. if 문을 통한 처리</h4>
<p>맨 처음 미션을 제출할 때는 각각의 상태에 따른 결과 산출을 if문을 통해서 처리해주었다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 변수로 다음과 같이 compareValue를 가지고 있음
* private final String result;
* private final int compareValue;
*/</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="n">Result</span> <span class="nf">decide</span><span class="o">(</span><span class="n">Dealer</span> <span class="n">dealer</span><span class="o">,</span> <span class="n">Player</span> <span class="n">player</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dealer</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">player</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">WIN</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dealer</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">player</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">STAND_OFF</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">dealer</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">player</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">LOSE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
	    <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">value</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">.</span><span class="na">compareValue</span> <span class="o">==</span> <span class="n">player</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">dealer</span><span class="o">.</span><span class="na">cards</span><span class="o">))</span>          
            <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
            <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(</span><span class="nl">IllegalArgumentException:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>하지만 이렇게 구한 결과에 스스로 다음과 같은 문제점을 느꼈다.</strong></p>
<ul>
  <li>딜러와 플레이어의 상태를 비교하는 동일한 행위를 if문으로 반복해서 처리하여 길어진 <code class="highlighter-rouge">decide()</code></li>
  <li>해당 타입을 구하기 위한 책임이 분리되어 있음 (데이터와 로직 분리되어 있음)</li>
  <li>compareValue인 <code class="highlighter-rouge">1, 0, -1</code> 값이 Result의 의미를 명확히 드러내지 못함</li>
  <li>만약 실수로 <code class="highlighter-rouge">decide()</code>의 if문 한줄을 지웠다면 프로그램 오류</li>
</ul>

<p>때문에 if문으로 처리했던 상태들을 어떻게 줄일 수 있을까 많은 고민을 했다.</p>

<h4 id="2-함수형-인터페이스를-통한-처리">2. 함수형 인터페이스를 통한 처리</h4>
<blockquote>
  <p><a href="https://jojoldu.tistory.com/137">Enum 활용사례 3가지</a>
<a href="https://dev3m.tistory.com/entry/ENUM-Funcational-Interface%EB%A1%9C-if%EB%AC%B8-%EC%A4%84%EC%9D%B4%EA%B8%B0">ENUM + Funcational Interface 활용하기</a></p>
</blockquote>

<p>해결책을 찾아보다, 위 글들을 참고하여 딜러와 플레이어의 상태마다 다른 처리를 
함수형 인터페이스를 사용해 구현해보았다.</p>

<p>이에 스스로 <a href="https://velog.io/@new_wisdom/Java-Functional-Interface-%EB%B6%80%EC%88%98%EA%B8%B0">함수형 인터페이스를 학습하며 정리하고</a> 
Dealer에 대한 Player의 결과를 구하는 로직을 <code class="highlighter-rouge">BiPredicate&lt;T&gt;</code>로 처리했다.
함수형 인터페이스를 사용하여 딜러, 플레이어의 상태별 / 점수별 결과 산출 코드는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Result</span> <span class="o">{</span>
    <span class="n">WIN</span><span class="o">(</span><span class="s">"승"</span><span class="o">,</span> <span class="o">(</span><span class="n">playerNotBust</span><span class="o">,</span> <span class="n">dealerNotBust</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">playerNotBust</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dealerNotBust</span><span class="o">,</span>
            <span class="o">(</span><span class="n">playerScore</span><span class="o">,</span> <span class="n">dealerScore</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">playerScore</span> <span class="o">&gt;</span> <span class="n">dealerScore</span><span class="o">),</span>
    <span class="n">STAND_OFF</span><span class="o">(</span><span class="s">"무"</span><span class="o">,</span> <span class="o">(</span><span class="n">playerNotBust</span><span class="o">,</span> <span class="n">dealerNotBust</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">playerNotBust</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dealerNotBust</span><span class="o">,</span>
            <span class="nl">Integer:</span><span class="o">:</span><span class="n">equals</span><span class="o">),</span>
    <span class="n">LOSE</span><span class="o">(</span><span class="s">"패"</span><span class="o">,</span> <span class="o">(</span><span class="n">playerNotBust</span><span class="o">,</span> <span class="n">dealerNotBust</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">playerNotBust</span> <span class="o">&amp;&amp;</span> <span class="n">dealerNotBust</span><span class="o">,</span>
            <span class="o">(</span><span class="n">playerScore</span><span class="o">,</span> <span class="n">dealerScore</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">playerScore</span> <span class="o">&lt;</span> <span class="n">dealerScore</span><span class="o">);</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">result</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">BiPredicate</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">statusPredicate</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">BiPredicate</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">scorePredicate</span><span class="o">;</span>

<span class="c1">// ... </span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Result</span> <span class="nf">decide</span><span class="o">(</span><span class="n">User</span> <span class="n">player</span><span class="o">,</span> <span class="n">User</span> <span class="n">dealer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">value</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">.</span><span class="na">statusPredicate</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">player</span><span class="o">.</span><span class="na">isAbleToHit</span><span class="o">(),</span> <span class="n">dealer</span><span class="o">.</span><span class="na">isAbleToHit</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
                <span class="o">.</span><span class="na">orElseGet</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">decideByScore</span><span class="o">(</span><span class="n">player</span><span class="o">.</span><span class="na">score</span><span class="o">(),</span> <span class="n">dealer</span><span class="o">.</span><span class="na">score</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Result</span> <span class="nf">decideByScore</span><span class="o">(</span><span class="kt">int</span> <span class="n">playerScore</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dealerScore</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">value</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">.</span><span class="na">scorePredicate</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">playerScore</span><span class="o">,</span> <span class="n">dealerScore</span><span class="o">))</span>
                <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
                <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">"승패 결과 조건에 매치되지 않습니다."</span><span class="o">));</span>
    <span class="o">}</span>
<span class="c1">// ...</span>
</code></pre></div></div>
<p>이렇게 Enum에 함수형 인터페이스를 사용하여 결과 산출을 했을 때,<br />
<strong>스스로 다음과 같은 장점을 느꼈다.</strong></p>
<ul>
  <li>동일한 기능(딜러와 플레이어의 상태를 비교)에 대해 각각 다른 연산을 가지고 있어 
늘어졌던 <code class="highlighter-rouge">decide()</code> 단순화</li>
  <li>(현 프로그램에서는 그럴일이 없겠지만) 새로운 Result 타입이 추가되어도,
메서드의 추가적 수정이 없다.</li>
  <li>타입이 해야 하는 기능에 대해서 가장 잘 알고 있을 수밖에 없는,
자신 안에 로직을 추가하면서, 로직에 대한 명확한 상수명을 가짐</li>
</ul>

<p>이렇게 함수형 인터페이스를 사용하면서 이를 사용했을 경우의 장점을 스스로 생각하고,<br />
리뷰어님께 질문을 남겼는데 추가적으로 의견을 달아주셨다 👀</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/7f0a6deb-3e53-49b1-8424-87ad3876b191/image.png" style="zoom:50%;" /></p>

<h3 id="상태-패턴">상태 패턴</h3>
<p>미션 2단계를 시작하면서, 베팅 금액을 입력 받고 상태에 따라 수익을 구하는 기능을 추가해야했다.
미션을 시작하기 앞서,
0309 블랙잭 피드백 강의에서 다룬 상태패턴을 적용해 여러 분기처리를 해결하고 싶었고,
이후 스스로 상태 패턴에 대해 더 찾아보고 이번 미션을 통해 
<strong>상태패턴이 무엇이고, 이를 적용하면 어떠한 장점이 있는지 알아보자!</strong>를 목표로
상태패턴 적용길을 걸었다.</p>

<h4 id="내가-적용한-상태-패턴">내가 적용한 상태 패턴</h4>
<p>제이슨 코드를 미리 보고 상태패턴을 시도했기 때문에,  스스로 생각해보지 못한 코드 따라쟁이가 되어버릴까봐 스스로 계속해서 상태별로 다르게 구현해야할 기능들에 대하여 생각해보고 클래스 다이어그램에 나름대로의 명분을 정리해보았다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/5c238570-b95c-4c63-b6ae-6e4b2ab77716/image.png" style="zoom:50%;" /></p>

<p>또한 아래는 상태 패턴의 콘텍스트인 User 클래스이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="kd">final</span> <span class="n">Name</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">protected</span> <span class="n">State</span> <span class="n">state</span><span class="o">;</span>
    <span class="kd">protected</span> <span class="n">Money</span> <span class="n">bettingMoney</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="k">new</span> <span class="n">Name</span><span class="o">(</span><span class="n">name</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="n">Name</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">initializeCards</span><span class="o">(</span><span class="n">Cards</span> <span class="n">cards</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">StateFactory</span><span class="o">.</span><span class="na">generateStateByCards</span><span class="o">(</span><span class="n">cards</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isAbleToHit</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">state</span><span class="o">.</span><span class="na">isFinish</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Score</span> <span class="nf">score</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="na">cards</span><span class="o">().</span><span class="na">totalScore</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Cards</span> <span class="nf">cards</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="na">cards</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">State</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">changeState</span><span class="o">(</span><span class="n">State</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">hit</span><span class="o">(</span><span class="n">Card</span> <span class="n">card</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">changeState</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">draw</span><span class="o">(</span><span class="n">card</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">stay</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">changeState</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">stay</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
</code></pre></div></div>

<p>콘텍스트의 필드로 상태(State)를 가지고 있으며, 
상태에 관련된 기능들을 그 상태에게 메시지를 보내 처리하도록 하였다.</p>

<h4 id="ps">PS</h4>

<p><img src="https://images.velog.io/images/new_wisdom/post/20bb1288-8fec-4e05-a353-61be9fefc696/image.png" style="zoom:50%;" /></p>

<p>위 말은 교육장에서 포비와 이야기를 나누다 인상 깊어 스스로 DM에 남겨놓은 말이다.
말씀대로 디자인 패턴이 무조건 좋은 것은 아니지만, 
개인적으로는 <strong>이번 미션동안 제일 고민했던 부분인 상태에 따른 여러가지 분기처리를
어떻게하면 효과적으로 구현할 수 있을까? 에 대한 좋은 답이 상태패턴이라 생각하여</strong>
상태 패턴을 사용하는 방법과 이점을 느껴보고 싶었기에 스스로 좋은 시도였다고 생각한다 !
물론 다른 미션에서 상태패턴을 적용하라하면 잘 적용할 수 있을지는 모르겠으나,
이번 미션을 통해 이렇게 상태에 따른 분기처리를 줄일 수 있구나, 
디자인 패턴은 이런 장점이 있구나를 느낄 수 있었다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>💡 위클리 회고 5, 6 주차</title>
	  <link>//%EC%9C%84%ED%81%B4%EB%A6%AC-%ED%9A%8C%EA%B3%A0-5,-6-%EC%A3%BC%EC%B0%A8</link>
	  <author></author>
	  <pubDate>2021-03-06T19:18:00+09:00</pubDate>
	  <guid>//%EC%9C%84%ED%81%B4%EB%A6%AC-%ED%9A%8C%EA%B3%A0-5,-6-%EC%A3%BC%EC%B0%A8</guid>
	  <description><![CDATA[
	     <h2 id="무슨일이-있었나">무슨일이 있었나?</h2>

<ul>
  <li>일주일 2번 오프라인 출근이 시작되었다.</li>
  <li>온라인으로만 만나던 사람들을 3D로 처음 만났다.</li>
  <li>출입증 사진을 찍었다.</li>
  <li>3월2일-3월 4일 블랙잭  페어 프로그램을 진행하고 이후 개별 미션으로 찢어졌다.</li>
  <li>학습 로그 말하기를 했다.</li>
  <li>브라운이랑 면담을 했다.</li>
  <li>테코톡 발표를 준비하고 있었는데 미뤄졌다.</li>
  <li>데일리 주제로 레벨 1후, 우테코 수료 후의 나를 적어보는 시간을 가졌다.</li>
  <li>3월 29일까지 완료해야하는 글쓰기 미션이 시작됐다.</li>
  <li>교육장에 있으면서 많은 크루, 코치님과 이야기를 나누었다.</li>
  <li>5주차는 정말 바빴다. 빠듯한 미션 후, 리팩토링과 공부한 내용을 정리하느라 조급했다.</li>
  <li>6주차에는 출근날이 아닌날은 사람들이랑 만나서 모각코를 했다.</li>
  <li>함수형 인터페이스에 대해 찐하게 공부했다.</li>
  <li>상태패턴을 배웠다.</li>
  <li>정말 오랜만에 뚝딱이들이랑 줌미팅을 했다.</li>
</ul>

<hr />

<h2 id="어떤-것을-느꼈나">어떤 것을 느꼈나?</h2>
<h3 id="크루들의-에너지">크루들의 에너지</h3>

<p>매일 온라인으로만 보던 데일리 크루들을 오프라인으로 보니 처음에는 낯설았지만, 또 금방 적응돼서 정말 유쾌하고 즐거웠다.<br />
또, 크루들과 함께 모여 공부하니 많은 에너지를 느끼고, 열심과 열정으로 가득한 크루들덕에 많은 동기부여를 받았다. 졸업하고 가장 아쉬웠던 것이 매일 학교에 남아서 동기들과 으쌰으쌰하며 공부했던 것이 내가 배움에 즐거움을 느끼는 이유 중 하나였는데, 우테코에 들어와서 더 열정적인 사람들과 함께 배움의 즐거움을 누리고 있다는게 너무 행복하다.<br />
온라인으로는 궁금한 것들이 있지만 말하기 애매해서 그냥 삼켰던 프로그래밍 질문들을 오프라인에서는 바로바로 답이 오니 마음 편하게 질문할 수 있어서 오프라인의 유익함을 많이 느꼈다.<br />
함께 공부하며 열정을 불태우는 환경 덕에, 스스로 뒤쳐지는 것이 아닌가 하는 불안감이 정말 싹 사라졌다. 오프라인 출근이 시작되고 크루들이 경쟁자가 아닌 10개월간 함께 으쌰으쌰할 동료라는 말이 이제 정말 진심으로 느껴졌다.</p>

<h3 id="많이-웃었다">많이 웃었다.</h3>
<p>(여기 글에 어울리는지는 모르겠으나) 우테코 출근 시작 부터 크루들과 정말 즐거운 생활을 했다. 정말 많이 웃고 유쾌했던 2주였다.</p>

<h3 id="브라운과-면담">브라운과 면담</h3>
<p><del>느낀점에다 적는게 맞는지는 모르겠으나</del> 브라운과 면담을 하면서 많은 것을 깨달았다. 또한 우테코 생활에 대한 자신감을 얻을 수 있었으며, 우테코를 시작하고 바꾼 나의 생활, 학습 태도에 확신을 얻을 수 있었다. 가장 인상 깊었던 부분은 <strong>페어와의 회고</strong>에 대한 부분이었다. 무조건 좋은 말이 아닌 상대방에 대한 객관적인 피드백은 그 사람을 더 성장하게 만들고, 우테코 미션의 목적 또한 미션 완수가 아닌 페어를 통해 함께 성장하는 것이다. 어떻게 하면 남에게 이로운 피드백을 줄 수 있을까에 대한 고민과 남에게 피드백을 주는데 두려움들이 면담을 통해 해소되었다. 
또 좋은 학습 방법을 알려주셨는데, 어떤 개념을 완전히 내 것으로 만들기 위해서 스스로 동영상이나 녹음을 통해 설명하는 것이다. 이 말을 듣고 굉장히 혹했기에 한번 시도해 볼 계획이다.</p>

<hr />

<h2 id="잘한-것은-무엇인가">잘한 것은 무엇인가?</h2>

<h3 id="깊게-공부하려고-노력한-것">깊게 공부하려고 노력한 것</h3>
<p>저번 미션 학습 로그까지는 무조건 많이 쓰는 것이 많이 성장한 것이라 생각했다. 하지만 내가 적은 내용을 말하려다보니 내가 많이 배우려는 욕심만 부리고 그 개념들을 완벽히 체화하지 못했다는 것이다.<br />
그래서 이번 미션부터는 정말 내가 누군가에게 설명이 가능하도록 내것으로 만들었다. 빠르게 보다는 천천히 꼭꼭 씹어 학습 태도를 취하려 노력하고 있다.</p>

<h3 id="사람들과-많은-이야기를-나눈-것">사람들과 많은 이야기를 나눈 것</h3>

<p>우테코에는 정말 좋은사람들이 많다. 사람들과 이야기를 나누면서, 기술적인 부분만 아니라 인간적으로도 많이 배운다. 다양한 사람들과 이야기를 나누면서 사람에 대해 배워갈 수 있어서 좋았다.
또한 우테코에서 이야기를 나누다가, 또는 채팅으로 좋은 이야기들이 많이 오고 가는데, 그 중 계속 기억해두면 좋을 것 같은 문장들을 개인 슬랙에 저장해두기로 하였다. 
이번주는 포비와 이야기할 수 있는 기회가 있었는데, 대화 속에서 많은 위로와 도전을 얻어서 조금 기록해 두었다.
브라운과 면담도 바로바로 이렇게 적을걸 하는 아쉬움이 살짝 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111073627-c840bc00-8522-11eb-9f11-621f1971db13.png" alt="image" /></p>

<h3 id="모각코한-것">모각코한 것</h3>
<p>이번주 내내 사람들과 만나서 공부했다. 교육장에서, 또는 출근을 안하는 날은 카페에서 누군가와 함께 공부했다. 
같이 만나서 공부하니 더 즐거웠고, 모르는 것을 함께 알아나가는 기쁨을 누릴 수 있어서 좋았다. 
누군가의 궁금증이 내 궁금증이 되어 같이 고민하고 차근차근 공부해 나가는 재미를 느낄 수 있었다.</p>

<h3 id="깃블로그를-판-것">깃블로그를 판 것</h3>
<p>기록 권태기가 와서 벼르고 벼뤘던 깃블로그 이사를 실행하는 중이다.
스스로 공부하는 내용을 좀 더 깊이있고 깔끔하게 정리하고자 하는 다짐과 함께 내 깃블로그가 탄생했다.
커스텀 하느라 너무 많은 시간을 투자하는 것 같아 지금 이래도 되나하는 생각이 들긴하지만, 나의 권태 극복에 많은 도움이 되었다 생각해 잘한 선택인 것 같다.</p>

<hr />

<h2 id="아쉬운-것은-무엇인가">아쉬운 것은 무엇인가?</h2>

<h3 id="내-지식에-대한-불확신">내 지식에 대한 불확신</h3>
<p>솔직하게 돌아보면 나는 아직도 내가 아는 것에 자신이 없는 것 같다.<br />
“나보다 저 사람이 더 맞을거야”라는 생각이 아직까지 강하다.<br />
크루들을 보면 자신이 아는 지식을 정리한 글들을 공유해주는데, <br />
나는 아직까지 내 글, 지식에 자신감이 없어서 그렇지 못하다.</p>

<h3 id="레벨-1후-수료-후의-뚜렷한-목표가-없는-것">레벨 1후, 수료 후의 뚜렷한 목표가 없는 것</h3>

<p>데일리 주제로 한번 스스로 레벨 1과 수료 후 어떻게 변화되어있을지 적어보는 시간을 가졌다. 정말 많은 생각이 들게하는 질문이었다. 최근 미션때문에, 오프라인 출근을 해서 스스로를 돌이켜보는 시간이 많이 없었다. 저 질문들에 선뜻 답하지 못하는 것은 내가 뚜렷한 목표없이 요즘을 살고 있는 것인가 하는 반성을 하게 됐다. 우테코 수료 후, 나는 어떤 개발자를 꿈꾸는가? 계속해서 고민해보고 목표를 세워야겠다.</p>

<h3 id="지금껏-제대로된-회고를-진행하지-못한-것">지금껏 제대로된 회고를 진행하지 못한 것</h3>

<p>브라운이랑 면담하면서 내가 그동안 상대방에게 유익한 피드백을 못주고 있었음을 깨달았다. 지금까지의 페어 모두 만족하지만 미션을 진행하기 급급해서 다른 부수적인 것들을 보지 못했다. 우테코에서 미션을 페어프로그래밍으로 진행하는 이유는 기술적인 부분만이 아닌, 소프트 스킬과 상대방이 보는 나의 객관적인 피드백을 들으며 성장하는 것이다. 면담 내용을 적기 위해 지금껏 미션을 돌아보니 스스로는 미션 완성에만 큰 목표를 두고 있었던 것 같다. 상대방을 기분 좋게 하는 피드백 보다 좋은 사람으로 만들 수 있는 피드백을 해야겠다. 이 내용을 가지고 브라운이랑 면담하면서 회고의 중요성을 많이 깨달았기에, 다음 미션부터는 페어와 사전 협의로 아주 찐한 회고를 할거다.</p>

<h3 id="약간의-귀차니즘이-찾아와-기록하는-습관을-놓친-것">약간의 귀차니즘이 찾아와 기록하는 습관을 놓친 것</h3>
<p>미션이 끝나고 너무 달려서였나, 내가 공부하거나 느낀 점들을 기록하기를 게을리했던 것 같다. 그래서 깃블로그를 팠다.</p>

<hr />

<h2 id="어떻게-달라질-것인가">어떻게 달라질 것인가</h2>
<h3 id="기록하는-삶">기록하는 삶</h3>
<p>이번주는 귀차니즘을 이겨내고, 블로그도 옮겼으니 새로운 마음으로 그날 배운 내용들을 간략하게라도 기록하자.</p>

<h3 id="계획하는-삶">계획하는 삶</h3>
<p>2주동안 그냥 정신없게 사느라 여러 방면에서 놓친 부분들이 많았다. 시간을 더 효율적으로 쓰기 위해 앞으로 내가 오늘 무슨 일을 할 것인지 아침마다 정리해보자.</p>

<h3 id="페어와-찐한-회고">페어와 찐한 회고</h3>
<p>화요일에 새로운 미션이 시작되는데, 이번에는 브라운과 면담한 대로 페어와 함께 성장을 위해 서로 솔직하고 찐한 회고를 약속할 것이다. 페어도 나와 동일한 마음이었으면 좋겠다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>🕹 Level 1. 로또 미션 코드 리뷰 정리</title>
	  <link>//Level-1.-%E1%84%85%E1%85%A9%E1%84%84%E1%85%A9-%E1%84%86%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB-%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3-%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5</link>
	  <author></author>
	  <pubDate>2021-03-01T19:18:00+09:00</pubDate>
	  <guid>//Level-1.-%E1%84%85%E1%85%A9%E1%84%84%E1%85%A9-%E1%84%86%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB-%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3-%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5</guid>
	  <description><![CDATA[
	     <h2 id="1단계-피드백">1단계 피드백</h2>
<h3 id="객체인-controller">객체인 Controller</h3>
<p><img src="https://images.velog.io/images/new_wisdom/post/c00aaeae-a114-4634-ba8b-15d91ea499f6/image.png" style="zoom:50%;" /></p>

<p>LottoFactory를 인스턴스 변수로 두지 않았던 이유는 
Controller는 객체가 아니라 데이터를 가지면 안된다고 생각하고 있었다.<br />
당연히 Domain만 객체라고 생각했었다. (모르는건 부끄러운게 아니다 🥲)</p>

<p>하지만 생각해보니 Controller도 도메인과 뷰를 이어주는 동시에, 객체를 생성하는 책임이 있다.<br />
인스턴스 변수로 가지고 있게 된다면 getLottoTickets 메소드에서 매번 객체를 생성할 필요가 없다.</p>

<p>일단 이 코드에서 중요한 점은 어차피 지금 로또를 생성하는 책임을 컨트롤러에서 하고 있었으니<br />
“불필요한 객체 생성을 방지하도록 인스턴스 변수로만들어서 재활용하자”가 목적이다.</p>

<ul>
  <li><a href="https://github.com/woowacourse/java-lotto/commit/ab16861d71a72d2016ef4cd232a5cf5b5af86ac9">반영한 커밋</a>
    <h3 id="반복되는-상수-처리">반복되는 상수 처리</h3>
    <p><img src="https://images.velog.io/images/new_wisdom/post/acf1e691-e345-41ee-a67b-e249b23f6547/image.png" style="zoom:50%;" /></p>
  </li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/3fd15906-7210-4084-bf94-32f8d9a2141a/image.png" style="zoom:50%;" /></p>

<p>미션 데드라인을 맞추기 위해 좀 더 꼼꼼히 확인을 못했던 부분인데,<br />
로또 티켓을 만드는 LottoTicketFactory에 있는 상수 값들이 LottoNumber나 LottoTicket등 여러 곳에서 중복되어 쓰이고 있었다.<br />
또 심지어 로또의 MAX 번호는 45인데, 49까지로 입력해 놓았다 🙃<br />
덕분에 상수값 하나라도 꼼꼼히 확인해야겠다는 깨달음을 얻었다.</p>

<p>중복되는 상수를 막으며, 각 객체가 알고 있어야 하는 값대로 상수를 두고<br />
이를 import 해서 사용하도록 수정했다.</p>

<h4 id="lottonumber">LottoNumber</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">LottoNumber</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MIN_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">45</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Pattern</span> <span class="n">NUMBER_PATTERN</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"^[0-9]*$"</span><span class="o">);</span>
</code></pre></div></div>
<h4 id="lottoticket">LottoTicket</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoTicket</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">LOTTO_TICKET_SIZE</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
</code></pre></div></div>
<h4 id="lottofactory">LottoFactory</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">lotto</span><span class="o">.</span><span class="na">domain</span><span class="o">.</span><span class="na">LottoNumber</span><span class="o">.</span><span class="na">MAX_LOTTO_NUMBER</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">lotto</span><span class="o">.</span><span class="na">domain</span><span class="o">.</span><span class="na">LottoNumber</span><span class="o">.</span><span class="na">MIN_LOTTO_NUMBER</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">lotto</span><span class="o">.</span><span class="na">domain</span><span class="o">.</span><span class="na">LottoTicket</span><span class="o">.</span><span class="na">LOTTO_TICKET_SIZE</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">lotto</span><span class="o">.</span><span class="na">domain</span><span class="o">.</span><span class="na">Money</span><span class="o">.</span><span class="na">LOTTO_PRICE</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoTicketFactory</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">START_INDEX</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</code></pre></div></div>
<ul>
  <li><a href="https://github.com/woowacourse/java-lotto/commit/95988ad3982c06c1d6b105db83bd0fa9b559260a">반영한 커밋</a>
    <h3 id="구매-금액-계산-법">구매 금액 계산 법</h3>
    <p><img src="https://images.velog.io/images/new_wisdom/post/1c7743ed-6856-4410-809d-aa6c383c680d/image.png" style="zoom:50%;" /></p>
  </li>
</ul>

<p>리팩토링 전 로직으로는 구매 금액을 입력 받을 때 만약 14500원이 들어오면 사용한 금액은<br />
14장을 사는데 14000원만 들게 하고 500원이 남는 것은 예외라고 생각하지 않고 진행했다.<br />
그런데 이 로직은 구매한 금액이 아닌 지불한 14500원으로 수익률을 계산하고 있다.<br />
때문에 입력 금액과 구매 금액의 미일치 오류가 발생한다.</p>

<p>피드백을 통해 lottoResult에서 구할 수 있는 티켓 개수와 상수 변수인 로또의 구매장수로<br />
지불 금액을 구할 수 있음을 깨닫고 <code class="highlighter-rouge">showResult()</code> 에서 <code class="highlighter-rouge">money</code>를 매개변수로 받을 필요가 없음을 깨달았다.</p>

<p>덕분에 money와의 연관관계를 하나 끊을 수 있고, <br />
수익금 계산 시 입력 금액과 구매 금액 미일치로 인한 수익률 에러를 방지할 수 있다.</p>

<ul>
  <li><a href="https://github.com/woowacourse/java-lotto/commit/06cf1861eab0fcd0900218e06c38024fcae2d957">반영한 커밋</a></li>
</ul>

<h3 id="prize에서의-static-메서드-사용">Prize에서의 static 메서드 사용</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/1c8c1eac-ab18-4280-b3ad-e5ab1ff285bb/image.png" style="zoom:50%;" /></p>

<h4 id="리팩토링-전-prize">리팩토링 전 Prize</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Prize</span> <span class="nf">getPrizeType</span><span class="o">(</span><span class="kt">int</span> <span class="n">matchCount</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isBonusBall</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isMatchCountEqualsPivot</span><span class="o">(</span><span class="n">matchCount</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isBonusBall</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">SECOND_PRIZE</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">matchCount</span> <span class="o">==</span> <span class="n">matchCount</span><span class="o">)</span>
                <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
                <span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="n">NO_PRIZE</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isMatchCountEqualsPivot</span><span class="o">(</span><span class="kt">int</span> <span class="n">matchCount</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">matchCount</span> <span class="o">==</span> <span class="n">BONUS_CHECK_PIVOT</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span> <span class="nf">calculatePrizeMoneySum</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Prize</span><span class="o">&gt;</span> <span class="n">lottoResults</span><span class="o">,</span> <span class="n">Money</span> <span class="n">money</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Money</span> <span class="n">moneySum</span> <span class="o">=</span> <span class="n">Money</span><span class="o">.</span><span class="na">ZERO</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Prize</span> <span class="n">prize</span> <span class="o">:</span> <span class="n">Prize</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">Money</span> <span class="n">perPrizeMoneySum</span> <span class="o">=</span> <span class="n">prize</span><span class="o">.</span><span class="na">prizeMoney</span>
                    <span class="o">.</span><span class="na">multiple</span><span class="o">(</span><span class="n">getCountByPrizeType</span><span class="o">(</span><span class="n">lottoResults</span><span class="o">,</span> <span class="n">prize</span><span class="o">));</span>
            <span class="n">moneySum</span> <span class="o">=</span> <span class="n">moneySum</span><span class="o">.</span><span class="na">plus</span><span class="o">(</span><span class="n">perPrizeMoneySum</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">moneySum</span><span class="o">.</span><span class="na">getRate</span><span class="o">(</span><span class="n">money</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getCountByPrizeType</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Prize</span><span class="o">&gt;</span> <span class="n">lottoResults</span><span class="o">,</span> <span class="n">Prize</span> <span class="n">prize</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">lottoResults</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">prize</span><span class="o">))</span>
                <span class="o">.</span><span class="na">count</span><span class="o">();</span>
    <span class="o">}</span>

</code></pre></div></div>

<h4 id="리팩토링-전-lottoresult">리팩토링 전 LottoResult</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoResult</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Prize</span><span class="o">&gt;</span> <span class="n">lottoResults</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LottoResult</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Prize</span><span class="o">&gt;</span> <span class="n">lottoResults</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lottoResults</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">lottoResults</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateProfitRate</span><span class="o">(</span><span class="n">Money</span> <span class="n">money</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Prize</span><span class="o">.</span><span class="na">calculatePrizeMoneySum</span><span class="o">(</span><span class="n">lottoResults</span><span class="o">,</span> <span class="n">money</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCountPerPrizeType</span><span class="o">(</span><span class="n">Prize</span> <span class="n">prize</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Prize</span><span class="o">.</span><span class="na">getCountByPrizeType</span><span class="o">(</span><span class="n">lottoResults</span><span class="o">,</span><span class="n">prize</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>LottoResult에서 <code class="highlighter-rouge">calculateProfitRate()</code>을 하기 위해  Prize의 도움을 받았다.<br />
lottoResults가 Prize의 도움을 받지 않고 <code class="highlighter-rouge">List&lt;Prize&gt; lottoResults</code> 
각각의 prize에게 메시지를 보내 스스로 계산할 수 있도록 코드를 다음과 같이 수정했었다.</p>

<h4 id="lottoresult">LottoResult</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="n">Money</span> <span class="nf">getTotalProfit</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Money</span> <span class="n">totalProfit</span> <span class="o">=</span> <span class="n">Money</span><span class="o">.</span><span class="na">ZERO</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Prize</span> <span class="n">prize</span> <span class="o">:</span> <span class="n">lottoResults</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">totalProfit</span> <span class="o">=</span> <span class="n">totalProfit</span><span class="o">.</span><span class="na">plus</span><span class="o">(</span><span class="n">prize</span><span class="o">.</span><span class="na">getPrizeMoney</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">totalProfit</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><a href="https://github.com/woowacourse/java-lotto/commit/af0f1ff2915d6420b6935e1baa9510c1030c7daf">1차 반영 커밋</a></li>
</ul>

<p>하지만 리팩토링 후에도 아직 객체 스스로 할 수 있는일들이 남아있었다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/acb68cb8-5309-4c65-a040-2babdc96a770/image.png" style="zoom:50%;" /></p>

<p>또 이때까지 로또 티켓과 당첨 티켓을 비교해 결과를 반환하는 책임을 <br />
lott. Tickets가 가지고 있었다.<br />
곰곰히 생각해보니 로또 티켓과 당첨 티켓을 비교해 결과를 반환하는 책임은 winningLotto가 맡는 것이 더 적합하다고 판단이 되었고,<br />
winningLotto에서 prize를 체크하도록 책임을 이동하였다.</p>

<p>최종적으로 LottoResult를 반환하는 것은 winnigLotto에서 담당하며,<br />
또 Prize의 도움을 받지 않고 스스로 prize를 체크하도록 하였다.</p>

<h4 id="리팩토링한-winniglotto의-메소드-일부">리팩토링한 WinnigLotto의 메소드 일부</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Prize</span> <span class="nf">matchPrize</span><span class="o">(</span><span class="n">LottoTicket</span> <span class="n">lottoTicket</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">matchCount</span> <span class="o">=</span> <span class="n">getMatchingCount</span><span class="o">(</span><span class="n">lottoTicket</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="n">isBonusNumber</span> <span class="o">=</span> <span class="n">isContainBonusNumber</span><span class="o">(</span><span class="n">lottoTicket</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">Prize</span><span class="o">.</span><span class="na">findPrize</span><span class="o">(</span><span class="n">matchCount</span><span class="o">,</span> <span class="n">isBonusNumber</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">getMatchingCount</span><span class="o">(</span><span class="n">LottoTicket</span> <span class="n">lottoTicket</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">lottoTicket</span><span class="o">.</span><span class="na">lottoTicket</span><span class="o">().</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">winningTicket</span><span class="o">.</span><span class="na">lottoTicket</span><span class="o">()::</span><span class="n">contains</span><span class="o">)</span>
            <span class="o">.</span><span class="na">count</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isContainBonusNumber</span><span class="o">(</span><span class="n">LottoTicket</span> <span class="n">lottoTicket</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">lottoTicket</span><span class="o">.</span><span class="na">lottoTicket</span><span class="o">()</span>
            <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">anyMatch</span><span class="o">(</span><span class="n">lottoNumber</span> <span class="o">-&gt;</span> <span class="n">lottoNumber</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">bonusNumber</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>
<h4 id="리팩토링-후-prize에서-줄어든-static-메소드들">리팩토링 후 Prize에서 줄어든 static 메소드들</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">Prize</span> <span class="nf">findPrize</span><span class="o">(</span><span class="kt">int</span> <span class="n">matchCount</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isBonusNumber</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isMatchCountEqualsPivot</span><span class="o">(</span><span class="n">matchCount</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isBonusNumber</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">SECOND_PRIZE</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">matchCount</span> <span class="o">==</span> <span class="n">matchCount</span><span class="o">)</span>
            <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
            <span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="n">NO_PRIZE</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isMatchCountEqualsPivot</span><span class="o">(</span><span class="kt">int</span> <span class="n">matchCount</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">matchCount</span> <span class="o">==</span> <span class="n">BONUS_CHECK_PIVOT</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="n">Money</span> <span class="nf">getPrizeMoney</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">prizeMoney</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getMatchCount</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">matchCount</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><a href="https://github.com/woowacourse/java-lotto/commit/df62ef0a1e9ef8bf680d03556a0c44886d252c24">반영한 커밋1</a></li>
  <li><a href="https://github.com/woowacourse/java-lotto/commit/e0acff81ab0893813483949504c22bd954271a46">반영한 커밋2</a></li>
</ul>

<h3 id="collectingandthen">collectingAndThen</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/40036589-2ae0-4833-a4ed-8bf372d68844/image.png" style="zoom:50%;" /></p>

<p>리뷰어님께서 수정해주신 코드는 <code class="highlighter-rouge">collectingAndThen</code>메소드를 사용했는데,<br />
처음보는 메소드라 찾아보니 collecting을 진행한 후 그 결과로 메소드를 호출할 수 있는 메서드 였다.<br />
stream map을 써서 객체 하나하나를 생성하고 이를 리스트로 바꿔,<br />
또 객체를 생성하는 나의 로직에서 이 메서드를 사용하면<br />
좀 더 간결하게 표현할 수 있었다.<br />
사용법을 배웠으니, 앞으로 자주 사용할 것이다 👀<br />
또 Collections의 다양한 API를 살펴보아야겠다.</p>

<ul>
  <li><a href="https://www.baeldung.com/java-8-collectors">참고</a></li>
</ul>

<h2 id="2단계-초기-리팩토링">2단계 초기 리팩토링</h2>
<p><img src="https://images.velog.io/images/new_wisdom/post/b07190ba-4871-4c44-8f25-b7c17d1da072/image.png" style="zoom:50%;" /></p>

<h3 id="lottocount-객체-추가">LottoCount 객체 추가</h3>
<p>이번 리팩토링에서 <code class="highlighter-rouge">수동 로또 개수</code>를 입력 받고, 이 갯수 만큼 로또를 생성하고 출력해야했다.<br />
원시값 포장의 의미도 담으면서 입력 받는 수동 로또 갯수에 대한 검증하고, <br />
이에 대한 상태와 행위를 한 곳에서 관리 하기 위해 <code class="highlighter-rouge">LottoCount</code> 객체를 만들게 되었다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoCount</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">manualCount</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">autoCount</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LottoCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">manualCount</span><span class="o">,</span> <span class="kt">int</span> <span class="n">totalCount</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">validateLottoCount</span><span class="o">(</span><span class="n">manualCount</span><span class="o">,</span> <span class="n">totalCount</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">manualCount</span> <span class="o">=</span> <span class="n">manualCount</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">autoCount</span> <span class="o">=</span> <span class="n">totalCount</span> <span class="o">-</span> <span class="k">this</span><span class="o">.</span><span class="na">manualCount</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateLottoCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">manualCount</span><span class="o">,</span> <span class="kt">int</span> <span class="n">totalCount</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">manualCount</span> <span class="o">&gt;</span> <span class="n">totalCount</span> <span class="o">||</span> <span class="n">manualCount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"[ERROR] 구매 가능한 로또 개수 범위가 아닙니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getManualCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">manualCount</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAutoCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">autoCount</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="exception">Exception</h3>
<p>화요일 강의인 Exception이 내게는 많은 배움을 주어서, <br />
이번 요구사항인 사용자 입력값에 대한 예외처리를 신경썼다.<br />
이전에는 Custom Exception을 만들어서 각 객체마다 예외 처리를 해주었으나,</p>

<ul>
  <li>리팩토링 전 Custom Class
```java
package lotto.exception;</li>
</ul>

<p>import lotto.view.ErrorView;</p>

<p>public class IllegalMoneyException extends IllegalArgumentException {
    public IllegalMoneyException() {
        ErrorView.printIllegalMoneyErrorMessage();
    }
}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>각 Custom Exception 클래스가 따로 처리하는 일이 없고,   
메세지도 super에게 전달하는 것이 아닌 `ErrorView`라는 객체를 통해 출력하고 있기 때문에    
필요성을 못느끼게 되어 자바의 기본 예외를 사용하도록 리팩토링을 진행했다.  
또 객체 단위로 묶어서 에러 메세지를 보내던 부분은   
각 예외 사항에 맞게 에러 메시지를 보내도록 수정했다.  

#### LottoTicketFactory -&gt; AutoNumbersFactory
요구사항에 따라 리팩토링을 진행하면서 `LottoTickets`를 생성해내던 LottoTicketfactory의 역할에 대한 의문이 들었다.   
처음 리팩토링에서는 객체를 많이 변경하지 않기 위해 수동 로또 번호들을 받고 자동 로또 갯수를 받아서  
`LottoTicketFactory`에서 자동 로또 숫자들을 만들고 `LottoTickets`를 생성하는 역할로 진행했는데,  
로또 티켓들 객체를 생성하기 위해 또 다른 `LottoTicketFactory`를 생성하는 것이 좋지 못한 방안이라는 생각이 들었다.  

때문에 LottoTickets 객체를 생성할 때 로또 번호들의 리스트들을 받아서   
(`List&lt;List&lt;LottoNumber&gt;&gt; lottoNumbersGroup`) `LottoTickets` 안에서 로또 티켓들을 생성하는 방식으로 변경했다.
그리고 기존 `LottoTicketFactory`는 `AutoNumbersFactory`로 변경하여  
자동 로또 숫자 리스트를 만들어내는 역할로 변경해보았다 !   

#### LottoNumber
0223 수업 때 로또 넘버의 범위에 제한이 있으니, 이를 미리 캐싱해서 사용하는 방법을 생각해보라고 하셨다.  
생각을 해보고 캐싱하는 방법을 찾아보니 `HashMap`을 이용해서 캐싱을 구현할 수 있음을 깨달았다.  
이로 생성자를 `private`로 막아 불필요한 객체 생성을 막고,   
`static block`에 의해 미리 캐싱된 `LottoNumber`에서 키값으로 접근해 해당 로또넘버를 가져오는 형식으로 리팩토링을 진행했다.  

* LottoNumber 캐시 적용 부분
```java
static {
    IntStream.range(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER + 1)
            .forEach(i -&gt; CACHE_LOTTO_NUMBERS.put(i, new LottoNumber(i)));
}

public static LottoNumber valueOf(int index) {
    validateLottoNumber(index);
    return CACHE_LOTTO_NUMBERS.get(index);
}
</code></pre></div></div>

<h2 id="2단계-피드백">2단계 피드백</h2>

<h3 id="정적-팩터리-메소드">정적 팩터리 메소드</h3>
<p><img src="https://images.velog.io/images/new_wisdom/post/6f036cee-daa9-49b9-95c1-5b1925020fd1/image.png" style="zoom:50%;" /></p>

<p>정적 팩터리 메서드에 대해 정리는 했었으나,<br />
사실 언제 써야하고 언제 쓰지 말아야할지 아직 감이 안왔다 해야하나 🥲</p>

<p>그런데 크루들이랑 얘기를 해보니, <br />
정답은 없으나 자신이 쓰는 명분을 가지는게 좋을 것 같다는 결론을 내렸다.<br />
사실 이때까지 정적 팩터리 메서드의 사용성을 제대로 인지하지 못하고 있었던 것 같다.<br />
static이라는 명분 때문에 객체를 공유한다고 생각했으나,<br />
정적 팩터리 메서드 내에서 새로운 객체를 생성해 반환한다면<br />
상태를 공유하지 않는 것이다.</p>

<p>왜 static이라는 명목 때문에 정적 팩터리 메서드가 무조건<br />
공유되는 객체를 만든다고만 생각했을까 🥲</p>

<p>때문에 이번 리팩토링에서는 정적 팩터리 메서드를 적극 사용해 보았다.</p>

<h3 id="많은-책임을-지고-있던-lottocontroller">많은 책임을 지고 있던 LottoController</h3>
<p><img src="https://images.velog.io/images/new_wisdom/post/12a6e507-efd1-4f00-9ba6-fd9c57bb9ab3/image.png" style="zoom:50%;" /></p>

<p>이 당시 내가 구현한 LottoController는</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="n">LottoTickets</span> <span class="nf">buyLottoTickets</span><span class="o">(</span><span class="n">LottoCount</span> <span class="n">lottoCount</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">LottoNumber</span><span class="o">&gt;&gt;</span> <span class="n">lottoNumbersGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">lottoNumbersGroup</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">createAllManualLottoTicket</span><span class="o">(</span><span class="n">lottoCount</span><span class="o">.</span><span class="na">getManualLottoCount</span><span class="o">()));</span>
    <span class="n">lottoNumbersGroup</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">createAutoNumbers</span><span class="o">(</span><span class="n">lottoCount</span><span class="o">.</span><span class="na">getAutoLottoCount</span><span class="o">()));</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">LottoTickets</span><span class="o">(</span><span class="n">lottoNumbersGroup</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이런식으로 LottoTicket에 해당하는 <code class="highlighter-rouge">List&lt;LottoNumber&gt;</code>도 Controller에서 만들고,<br />
이를 가지고 LottoTickets까지 만들어 낸다.<br />
또 보다싶이 <code class="highlighter-rouge">List&lt;List&lt;LottoNumber&gt;&gt;</code>를 만들어 내기 위해 복잡한 코드를 가지고 있었다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">LottoNumber</span><span class="o">&gt;&gt;</span> <span class="nf">createAllManualLottoTicket</span><span class="o">(</span><span class="kt">int</span> <span class="n">manualLottoCount</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">OutputView</span><span class="o">.</span><span class="na">printInputManualLottoNumbers</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">manualLottoCount</span><span class="o">)</span>
            <span class="o">.</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">InputView</span><span class="o">.</span><span class="na">inputNumbers</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">input</span> <span class="o">-&gt;</span> <span class="n">LottoNumber</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">ParseUtil</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">)))</span>
                    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">()))</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이에 대해 남겨주신 피드백은 다음과 같다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/001e2dd8-9190-4b5f-a7de-2517dd7e6387/image.png" style="zoom:50%;" /></p>

<p><img src="https://images.velog.io/images/new_wisdom/post/3d3587e8-af0a-43a5-a164-a3fc966295f0/image.png" style="zoom:50%;" /></p>

<p><img src="https://images.velog.io/images/new_wisdom/post/9413baaf-ec08-45c4-a999-d47ef4092193/image.png" style="zoom:50%;" /></p>

<p>이로 인해 전반적으로 많은 수정이 일어났다.<br />
LottoTicket에 <code class="highlighter-rouge">auto()</code>, <code class="highlighter-rouge">manual()</code> 정적 팩터리 메서드를 만들고,<br />
LottoTickets에도 <code class="highlighter-rouge">auto()</code> 정적 팩터리 메서드를 만들어 <br />
LottoController에서 생성하고 있던 책임을 분배했다.</p>

<h4 id="lottoticket---auto-manual">LottoTicket - auto(), manual()</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">LottoTicket</span> <span class="nf">auto</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">LottoTicket</span><span class="o">(</span><span class="n">LottoNumbersFactory</span><span class="o">.</span><span class="na">generateAutoLottoNumbers</span><span class="o">());</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="n">LottoTicket</span> <span class="nf">manual</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">lottoNumberStrings</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">lottoNumberStrings</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">LottoNumber</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">ParseUtil</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">collectingAndThen</span><span class="o">(</span><span class="n">toList</span><span class="o">(),</span> <span class="nl">LottoTicket:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>
<p>LottoTicket에서 <code class="highlighter-rouge">List&lt;String&gt;</code>을 받아 수동 로또 티켓을 생성하도록 리팩토링 해보았다 !</p>
<h4 id="lottotickets---auto">LottoTickets - auto()</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">LottoTickets</span> <span class="nf">auto</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="nl">LottoTicket:</span><span class="o">:</span><span class="n">auto</span><span class="o">)</span>
            <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="n">count</span><span class="o">)</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">collectingAndThen</span><span class="o">(</span><span class="n">toList</span><span class="o">(),</span> <span class="nl">LottoTickets:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>
<p>덕분에 LottoContoller에 있던 많은 책임이 분배되었다고 생각하고(?),
각 메서드 코드도 간결해졌다고 느낀다.</p>

<h4 id="lottocontroller-일부">LottoController 일부</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="n">LottoTickets</span> <span class="nf">buyLottoTickets</span><span class="o">(</span><span class="n">LottoCount</span> <span class="n">lottoCount</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">LottoTickets</span> <span class="n">lottoTickets</span> <span class="o">=</span> <span class="n">createManualLottoTickets</span><span class="o">(</span><span class="n">lottoCount</span><span class="o">.</span><span class="na">getManualCount</span><span class="o">());</span>
    <span class="n">lottoTickets</span><span class="o">.</span><span class="na">combine</span><span class="o">(</span><span class="n">LottoTickets</span><span class="o">.</span><span class="na">auto</span><span class="o">(</span><span class="n">lottoCount</span><span class="o">.</span><span class="na">getAutoCount</span><span class="o">()));</span>
    <span class="k">return</span> <span class="n">lottoTickets</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">LottoTickets</span> <span class="nf">createManualLottoTickets</span><span class="o">(</span><span class="kt">int</span> <span class="n">manualCount</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">OutputView</span><span class="o">.</span><span class="na">printInputManualLottoNumbers</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">LottoTicket</span><span class="o">.</span><span class="na">manual</span><span class="o">(</span><span class="n">InputView</span><span class="o">.</span><span class="na">inputNumbers</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="n">manualCount</span><span class="o">)</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">collectingAndThen</span><span class="o">(</span><span class="n">toList</span><span class="o">(),</span> <span class="nl">LottoTickets:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="lottotickets">LottoTickets</h3>
<p><img src="https://images.velog.io/images/new_wisdom/post/3f3db20b-c6f6-4134-b43c-35174ea78954/image.png" style="zoom:50%;" /></p>

<p>피드백을 듣고 생각해보니 LottoTickets를 나는 단순히 LottoTicket의 모음이라고만 생각했었다.<br />
(약간 Repository로 생각했던 것 같다.)</p>

<h4 id="리펙토링-전-lottotickets">리펙토링 전 LottoTickets</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">LottoTicket</span><span class="o">&gt;</span> <span class="n">lottoTickets</span><span class="o">;</span>

<span class="kd">public</span> <span class="nf">LottoTickets</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">LottoNumber</span><span class="o">&gt;&gt;</span> <span class="n">lottoNumbersGroup</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">lottoTickets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">createLottoTickets</span><span class="o">(</span><span class="n">lottoNumbersGroup</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">LottoTicket</span><span class="o">&gt;</span> <span class="nf">lottoTickets</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableList</span><span class="o">(</span><span class="n">lottoTickets</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">LottoTicket</span><span class="o">&gt;</span> <span class="nf">createLottoTickets</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">LottoNumber</span><span class="o">&gt;&gt;</span> <span class="n">lottoNumbersGroup</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">lottoNumbersGroup</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">LottoTicket:</span><span class="o">:</span><span class="k">new</span><span class="o">)</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>고민해보니 이전에 아래와 같이 WinningTicket에서 당첨 결과를 산출했었는데,</p>
<h4 id="리펙토링-전-winniglotto">리펙토링 전 WinnigLotto</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">LottoResult</span> <span class="nf">checkPrizes</span><span class="o">(</span><span class="n">LottoTickets</span> <span class="n">lottoTickets</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">lottoTickets</span><span class="o">.</span><span class="na">lottoTickets</span><span class="o">().</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">matchPrize</span><span class="o">)</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">collectingAndThen</span><span class="o">(</span><span class="n">toList</span><span class="o">(),</span> <span class="nl">LottoResult:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="n">Prize</span> <span class="nf">matchPrize</span><span class="o">(</span><span class="n">LottoTicket</span> <span class="n">lottoTicket</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">matchCount</span> <span class="o">=</span> <span class="n">getMatchingCount</span><span class="o">(</span><span class="n">lottoTicket</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="n">isBonusNumber</span> <span class="o">=</span> <span class="n">isContainBonusNumber</span><span class="o">(</span><span class="n">lottoTicket</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">Prize</span><span class="o">.</span><span class="na">findPrize</span><span class="o">(</span><span class="n">matchCount</span><span class="o">,</span> <span class="n">isBonusNumber</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">getMatchingCount</span><span class="o">(</span><span class="n">LottoTicket</span> <span class="n">lottoTicket</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">lottoTicket</span><span class="o">.</span><span class="na">lottoTicket</span><span class="o">().</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">winningTicket</span><span class="o">.</span><span class="na">lottoTicket</span><span class="o">()::</span><span class="n">contains</span><span class="o">)</span>
                <span class="o">.</span><span class="na">count</span><span class="o">();</span>
<span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isContainBonusNumber</span><span class="o">(</span><span class="n">LottoTicket</span> <span class="n">lottoTicket</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">lottoTicket</span><span class="o">.</span><span class="na">lottoTicket</span><span class="o">()</span>
                <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">anyMatch</span><span class="o">(</span><span class="n">lottoNumber</span> <span class="o">-&gt;</span> <span class="n">lottoNumber</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">bonusNumber</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 모든 메서드에서 LottoTicket의 값을 꺼내오고 있었다.<br />
때문에 LottoTickets에 WinnigLotto를 주어 각 LottoTicket에게 비교하라는 메시지를 주는것이 더 옳다고 생각해서<br />
LottoTickets에서 결과를 비교하는 역할을 부여하게 되었다.</p>

<p>또 Controller에서 로또 티켓을 생성하는 역할을 덜기 위해 메서드들이 바로 LottoTickets를 반환하도록 하면서<br />
<code class="highlighter-rouge">ManualLottoTickets</code>와 <code class="highlighter-rouge">LottoTickets.auto</code>를생성하는데<br />
생성된 이 두 <code class="highlighter-rouge">LottoTickets</code>들을 합치는 역할도 필요하다고 생각해서 <br />
<code class="highlighter-rouge">combine()</code>할 수 있는 기능을 추가했다.</p>

<p>그런데 WinnigLotto에 있던 것들을 LottoTickets로 분배하니 WinningLotto의<br />
역할이 다 빼앗겨 버린건 아닐까 고민이 되었지만,</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/044fae6a-acce-474a-8d3d-5b031dfe7196/image.png" style="zoom:50%;" /></p>

<p>리뷰어 분께서 괜찮다고 말씀해주셨다.</p>

<p>미션을 진행하면 할수록 아직 배울 것이 많고 나의 부족함을 느낀다.<br />
배울 것이 많다는 것은 느낄 성취감이 많다는 것이니 앞으로 화이팅하자 🏃‍♂️</p>

	  ]]></description>
	</item>


</channel>
</rss>
