<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>NewWisdom.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>블로그 이사중... 아직 정리가 안되었음...</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>📋 Jpa - 양방향 매핑</title>
	  <link>//jpa</link>
	  <author></author>
	  <pubDate>2021-05-29T19:18:00+09:00</pubDate>
	  <guid>//jpa</guid>
	  <description><![CDATA[
	     <h2 id="양방향-매핑">양방향 매핑</h2>

<ul>
  <li>반대방향으로도 그래프 조회가 가능해야함</li>
</ul>

<h3 id="연관-관계의-주인과">연관 관계의 주인과</h3>

<ul>
  <li>왜 <strong>mappedBy</strong>를 해주는 건지?</li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/0bb5bd16-ea28-4860-8051-7831cdb3994e/image.png" style="zoom:50%;" /></p>

<ul>
  <li>객체는 서로를 포함하고 있어야 함 (2개가 필요)</li>
</ul>

<h3 id="객체와-테이블이-관계를-맺는-차이">객체와 테이블이 관계를 맺는 차이</h3>

<h4 id="객체-연관관계">객체 연관관계</h4>

<ul>
  <li>회원 -&gt; 팀 연관 관계 1개 (단방향)</li>
  <li>팀 -&gt; 회원 연관관계 1개 (단방향)</li>
</ul>

<h4 id="테이블-연관관계">테이블 연관관계</h4>

<ul>
  <li>회원 &lt;-&gt; 팀의 연관관계 1개 (양방향)</li>
</ul>

<h4 id="이-차이를-어떻게-극복할거냐">이 차이를 어떻게 극복할거냐??</h4>

<h4 id="객체의-양방향-관계">객체의 양방향 관계</h4>

<p>객체는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개이다.<br />
객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 함</p>

<h4 id="테이블의-양방향-관계">테이블의 양방향 관계</h4>

<p>테이블은 외래키 하나로 두테이블의 연관 관계를 관리</p>

<h4 id="둘-중-하나로-외래키를-관리해야-한다">둘 중 하나로 외래키를 관리해야 한다</h4>

<p><img src="https://images.velog.io/images/new_wisdom/post/f09341ef-b543-4385-b523-95508f1d4021/image.png" style="zoom:50%;" /></p>

<ul>
  <li>객체는 두 곳에서 연관관계에 있는 객체를 다루고 있음</li>
  <li>그러면 뭘 믿어야 하나?</li>
  <li>두개는 어차피 다르다. 둘 중 하나만 주인으로 만들자</li>
</ul>

<h3 id="연관-관계의-주인">연관 관계의 주인</h3>

<ul>
  <li>두곳에 있는 객체중 하나만 주인으로 두고 걔만 영향을 받음</li>
</ul>

<h5 id="양방향-매핑-규칙">양방향 매핑 규칙</h5>

<ul>
  <li>객체의 두 관계 중 하나를 연관관계의 주인으로 지정</li>
  <li>연관관계의 주인만이 외래키를 관리(등록, 수정)</li>
  <li>주인이 아닌 쪽은 읽기만 가능</li>
  <li>주인은 mappedBy 속성 사용 x</li>
  <li>주인이 아니면 mappedBy 속성으로 주인 지정</li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/905fc876-da30-4127-8deb-166c9a7b1b85/image.png" style="zoom:50%;" /></p>

<h4 id="그런데-누구를-주인으로-해야하나">그런데 누구를 주인으로 해야하나?</h4>

<ul>
  <li>외래키가 있는 곳을 주인으로 정해라</li>
  <li>여기서는 Member.team이 연관관계의 주인</li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/0f6057f2-1231-4290-8708-1764e7edd84b/image.png" style="zoom:50%;" /></p>

<h5 id="참고---설계">참고 - 설계</h5>

<ul>
  <li>일단 단방향으로 다 설계를 하고 양방향이 필요할 때 양방향을 추가하자</li>
  <li>양방향은 조회를 편하게 하기 위해 사용하는 느낌</li>
  <li>인지 부조화가 생기지 않음</li>
</ul>

<h4 id="양방향-매핑시-가장-많이-하는-실수">양방향 매핑시 가장 많이 하는 실수</h4>

<ul>
  <li>연관관계의 주인에 값을 입력하지 않음</li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/89b56488-72dd-40db-9a1d-d8409c74feed/image.png" style="zoom:50%;" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Team</span><span class="o">();</span>
<span class="n">team</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"teamA"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">team</span><span class="o">);</span>

<span class="n">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Member</span><span class="o">();</span>
<span class="n">member</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"amazzi"</span><span class="o">);</span>
<span class="n">member</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>주인에 값을 입력하기</li>
</ul>

<h4 id="양방향-매핑시-연관관계의-주인에-값을-입력해야함">양방향 매핑시 연관관계의 주인에 값을 입력해야함</h4>

<ul>
  <li>순수한 객체 관계를 고려하면 항상 양쪽 다 값을 입력해야 함</li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/40569da2-4675-477b-8891-a3228c9bc8b4/image.png" style="zoom:50%;" /></p>

<ul>
  <li>실제 코드에는 양쪽 다 할 것을 권장</li>
</ul>

<h3 id="양방향-매핑의-장점">양방향 매핑의 장점</h3>

<ul>
  <li>단방향 매핑만으로도 이미 연관관계 매핑은 완료</li>
  <li>양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐</li>
  <li>JPQL에서 역방향으로 탐색할 일이 많음</li>
  <li>단방향 매핑을 잘하고 양방향은 필요할 때 추가해도 됨(테이블에 영향을 주지 않음)</li>
</ul>

<h3 id="연관-관계-매핑-어노테이션">연관 관계 매핑 어노테이션</h3>

<ul>
  <li>다대일 <code class="highlighter-rouge">@ManyToOne</code></li>
  <li>일대다 <code class="highlighter-rouge">@OneToMany</code></li>
  <li>일대일 <code class="highlighter-rouge">@OneToOne</code></li>
  <li>다대다 <code class="highlighter-rouge">@ManyToMany</code></li>
  <li><code class="highlighter-rouge">@JoinColum</code>, <code class="highlighter-rouge">@JoinTable</code></li>
</ul>

<h3 id="상속-관계-매핑-어노테이션">상속 관계 매핑 어노테이션</h3>

<ul>
  <li><code class="highlighter-rouge">@Ingeritance</code></li>
  <li><code class="highlighter-rouge">@DiscriminatorColumn</code></li>
  <li><code class="highlighter-rouge">@DiscriminatorValue</code></li>
  <li><code class="highlighter-rouge">@MappedSuperclass</code> : 매핑 속성만 상속</li>
</ul>

<h4 id="복합키-어노테이션">복합키 어노테이션</h4>

<ul>
  <li><code class="highlighter-rouge">@IdClass</code></li>
  <li><code class="highlighter-rouge">@EmbeddeId</code></li>
  <li><code class="highlighter-rouge">@Embeddable</code></li>
  <li><code class="highlighter-rouge">@MapsId</code></li>
</ul>

<hr />

<h2 id="jpa-내부구조">JPA 내부구조</h2>

<h3 id="영속성-컨텍스트">영속성 컨텍스트</h3>

<ul>
  <li>엔티티를 영구히 저장하는 환경</li>
  <li>영속성 = 영구히 저장하는 속성</li>
  <li><code class="highlighter-rouge">EntityManager.persist(entity)</code></li>
  <li>영속성 컨텍스트는 논리적인 개념 (눈에 보이지 않음)</li>
  <li>엔티티 매니저를 통해 영속성 컨텍스트에 접근</li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/f984194b-1654-4746-8269-a5969585fb7c/image.png" style="zoom:50%;" /></p>

<h4 id="스프링-프레임-워크에서의-영속성-컨텍스트">스프링 프레임 워크에서의 영속성 컨텍스트</h4>

<ul>
  <li>엔티티 매니저와 영속성 컨텍스트가 N:1</li>
  <li>같은 트랜잭션이면 같은 영속성 컨텍스트에 접근</li>
</ul>

<h3 id="엔티티-매니저-팩토리와-엔티티-매니저">엔티티 매니저 팩토리와 엔티티 매니저</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/f229b671-e4ee-4019-980d-be717d3190d3/image.png" style="zoom:50%;" /></p>

<ul>
  <li>
    <p>요청이 들어와 이걸 처리하는 스레드가 하나 생성될 때마다 새로운 엔티티 매니저를 만든다.</p>
  </li>
  <li>
    <p>엔티티 매니저에서 내부적으로 데이터베이스 커넥션 풀에서 JPA를 사용</p>
  </li>
</ul>

<h3 id="엔티티의-생명-주기">엔티티의 생명 주기</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/7ba71a87-a296-4276-8ef5-c8a66a4e1fd2/image.png" style="zoom:50%;" /></p>

<h4 id="비영속-new">비영속 (New)</h4>

<ul>
  <li>객체를 생성한 상태</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Team</span><span class="o">();</span>
<span class="n">team</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"teamA"</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="영속">영속</h4>

<ul>
  <li>비영속 상태인 객체를 영속성 컨텍스트에 저장한 상태</li>
  <li>영속성 컨텍스트 안에서 관리되기 시작</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">team</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="준영속-detached">준영속 (Detached)</h4>

<ul>
  <li>엔티티를 영속성 컨텍스트에서 분리</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">detach</span><span class="o">(</span><span class="n">team</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>영속 -&gt; 준영속</li>
  <li>영속 상태의 엔티티가 영속성 컨텍스트에서 분리</li>
  <li>영속성 컨텍스트가 제공하는 기능을 사용 못함</li>
</ul>

<h5 id="준영속-상태로-만드는-방법">준영속 상태로 만드는 방법</h5>

<ul>
  <li><code class="highlighter-rouge">em.detched(entity)</code> : 특정 엔티티만 준영속 상태로 전환</li>
  <li><code class="highlighter-rouge">em.clear()</code> : 영속성 컨텍스트를 완전히 초기화</li>
  <li><code class="highlighter-rouge">em.close()</code> : 영속성 컨텍스트를 종료</li>
</ul>

<h4 id="삭제">삭제</h4>

<ul>
  <li>객체를 삭제한 상태</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">team</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="영속성-컨텍스트의-이점">영속성 컨텍스트의 이점</h3>

<h4 id="1차-캐시">1차 캐시</h4>

<p><img src="https://images.velog.io/images/new_wisdom/post/1a245e9b-61e8-400d-b492-e194c230a9d9/image.png" style="zoom:33%;" /></p>

<ul>
  <li>엔티티 매니저 안에 키 밸류로 캐시가 됨</li>
</ul>

<h5 id="1차-캐시에서-조회">1차 캐시에서 조회</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Member</span><span class="o">();</span>
<span class="n">member</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"amazzi"</span><span class="o">);</span>
<span class="c1">// 1차 캐시에 저장됨</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
<span class="c1">// 1차 캐시에서 조회</span>
<span class="n">Memeber</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>DB를 가지 않음</li>
  <li>1차 캐시는 Global 캐시가 아님. 트랜잭션 안에서만 동작하는 캐시</li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/dbc6eae5-2881-4d47-9a31-5c3a108e15a3/image.png" style="zoom:50%;" /></p>

<h5 id="데이터-베이스에서-조회">데이터 베이스에서 조회</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Member</span> <span class="n">findMember2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">Member</span><span class="o">.</span><span class="na">classm</span> <span class="s">"member2"</span><span class="o">);</span>
</code></pre></div></div>

<p><img src="https://images.velog.io/images/new_wisdom/post/5b985b9a-1b05-4952-ae28-7e0a0b86482d/image.png" style="zoom:50%;" /></p>

<h4 id="동일성-보장">동일성 보장</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Member</span> <span class="n">a</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
<span class="n">Member</span> <span class="n">b</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>

<span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="c1">// 동일성 비교 true</span>
</code></pre></div></div>

<ul>
  <li>1차 캐시로 반복 가능한 읽기 등급(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 DB 가 아닌 애플리케이션 차원에서 제공</li>
</ul>

<h4 id="트랜잭션을-지원하는-쓰기-지연">트랜잭션을 지원하는 쓰기 지연</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span> <span class="o">=</span> <span class="n">entityManagerFactory</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
<span class="n">EntityTransaction</span> <span class="n">transaction</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
<span class="c1">// 엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 함</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>
  	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>
    <span class="c1">// 여기까지 INSERT 쿼리를 DB에 날리지 않음</span>

    <span class="n">transaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span> <span class="c1">// 트랜잭션 커밋</span>
    <span class="n">em</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
    <span class="n">em</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">transaction</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://images.velog.io/images/new_wisdom/post/1602a866-12c2-43db-b955-ddeb562d306b/image.png" style="zoom:50%;" /></p>

<p><img src="https://images.velog.io/images/new_wisdom/post/7008bed1-7d1b-49fb-9ba6-941a655e617c/image.png" style="zoom:50%;" /></p>

<ul>
  <li>논리적인 개념. 이 때 Insert 쿼리를 쌓아 놓는다.</li>
</ul>

<h5 id="transcationcommit">transcation.commit();</h5>

<p><img src="https://images.velog.io/images/new_wisdom/post/5a364e74-035d-412b-b08c-d88573e6a440/image.png" style="zoom:50%;" /></p>

<h4 id="변경-감지dirty-checking">변경 감지(Dirty Checking)</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span> <span class="o">=</span> <span class="n">entityManagerFactory</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
<span class="n">EntityTransaction</span> <span class="n">transaction</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
<span class="c1">// 엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 함</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
<span class="k">try</span> <span class="o">{</span>
  	<span class="c1">// 영속 엔티티 조회</span>
    <span class="n">Member</span> <span class="n">memberA</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"memberA"</span><span class="o">);</span>
  
    <span class="c1">// 영속 엔티티 데이터 수정</span>
  	<span class="n">memberA</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"hi"</span><span class="o">);</span>
    
    <span class="n">transaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span> <span class="c1">// 트랜잭션 커밋</span>
    <span class="n">em</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span> <span class="c1">// 쿼리를 다 날림</span>
    <span class="n">em</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span> <span class="c1">// 영속성 컨텍스트 안에 있는 캐시를 다 날림</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">transaction</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">em.update(member)</code> 이런 코드가 없어도 됨</li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/0c267388-1e7a-477f-a441-a90e496026e8/image.png" style="zoom:50%;" /></p>

<ul>
  <li>1차 캐시가 생성되는 순간 스냅샷이 생긴다.</li>
  <li>JPA는 트랜잭션이 커밋되는 순간 스냅샷과 1차 캐시의 엔티티를 비교해서 바뀐 놈을 감지한다.</li>
  <li>그래서 update 쿼리를 날림</li>
</ul>

<h5 id="왜-이렇게-했을까">왜 이렇게 했을까?</h5>

<ul>
  <li>자바 컬렉션에서 데이터를 가져오고 이를 변경하면 리스트에 있는 값이 바뀌죠?</li>
  <li>이거랑 같은 맥락</li>
  <li>그래서 바꾸고 커밋만 치면 된다.</li>
</ul>

<h5 id="엔티티-삭제">엔티티 삭제</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 삭제 대산 엔티티 조회</span>
<span class="n">Member</span> <span class="n">memberA</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"memberA"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">memberA</span><span class="o">);</span> <span class="c1">// 엔티티 삭제</span>
</code></pre></div></div>

<ul>
  <li>트랜잭션 커밋 시점에 쿼리가 날라감</li>
  <li>버퍼를 최대한 늦춘다. (트랜잭션 커밋할 때까지)</li>
</ul>

<h4 id="플러시">플러시</h4>

<ul>
  <li>영속성 컨텍스트의 변경 내용을 데이터베이스에 반영</li>
</ul>

<h5 id="플러시가-발생될-때">플러시가 발생될 때</h5>

<ul>
  <li>변경 감지</li>
  <li>수정된 엔티티 쓰기 지연 SQL 저장소에 등록</li>
  <li>쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)</li>
</ul>

<h5 id="플러시하는-방법">플러시하는 방법</h5>

<ul>
  <li>em.flush() : 직접 호출</li>
  <li>트랜잭션 커밋 : 플러시 자동 호출</li>
  <li>JPQL 쿼리 실행 : 플러시 자동 호출</li>
</ul>

<h5 id="jpql-쿼리-실행시-플러시가-자동으로-호출되는-이유">JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberA</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberB</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberC</span><span class="o">);</span>

<span class="c1">// 중간에 JPQL 실행 // 플러시가 먼저 수행된다.</span>
<span class="n">query</span> <span class="o">-</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select m from Member m"</span><span class="o">,</span> <span class="n">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li>쿼리 실행 때 플러시가 안되면 DB에서 조회해올 수 없기 때문</li>
  <li>만약 마이바티스나 JDBC를 사용하면 플러시가 안됨</li>
</ul>

<h5 id="플러시는">플러시는!</h5>

<ul>
  <li>영속성 컨텍스트를 비우지 않음</li>
  <li>영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화</li>
  <li>트랜잭션이라는 작업 단위가 중요 -&gt; 커밋 직전에만 동기화 하면 됨</li>
</ul>

<h4 id="지연-로딩lazy-loading">지연 로딩(Lazy Loading)</h4>

<h5 id="지연로딩과-영속성-컨텍스트">지연로딩과 영속성 컨텍스트</h5>

<ul>
  <li>Member를 조회할 때 Team도 함께 조회해야 할까?</li>
  <li>단순히 member 정보만 사용하는 비즈니스 로직이라면… 미리 조회할 필요가 없겠죠
    <ul>
      <li><code class="highlighter-rouge">member.getName()</code></li>
      <li>이러면 FetchType.Lazy로 지연로딩을 걸자</li>
    </ul>
  </li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/f93c7561-bafc-426e-a29c-d8ffd4a9c38f/image.png" style="zoom: 33%;" /></p>

<ul>
  <li>Member를 조회할 때 Team은 가짜 객체(프록시 객체)가 들어감</li>
</ul>

<h5 id="즉시로딩">즉시로딩</h5>

<ul>
  <li>FetchType.EAGER</li>
  <li>Member를 조회할 때 Team도 함께 조회</li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/c9642d5c-2ea2-4763-908b-f0b3da9a3b75/image.png" style="zoom:33%;" /></p>

<h5 id="프록시와-즉시로딩-주의">프록시와 즉시로딩 주의</h5>

<ul>
  <li>가급적 지연 로딩을 사용</li>
  <li>즉시 로딩을 적용하면 예상하지 못한 SQL이 발생</li>
  <li>즉시 로딩은 JPQL에서 N+1 문제를 일으킴</li>
  <li><code class="highlighter-rouge">@ManyToOne</code>, <code class="highlighter-rouge">@OneToOne</code> 은 기본이 즉시 로딩
    <ul>
      <li>LAZY로 설정하기</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">@OneToMany</code>, <code class="highlighter-rouge">@ManyToMany</code> 는 기본이 지연 로딩</li>
  <li>스프링에서는 트랜잭션이 끝나고 컨트롤러에서 LAZY 로딩 하려고 할 때 문제 생김
    <ul>
      <li><a href="https://github.com/NewWisdom/TIL/issues/26">Open Session In View</a></li>
      <li>와 이게 이제 와닿네</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://www.youtube.com/playlist?list=PL9mhQYIlKEhfpMVndI23RwWTL9-VL-B7U">[토크ON세미나] JPA 프로그래밍 기본기 다지기</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>📋 4. 의존 자동 주입</title>
	  <link>//springbasic4</link>
	  <author></author>
	  <pubDate>2021-05-29T19:18:00+09:00</pubDate>
	  <guid>//springbasic4</guid>
	  <description><![CDATA[
	     <h2 id="autowired-어노테이션을-통한-의존-자동-주입">@Autowired 어노테이션을 통한 의존 자동 주입</h2>

<ul>
  <li>자동 주입 기능을 사용하면 스프링이 알아서 의존 객체를 찾아 주입한다.</li>
  <li>사용 방법은 의존을 주입할 대상에 <code class="highlighter-rouge">@Autowiwred</code> 어노테이션을 붙이면 된다.</li>
  <li>해당 어노테이션이 붙어있으면 스프링이 이를 찾아 필드에 할당한다.</li>
</ul>

<p>**@Autowired를 적용한 대상에 일치하는 빈이 없으면? **</p>

<p>해당 필드에 대한 의존을 충족하지 않는다는 내용과 함께 빈이 존재하지 않는다는 에러 메시지가 출력된다.</p>

<p>**만약 두개 이상이면? **</p>

<p>해당 타입의 빈이 한개가 아닌 여러개를 발견했다는 예외 메시지가 출력된다.</p>

<hr />

<h2 id="qualifier를-이용한-의존-객체-선택">@Qualifier를 이용한 의존 객체 선택</h2>

<ul>
  <li>자동 주입 가능한 빈이 두 개 이상인 경우 자동 주입을 할 빈을 지정하는 방법</li>
</ul>

<h3 id="사용-위치">사용 위치</h3>

<h4 id="bean-을-붙인-빈-설정-메서드">@Bean 을 붙인 빈 설정 메서드</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplicationContextTestResourceQualifier</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
  	<span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"defaultFile"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">File</span> <span class="nf">defaultFile</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">File</span> <span class="n">defaultFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"defaultFile.txt"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">defaultFile</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="autowired에서-자동-주입할-빈을-한정할-때-사용">@Autowired에서 자동 주입할 빈을 한정할 때 사용</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberListPrinter</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="n">MemberDao</span> <span class="n">memberDao</span><span class="o">;</span>
	<span class="kd">private</span> <span class="n">MemberPrinter</span> <span class="n">printer</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">MemberListPrinter</span><span class="o">(</span><span class="n">MemberDao</span> <span class="n">memberDao</span><span class="o">,</span> <span class="n">MemberPrinter</span> <span class="n">printer</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">memberDao</span> <span class="o">=</span> <span class="n">memberDao</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">printer</span> <span class="o">=</span> <span class="n">printer</span><span class="o">;</span>
	<span class="o">}</span>
	
  <span class="nd">@Autowired</span>
  <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"printer"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMemberPrint</span><span class="o">(</span><span class="n">MemberPrinter</span> <span class="n">printer</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">printer</span> <span class="o">=</span> <span class="n">printer</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>@Qualifier의 속성으로 주입할 빈의 후보를 한정한다.</li>
  <li>빈 설정에 해당 어노테이션이 없으면 빈의 이름을 한정자로 지정한다.</li>
</ul>

<hr />

<h2 id="상위하위-타입-관계와-자동-주입">상위/하위 타입 관계와 자동 주입</h2>

<p>MemberPrinter 클래스를 상속한 MeberSummaryPrinter 클래스가 있다고 하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberSummaryPrinter</span> <span class="kd">extends</span> <span class="n">MemberPrinter</span> <span class="o">{</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="n">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
				<span class="s">"회원 정보: 이메일=%s, 이름=%s\n"</span><span class="o">,</span> 
				<span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>그리고 AppCtx 설정에서 <code class="highlighter-rouge">memberPrinter2()</code> 가 의 빈 객체를 설정하도록 변경한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppCtx</span> <span class="o">{</span>
	<span class="c1">// ...</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberPrinter</span> <span class="nf">memberPrinter1</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberPrinter</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberSummaryPrinter</span> <span class="nf">memberPrinter2</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberSummaryPrinter</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">memberPrinter2()</code> 의 빈을 MemberSummaryPrinter으로 변경해도 빈 중복 에러가 발생한다.</li>
  <li>MemberSummaryPrinter는 MemberPrinter 타입에도 할당할 수 있기 때문이다.</li>
  <li>스프링 컨테이너는 MemberPrinter 타입 빈을 자동 주입해야하는 @Autowired를 만나면 `memberPrinter1(), memberPrinter2() 중 어떤 빈을 주입해야하는 지 알 수 없다.</li>
</ul>

<p>이 문제는 두가지 방법으로 처리할 수 있다.</p>

<p><strong>@Qualifier</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nd">@Bean</span>
	<span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"printer"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="n">MemberPrinter</span> <span class="nf">memberPrinter1</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberPrinter</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"summaryPrinter"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="n">MemberSummaryPrinter</span> <span class="nf">memberPrinter2</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberSummaryPrinter</span><span class="o">();</span>
	<span class="o">}</span>
</code></pre></div></div>

<p><strong>MemberListPrinter가 MemberSummaryPrinter를 사용하도록 (Composition)</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberListPrinter</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="n">MemberDao</span> <span class="n">memberDao</span><span class="o">;</span>
	<span class="kd">private</span> <span class="n">MemberPrinter</span> <span class="n">printer</span><span class="o">;</span>

  <span class="c1">// ...</span>
	
	<span class="nd">@Autowired</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMemberPrinter</span><span class="o">(</span><span class="n">MemberSummaryPrinter</span> <span class="n">printer</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">printer</span> <span class="o">=</span> <span class="n">printer</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="autowired의-필수-여부-지정-방법">@Autowired의 필수 여부 지정 방법</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberPrinter</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="n">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">dateTimeFormatter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
					<span class="s">"회원 정보: 아이디=%d, 이메일=%s, 이름=%s, 등록일=%tF\n"</span><span class="o">,</span> 
					<span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span>
					<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getRegisterDateTime</span><span class="o">());</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
					<span class="s">"회원 정보: 아이디=%d, 이메일=%s, 이름=%s, 등록일=%s\n"</span><span class="o">,</span> 
					<span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span>
					<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> 
					<span class="n">dateTimeFormatter</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getRegisterDateTime</span><span class="o">()));</span>
		<span class="o">}</span>
	<span class="o">}</span>
  
 	<span class="nd">@Autowired</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDateFormatter</span><span class="o">(</span><span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
	<span class="o">}</span>

 <span class="c1">// ...</span>
</code></pre></div></div>

<p>dateTimeFormatter가 null인지 여부에 따라 날짜 형식을 바꿔 출력한다.<br />
즉 반드시 <code class="highlighter-rouge">setDateFormatter()</code>를 통해 의존 객체를 주입할 필요가 없다.<br />
하지만 <code class="highlighter-rouge">@Autowired</code>는 해당하는 빈이 존재하지 않으면 예외를 발생시킨다.</p>

<h3 id="autowiredrequired--false">@Autowired(required = false)</h3>

<p>이 경우 <code class="highlighter-rouge">@Autowired(required = false)</code> 설정으로 자동 주입 대상이 필수가 아님을 명시한다.<br />
이러면 매칭되는 빈이 없어도 예외가 발생하지 않고 자동 주입을 수행하지 않는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span><span class="o">(</span><span class="n">required</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDateFormatter</span><span class="o">(</span><span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="optional">Optional</h3>

<p>스프링 5부터는 required 속성 말고, Optional을 사용할 수도 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDateFormatter</span><span class="o">(</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">DateTimeFormatter</span><span class="o">&gt;</span> <span class="n">formatterOpt</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">formatterOpt</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="n">formatterOpt</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
   	<span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="nullable">@Nullable</h3>

<p>해당 어노테이션을 의존 주입 대상 파라미터에 붙이면 세터 메서드를 호출할 때 자동 주입할 빈이 존재할 경우 인자로 받고, 존재하지 않으면 null을 전달한다.<br />
이 어노테이션은 스프링이 제공하는 어노테이션이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDateFormatter</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>required 속성을 false로 할 때와 차이점?</strong></p>

<p>@Nullable 어노테이션을 사용하면 자동 주입할 빈이 존재하지 않아도 세터 메서드가 호출된다.<br />
@Autowired(required = false)의 경우 대상 빈이 존재하지 않을 경우 세터 메서드를 호출하지 않는다.</p>

<p>위의 세가지 방식은 메서드 뿐만 아니라 필드에도 동일하게 적용할 수 있다.</p>

<h3 id="생성자-초기화와-필수-여부-지정-방식-동작">생성자 초기화와 필수 여부 지정 방식 동작</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberPrinter</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">MemberPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">dateTimeFormatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">"yyyy년 MM월 dd일"</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="n">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">dateTimeFormatter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
					<span class="s">"회원 정보: 아이디=%d, 이메일=%s, 이름=%s, 등록일=%tF\n"</span><span class="o">,</span> 
					<span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span>
					<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getRegisterDateTime</span><span class="o">());</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
					<span class="s">"회원 정보: 아이디=%d, 이메일=%s, 이름=%s, 등록일=%s\n"</span><span class="o">,</span> 
					<span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span>
					<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> 
					<span class="n">dateTimeFormatter</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getRegisterDateTime</span><span class="o">()));</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="nd">@Autowired</span><span class="o">(</span><span class="n">required</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDateFormatter</span><span class="o">(</span><span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="autowiredrequired--false일-경우">@Autowired(required = false)일 경우</h4>

<ul>
  <li>dateTimeFormatter에 null을 할당하지 않는다. <code class="highlighter-rouge">setDateFormatter()</code> 가 호출되지 않기 때문이다.</li>
</ul>

<h4 id="nullable-1">@Nullable</h4>

<ul>
  <li>일치하는 빈이 없을 때 기본 생성자에서 초기화해주고 있어도, dateTimeFormatter에 null 값을 할당한다.</li>
</ul>

<hr />

<h2 id="자동-주입과-명시적-의존-주입-간의-관계">자동 주입과 명시적 의존 주입 간의 관계</h2>

	  ]]></description>
	</item>

	<item>
	  <title>📋 3. 스프링 DI</title>
	  <link>//springbasic</link>
	  <author></author>
	  <pubDate>2021-05-28T19:18:00+09:00</pubDate>
	  <guid>//springbasic</guid>
	  <description><![CDATA[
	     <h2 id="스프링은-객체-컨테이너">스프링은 객체 컨테이너</h2>

<h3 id="beanfactory">BeanFactory</h3>

<ul>
  <li>객체 생성과 검색에 대한 기능 정의</li>
  <li><code class="highlighter-rouge">getBean()</code> : 생성된 객체를 검색하는데 필요한 메서드</li>
  <li>객체 검색 이외에도 싱글톤인지 프로토타입 빈인지 확인하는 기능도 있음</li>
</ul>

<h3 id="annotationcontext">AnnotationContext</h3>

<ul>
  <li>메시지, profile, 환경 변수 등을 처리할 수 있는 기능을 추가로 쩡의</li>
</ul>

<hr />

<h2 id="의존이란">의존이란?</h2>

<h2 id="di를-통한-의존-처리">DI를 통한 의존 처리</h2>

<h3 id="의존이란-1">의존이란?</h3>

<ul>
  <li>한 클래스가 다른 클래스의 메서드를 실행할 때 <strong>의존</strong>한다고 표현</li>
  <li>
    <p>변경에 의해 영향을 받는 관계를 의미</p>
  </li>
  <li>DI는 의존하는 객체를 직접 생성하지 않고, 의존 객체를 주입받는 방식을 사용</li>
  <li>DI를 통해 객체를 주입하면 유지보수성이 더 올라간다.</li>
</ul>

<h2 id="스프링의-di-설정">스프링의 DI 설정</h2>

<ul>
  <li>스프링은 DI를 이용해서 객체를 서로 연결해주는 조립기이다.
    <ul>
      <li>특정 타입의 클래스만 생성하는 조립기가 아닌 범용 조립기이다.</li>
    </ul>
  </li>
</ul>

<p><strong>설정 클래스</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppCtx</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">MemberDao</span> <span class="nf">memberDao</span><span class="o">()</span> <span class="o">{</span>
    	<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberDao</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">MemberRegisterService</span> <span class="nf">memberRegSvc</span><span class="o">()</span> <span class="o">{</span>
    	<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberRegisterService</span><span class="o">(</span><span class="n">memberDao</span><span class="o">());</span> <span class="c1">// memberDao()	가 생성한 객체를 주입</span>
    <span class="o">}</span>
    
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">ChangePasswordService</span> <span class="nf">changePwSvc</span><span class="o">()</span> <span class="o">{</span>
    	<span class="n">ChangePasswordService</span> <span class="n">pwsSvc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChangePasswordService</span><span class="o">();</span>
        <span class="n">pwdSvc</span><span class="o">.</span><span class="na">setMemberDao</span><span class="o">(</span><span class="n">memberDao</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">pwdSvc</span><span class="o">;</span>
    
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">@Configuration</code> : 스프링 설정 클래스</li>
  <li><code class="highlighter-rouge">@Bean</code> : 해당 메서드가 생성한 객체를 스프링 빈으로 설정
    <ul>
      <li>메서드 이름을 빈 객체의 이름으로 사용</li>
    </ul>
  </li>
</ul>

<p>설정 클래스만 만들어서 끝나는 것이 아닌, 설정 클래스로 컨테이너를 생성해야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="n">AppCtx</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  
<span class="c1">// ...</span>
<span class="n">MemberRegisterService</span> <span class="n">regSvc</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"memberRegSvc"</span><span class="o">,</span> <span class="n">MemberRegisterService</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</code></pre></div></div>

<ul>
  <li>컨테이너를 생성하면 <code class="highlighter-rouge">getBean()</code> 를 이용해 사용할 객체를 구할 수 있음</li>
  <li>스프링 컨테이너 <code class="highlighter-rouge">ctx</code> 로터 이름이 “memberRegSvc”인 빈 객체를 구함</li>
</ul>

<h3 id="di-방식---생성자-방식">DI 방식 - 생성자 방식</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StationService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">StationDao</span> <span class="n">stationDao</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">StationService</span><span class="o">(</span><span class="n">StationDao</span> <span class="n">stationDao</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">stationDao</span> <span class="o">=</span> <span class="n">stationDao</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="di-방식---생성자-방식-1">DI 방식 - 생성자 방식</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StationService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">StationDao</span> <span class="n">stationDao</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setStationDao</span><span class="o">(</span><span class="n">StationDao</span> <span class="n">stationDao</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">stationDao</span> <span class="o">=</span> <span class="n">stationDao</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<hr />

<h2 id="configuration-설정-클래스의-bean-설정과-싱글톤">@Configuration 설정 클래스의 @Bean 설정과 싱글톤</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppCtx</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">MemberDao</span> <span class="nf">memberDao</span><span class="o">()</span> <span class="o">{</span>
    	<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberDao</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">MemberRegisterService</span> <span class="nf">memberRegSvc</span><span class="o">()</span> <span class="o">{</span>
    	<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberRegisterService</span><span class="o">(</span><span class="n">memberDao</span><span class="o">());</span> <span class="c1">// memberDao()	가 생성한 객체를 주입</span>
    <span class="o">}</span>
    
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">ChangePasswordService</span> <span class="nf">changePwSvc</span><span class="o">()</span> <span class="o">{</span>
    	<span class="n">ChangePasswordService</span> <span class="n">pwsSvc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChangePasswordService</span><span class="o">();</span>
        <span class="n">pwdSvc</span><span class="o">.</span><span class="na">setMemberDao</span><span class="o">(</span><span class="n">memberDao</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">pwdSvc</span><span class="o">;</span>
    
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><code class="highlighter-rouge">memberDao()</code>는 매번 새로운 MemberDao 객체를 생성해서 반환한다.</li>
</ul>

<p><strong>그러면 <code class="highlighter-rouge">memberRegSvc()</code> 가 반환하는 객체와 <code class="highlighter-rouge">changePwSvc()</code>가 반환하는 객체는 서로 다른 MemberDao 객체를 사용하는 것인가?</strong></p>

<p>🙅‍♀️ 스프링 컨테이너가 생성한 빈은 싱글톤 객체이다.<br />
<code class="highlighter-rouge">@Bean</code>이 붙은 메서드에 대해 한 개의 객체만 생성하고 이를 보관했다가, 동일한 객체를 반환한다.</p>

<hr />

<h2 id="두-개-이상의-설정-파일-사용하기">두 개 이상의 설정 파일 사용하기</h2>

<p>스프링은 한 개 이상의 설정 파일을 이용해서 컨테이너를 생성할 수 있다.</p>

<h3 id="configuration-autowired">@Configuration, @Autowired</h3>

<p><strong>AppConf1</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConf1</span> <span class="o">{</span>

	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberDao</span> <span class="nf">memberDao</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberDao</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberPrinter</span> <span class="nf">memberPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberPrinter</span><span class="o">();</span>
	<span class="o">}</span>
	
<span class="o">}</span>
</code></pre></div></div>

<p><strong>AppConf2</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConf2</span> <span class="o">{</span>
	<span class="nd">@Autowired</span>
	<span class="kd">private</span> <span class="n">MemberDao</span> <span class="n">memberDao</span><span class="o">;</span>
	<span class="nd">@Autowired</span>
	<span class="kd">private</span> <span class="n">MemberPrinter</span> <span class="n">memberPrinter</span><span class="o">;</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberRegisterService</span> <span class="nf">memberRegSvc</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberRegisterService</span><span class="o">(</span><span class="n">memberDao</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">ChangePasswordService</span> <span class="nf">changePwdSvc</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">ChangePasswordService</span> <span class="n">pwdSvc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChangePasswordService</span><span class="o">();</span>
		<span class="n">pwdSvc</span><span class="o">.</span><span class="na">setMemberDao</span><span class="o">(</span><span class="n">memberDao</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">pwdSvc</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberListPrinter</span> <span class="nf">listPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberListPrinter</span><span class="o">(</span><span class="n">memberDao</span><span class="o">,</span> <span class="n">memberPrinter</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberInfoPrinter</span> <span class="nf">infoPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">MemberInfoPrinter</span> <span class="n">infoPrinter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MemberInfoPrinter</span><span class="o">();</span>
		<span class="n">infoPrinter</span><span class="o">.</span><span class="na">setMemberDao</span><span class="o">(</span><span class="n">memberDao</span><span class="o">);</span>
		<span class="n">infoPrinter</span><span class="o">.</span><span class="na">setPrinter</span><span class="o">(</span><span class="n">memberPrinter</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">infoPrinter</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">VersionPrinter</span> <span class="nf">versionPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">VersionPrinter</span> <span class="n">versionPrinter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VersionPrinter</span><span class="o">();</span>
		<span class="n">versionPrinter</span><span class="o">.</span><span class="na">setMajorVersion</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
		<span class="n">versionPrinter</span><span class="o">.</span><span class="na">setMinorVersion</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">versionPrinter</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">@AutoWired</code> : 스프링의 자동 주입 기능. 스프링 설정 클래스 필드에 해당 어노테이션을 붙이면 해당 타입 빈을 찾아서 필드에 할당한다.
    <ul>
      <li>AppConf2의 memberDao 필드에는 AppConf1 클래스에서 설정한 빈이 할당된다.</li>
    </ul>
  </li>
  <li>스프링 컨테이너는 AppConf2 객체를 빈으로 등록하고 <code class="highlighter-rouge">@AutoWired</code> 가 붙은 대상에 대해 알맞은 빈을 자동으로 주입한다.</li>
</ul>

<p><strong>설정 클래스가 여러개일 때 스프링 컨테이너를 생성하는 방법은?</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="n">AppConf1</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">AppConf2</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</code></pre></div></div>

<ul>
  <li>AnnotationConfigApplicationContext의 생성자의 인자는 가변 인자이다.</li>
</ul>

<h3 id="import-어노테이션-사용">@Import 어노테이션 사용</h3>

<ul>
  <li>함께 사용할 설정 클래스를 지정</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@Import</span><span class="o">({</span><span class="n">AppConf2</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfImport</span> <span class="o">{</span>

	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberDao</span> <span class="nf">memberDao</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberDao</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberPrinter</span> <span class="nf">memberPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberPrinter</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>지정한 클래스도 함께 사용하기 때문에 스프링 컨테이너를 생성할 때 AppConfi2를 지정할 필요가 없다.</li>
</ul>

<hr />

<h2 id="getbean">getBean()</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VersionPrinter</span> <span class="n">versionPrinter</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"versionPrinter"</span><span class="o">,</span> <span class="n">VersionPrinter</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</code></pre></div></div>

<ul>
  <li>첫번째 인자는 빈의 이름</li>
  <li>두번째 인자는 빈의 타입</li>
  <li>빈의 이름을 지정하지 않고 타입만으로 빈을 구할 수도 있다.
    <ul>
      <li>대신 해당 타입의 빈 객체가 한 개만 존재해야한다.</li>
    </ul>
  </li>
</ul>

<p><strong>주입 대상 객체를 모두 빈 객체로 설정해야하나?</strong></p>

<p>🙅‍♀️ 스프링 컨테이너가 객체를 관리하는지 여부만 다를 뿐이다.<br />
참고로 스프링 컨테이너는 자동 주입, 라이프사이클 관리 등 객체 생성 외에도 객체 관리를 위한 다양한 기능을 제공한다.</p>

	  ]]></description>
	</item>


</channel>
</rss>
