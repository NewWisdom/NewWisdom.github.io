<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>NewWisdom.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>블로그 이사중... 아직 정리가 안되었음...</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>📌 CORS</title>
	  <link>//cors</link>
	  <author></author>
	  <pubDate>2021-06-16T10:01:00+09:00</pubDate>
	  <guid>//cors</guid>
	  <description><![CDATA[
	     <h2 id="배경-지식">배경 지식</h2>

<h3 id="sopsame-origin-policy">SOP(Same Origin Policy)</h3>

<ul>
  <li>다른 출처의 리소스를 사용하는 것에 제한하는 보안 방식</li>
</ul>

<h4 id="왜-sop">왜 SOP?</h4>

<p><img src="https://images.velog.io/images/new_wisdom/post/bc601fec-399d-4762-bd39-f9ec9357b1a7/image.png" alt="" /></p>

<ul>
  <li>CSRF Attack 때문!</li>
  <li>사용자는 인증 토큰을 가지고 있는 상태</li>
  <li>해커가 만든 주소로 이동하는데, 여기다 해커는 악의적인 스크립트를 심음</li>
  <li>해커는 인증 토큰을 가지고 악의적인 스크립트를 실행할 수 있음</li>
  <li>만약 송금이나 민감한 정보를 건드릴 시 굉장히 위험</li>
</ul>

<p><strong>여기서 SOP가 위력을 발휘</strong></p>

<ul>
  <li>웹사이트 입장에서는 자신과 다른 출처를 가지기 때문에 위 요청은 받을 수 없다고 판단</li>
</ul>

<h3 id="출처origin란">출처(Origin)란?</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/c26c3768-a3c4-43dc-930e-da5d4990b1fe/image.png" /></p>

<ul>
  <li><strong>Protocol, Host, Port</strong> 세가지가 같아야 같은 출처라고 판단</li>
  <li>참고로 인터넷 익스플로어는 출처판단에 Port가 포함되지 않음</li>
</ul>

<h4 id="-그러면-다른-출처-리소스가-필요하면-어떻게해">🤔 그러면 다른 출처 리소스가 필요하면 어떻게해??</h4>

<p><img src="https://images.velog.io/images/new_wisdom/post/f352b075-2ea9-46da-83f8-2e862f46154d/image.png" style="zoom:50%;" /></p>

<h4 id="cors">CORS!!</h4>

<hr />

<h2 id="cors란">CORS란?</h2>

<blockquote>
  <p>교차 출처 리소스 공유(Cross-Origin Resource Sharing, CORS)는 추가 HTTP 헤더를 사용하여, 한 출처에서 실행중인 웹 애플리케이션이 다른 <strong>출처의</strong> 선택한 자원에 접근할 수 있는 권한을 부여하도록 <strong>브라우저에</strong> 알려주는 체제입니다. - MOZILLA</p>
</blockquote>

<h2 id="cors-접근제어-시나리오">CORS 접근제어 시나리오</h2>

<h3 id="단순-요청-simple-request">단순 요청 (Simple Request)</h3>

<ul>
  <li>Preflight 요청 없이 바로 요청</li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/12d244c6-c984-4de2-a0df-e147160b6009/image.png" style="zoom:80%;" /></p>

<h4 id="조건을-모두-만족해야-함">조건을 모두 만족해야 함</h4>

<ul>
  <li><strong>메서드는 아래만 허용</strong>
    <ul>
      <li>GET, POST, HEAD</li>
    </ul>
  </li>
  <li><strong>Content-Type은 아래만 허용</strong>
    <ul>
      <li>application/x-www-form-urlencoded</li>
      <li>multipart/form-data</li>
      <li>test/plain</li>
    </ul>
  </li>
  <li><strong>Header는 아래만 허용</strong>
    <ul>
      <li>Accept</li>
      <li>Accept-Language</li>
      <li>Content-Language</li>
      <li>Content-Type</li>
    </ul>
  </li>
</ul>

<h3 id="프리플라이트-요청-preflight-request">프리플라이트 요청 (Preflight Request)</h3>

<ul>
  <li>쉽게 말하자면 사전 확인 작업</li>
  <li>OPTIONS 메서드를 통해 다른 출처의 리소스에 요청이 가능한지 확인하는 작업</li>
  <li>요청이 가능하면 실제 요청(Actual Request)을 보냄</li>
</ul>

<p><img src="https://images.velog.io/images/new_wisdom/post/4034279a-ff4f-4ba6-9e85-ede6e8bdf2f5/image.png" style="zoom: 50%;" /></p>

<ul>
  <li>클라이언트가 사전 요청을 보냄</li>
  <li>서버는 이에 응답</li>
  <li>만약 이 요청이 거부된다면 Actual Request는 보내지 않음</li>
</ul>

<h4 id="preflight-request-포맷">Preflight Request 포맷</h4>

<ul>
  <li><strong>Origin</strong> : 요청 출처</li>
  <li><strong>Access-Control-Request-Method</strong> : 실제 요청의 메서드</li>
  <li><strong>Access-Control-Request-Headers</strong> : 실제 요청의 추가 헤더</li>
</ul>

<h4 id="preflight-response-포맷">Preflight Response 포맷</h4>

<ul>
  <li><strong>Access-Control-Allow-Origin</strong> : 서버 측 허가 출처</li>
  <li><strong>Access-Control-Allow-Methods</strong> : 서버 측 허가 메서드</li>
  <li><strong>Access-Control-Allow-Headers</strong> : 서버 측 허가 헤더</li>
  <li>**Access-Control-Max-Age **: Preflight 응답 캐시 기간
    <ul>
      <li>사전 요청과 실제 요청을 매번 보내면 효율적이지 않으니 브라우저는 사전 요청을 캐싱해둠</li>
    </ul>
  </li>
</ul>

<h5 id="preflight-response-특징">Preflight Response 특징</h5>

<ul>
  <li>응답 코드는 200대여야 함</li>
  <li>응답 바디는 비어있는 것이 좋음</li>
</ul>

<h4 id="왜-preflight가-필요할까">왜 Preflight가 필요할까?</h4>

<ul>
  <li>
    <p>사전 요청이 없으면 서버는 요청에 대해 모든 로직을 일단 수행함</p>
  </li>
  <li>
    <p>그리고 나서 Origin을 판단</p>
  </li>
  <li>
    <p>일단 로직이 수행된 후 CORS 이슈가 발생</p>
  </li>
  <li>
    <p>사전 요청이 있으면 요청을 수행하기 전 Origin을 판단</p>
  </li>
  <li>
    <p>때문에 서버는 안전히 잘 지켜짐</p>
  </li>
</ul>

<h4 id="인증정보-포함-요청-credentialed-request">인증정보 포함 요청 (Credentialed Request)</h4>

<ul>
  <li>인증 관련 헤더를 포함할 때 사용하는 요청</li>
  <li><strong>클라이언트 측</strong>
    <ul>
      <li><code class="highlighter-rouge">credentials : include</code></li>
    </ul>
  </li>
  <li>서버 측
    <ul>
      <li><code class="highlighter-rouge">Access-Control-Allow-Credentials : true</code></li>
      <li>대신 이러면 아래와 같은 조건이 충족되어야 함</li>
    </ul>
  </li>
</ul>

<h5 id="조건">조건</h5>

<ul>
  <li><code class="highlighter-rouge">Access-Control-Allow-Origin</code>에는 <code class="highlighter-rouge">*</code>를 사용할 수 없으며, 명시적인 URL이어야함</li>
  <li>응답 헤더에는 반드시 <code class="highlighter-rouge">Access-Control-Allow-Credentials: true</code>가 존재해야함</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🚨 Access to fetch at ’https://localhost:8080’ from origin ’http://localhost:8000’ has been blocked by CORS policy: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ’*’ when the request’s credentials mode is ‘include’.
</code></pre></div></div>

<h2 id="cors-해결하기">CORS 해결하기!</h2>

<h3 id="프론트-프록시-서버-설정개발-환경">프론트 프록시 서버 설정(개발 환경)</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/d6ab0645-2430-405f-b6c5-4475762a9820/image.png" style="zoom:67%;" /></p>

<ul>
  <li>브라우저 입장에서는 origin과 target이 같기 때문에 <code class="highlighter-rouge">same origin</code></li>
</ul>

<h4 id="추가">추가</h4>

<ul>
  <li><a href="https://github.com/NewWisdom/TIL/issues/54">내가 CORS 이슈를 해결한 방법 - Proxy </a></li>
</ul>

<h3 id="스프링-부트-이용">스프링 부트 이용</h3>

<h4 id="crossorigin-어노테이션-사용">@CrossOrigin 어노테이션 사용</h4>

<p><img src="https://images.velog.io/images/new_wisdom/post/15daecfe-b6be-4cdf-9147-19f01497859f/image.png" style="zoom:50%;" /></p>

<h5 id="참고">참고</h5>

<p><img src="https://images.velog.io/images/new_wisdom/post/f908b312-5120-45f4-84f9-0bd36c0c4129/image.png" style="zoom:50%;" /></p>

<ul>
  <li>Origin을 설정 안해주면 Default 값으로 모든 Origin을 허용함</li>
  <li>때문에 설정해주는 것이 좋음</li>
</ul>

<h4 id="전역으로-설정하는-방법---config">전역으로 설정하는 방법 - Config</h4>

<p><img src="https://images.velog.io/images/new_wisdom/post/fd4ee87d-b269-453b-9e68-889a10f2c6c3/image.png" style="zoom: 50%;" /></p>

<hr />

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=-2TgkKYmJt4&amp;t=15s">[10분 테코톡] 🌳 나봄의 CORS</a></li>
  <li><a href="https://evan-moon.github.io/2020/05/21/about-cors/#credentialed-request">CORS는 왜 이렇게 우리를 힘들게 하는걸까?</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>📌 시간 복잡도</title>
	  <link>//time</link>
	  <author></author>
	  <pubDate>2021-06-01T19:18:00+09:00</pubDate>
	  <guid>//time</guid>
	  <description><![CDATA[
	     <h3 id="알고리즘이란">알고리즘이란?</h3>

<ul>
  <li>문제를 해결하기 위한 방법</li>
</ul>

<h3 id="예시">예시</h3>

<h4 id="건너뛰기-혹은-살펴보기-전략">건너뛰기 혹은 살펴보기 전략</h4>

<ul>
  <li>자취방 구하기</li>
  <li>맛있는 음식점 찾아다니기</li>
  <li>마음에 드는 옷 고르기</li>
</ul>

<h3 id="시간-복잡도">시간 복잡도</h3>

<ul>
  <li>문제를 해결하는데 걸리는 시간과 입력의 함수 관계</li>
  <li>계산법 = 핵심이 되는 연산이 무엇일까?</li>
  <li>항상 최악의 경우를 시간복잡도로 쓴다.</li>
  <li>최선의 경우는 어떤 알고리즘을 써도 만족스러운 경우가 나오기 때문에 최악의 경우를 시간복잡도로 사용</li>
</ul>

<h4 id="현실적-알고리즘">현실적 알고리즘</h4>

<ul>
  <li>Polynomial complexity (P 문제)</li>
  <li>sorting. dp</li>
</ul>

<h4 id="비현실적-알고리즘">비현실적 알고리즘</h4>

<ul>
  <li>Nondeterministic Polynomial complexity (NP 문제)</li>
  <li>소인수 분해 문제
    <ul>
      <li>ex) 21이 어떤 수들의 곱인지 구하는 것은 오래걸림</li>
      <li>q와 p의 곱을 n이라하고 이를 공개키로 둔다.</li>
    </ul>
  </li>
  <li>해밀턴 경로 문제</li>
  <li>컴퓨터로도 풀 수 없다</li>
  <li>너무 오래 걸려</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>📌 Cache</title>
	  <link>//cache</link>
	  <author></author>
	  <pubDate>2021-05-31T19:18:00+09:00</pubDate>
	  <guid>//cache</guid>
	  <description><![CDATA[
	     <h3 id="메모리-계층-구조">메모리 계층 구조</h3>

<ul>
  <li>데이터를 저장하는 공간의 속도와 용량은 반비례
    <ul>
      <li>빠를수록 가격이 올라간다.</li>
    </ul>
  </li>
  <li>용량이 큰 저장장치는 속도가 느림</li>
  <li>둘 다 잡기엔 비용이 너무 많이 듦</li>
</ul>

<h3 id="파레토의-법칙">파레토의 법칙</h3>

<ul>
  <li>원인 중 상위 20%가 전체 결과의 80%를 만든다.</li>
  <li>많이 쓰는 20%가 80%의 효율을 차지한다.</li>
</ul>

<h3 id="데이터-지역성의-원리">데이터 지역성의 원리</h3>

<ul>
  <li>자주 쓰는 데이터는 시간적 혹은 공간적으로 한 곳에 몰려있을 가능성이 높음</li>
  <li><strong>시간 지역성</strong>
    <ul>
      <li>for문에 조건 변수를 선언하면 해당 변수는 for문이 끝나기 전까지 계속 쓰일 확률이 높음</li>
    </ul>
  </li>
  <li><strong>공간 지역성</strong>
    <ul>
      <li>for문에서 어떤 배열에 접근했을 때 해당 배열이 위치한 메모리 공간의 내용은 for문이 끝나기 전까지 계속 쓰일 확률이 높음</li>
      <li>순차 지역성이라고 부르기도 함(arr[0], arr[1] 다음에는 arr[3]에 접근할 확률이 높을 것을 따로 분류하기도 함)</li>
      <li>ex) 창고의 모든 종이를 한번에 미리 책상위로 가져오면 효율이 좋다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="cache">Cache</h2>

<ul>
  <li>나중에 필요할 수 있는 무언가를 저장했다가 신속하게 회수할 수 있는 보관</li>
  <li>원본 데이터를 빠르게 저장할 수 있는 메모리에 저장한다.</li>
  <li>낮은 시간 복잡도로 접근 가능한 곳에 주로 저장한다.
    <ul>
      <li>ex) 자바의 HashMap</li>
    </ul>
  </li>
  <li>원하는 데이터가 없거나 최신성을 잃은 경우 그때서야 원본 데이터가 있는 곳에 접근해 데이터를 가져온다.
    <ul>
      <li>최신성을 잃었다는 프로그래머가 정해주는 것</li>
    </ul>
  </li>
  <li>원하는 데이터가 있으면 캐시에서 바로 해당 데이처를 제공한다. (Cache Hit)</li>
  <li>캐시 공간은 작으니 안쓰는 데이터부터 삭제한다.</li>
</ul>

<h3 id="example">Example</h3>

<h4 id="cpu">CPU</h4>

<ul>
  <li>1초에 최고 수십억번 작동 각능</li>
  <li>아무리 빠른 주기억장치라도 CPU를 따라가기 어려움</li>
  <li>그래서 SRAM이라는 특수한 메모리를 CPU에 넣어 캐시 메모리로 사용</li>
</ul>

<h4 id="하드-디스크-데이터베이스">하드 디스크, 데이터베이스</h4>

<ul>
  <li>하드디스크는 주기억장치에 비해 10만배 느림</li>
  <li>처리 효율을 올리려면 자주 쓰이는 데이터를 캐싱하는 것이 좋다.</li>
  <li>JPA의 영속성 컨텍스트</li>
</ul>

<h4 id="youtube">Youtube</h4>

<ul>
  <li>미국에 서버가 있으니 Google Global Cache를 두어 인기 동영사는 국내 서버가 처리하도록 함</li>
  <li>이처럼 세계 각지에 캐시 서버를 두는 것이 CDN</li>
</ul>

<h4 id="웹-캐시">웹 캐시</h4>

<ul>
  <li>네트워크를 통해 데이터를 가져오는 것은 하드 디스크보다 느릴 때도 많다.</li>
  <li>웹 브라우저에서는 정적 파일을 하드디스크나 메모리에 캐싱해뒀다가 다음번에 이를 재활용한다.</li>
  <li>동적 페이지 경우 매번 내용이 바뀌지 않는 경우가 더 많으므로 서버에서 생성한 HTML을 캐싱한다.</li>
  <li>클라이언트에서 자주 요청하는 내용은 웹 서버로 전달하지 않고 웹 서버 앞단 프록시 서버에서 캐싱해둔 데이터를 바로 제공한다. (프록시 캐시)</li>
</ul>

<h4 id="브라우저-캐시">브라우저 캐시</h4>

<ul>
  <li>웹 서버에서 클라이언트에 보내는 HTTP 헤더에 캐시 지시사를 삽입해 브라우저에서 이에 따른 캐싱 정책을 실시한다.</li>
  <li>캐시 유효시간 (max-age)가 지나도 캐시 데이터가 바뀌지 않은 경우를 확인하기 위해 ETag라는 유효성 검사 토큰을 사용한다.</li>
  <li>캐싱 정책은 웹페이지 전반적 상황에 따라 각 파일마다 다르게 적용되야 함
    <ul>
      <li>정적 파일과 동적 부분의 브라우저 캐싱 정책은 달라야함</li>
    </ul>
  </li>
</ul>

<h4 id="redisremote-dictionary-server">Redis(Remote Dictionary Server)</h4>

<ul>
  <li>메모리 기반 NoSQL DBMS의 일종으로 웹 서비스에서 캐싱을 위해 많이 씀</li>
  <li>Dictionary Server는 자바의 HashMap과 유사하다.</li>
  <li>기본적으로 모든 데이터를 메모리에 저장</li>
  <li>재부팅 때 메모리가 휘발되지 않게 데이터를 하드디스크에 기록할 수 있음</li>
  <li>DBMS 일종이므로 명시적 삭제하지 않는 한 메모리에서 삭제하지 않음</li>
</ul>

<h4 id="ehcache">EHcache</h4>

<ul>
  <li>자바 표준 캐싱 API 명세인 JSR-107을 따르는 오픈소스 캐시 구현체</li>
  <li>Spring 프레임워크나 Hibernate ORM 등에서 바로 사용 가능</li>
  <li>캐시 저장 공간을 속도에 따라 여러 등급으로 나누어 메모리 계층 구조 적용 가능</li>
  <li>하드디스크에 기록 가능</li>
</ul>

<hr />

<h3 id="참고자료">참고자료</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=c33ojJ7kE7M">[10분 테코톡] 🐻큰곰의 Cache</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>📌 SpringBoot Auto Configuration</title>
	  <link>//springconfiguration</link>
	  <author></author>
	  <pubDate>2021-05-27T19:18:00+09:00</pubDate>
	  <guid>//springconfiguration</guid>
	  <description><![CDATA[
	     <h2 id="테코톡을-보고-추가로-학습한-내용들">테코톡을 보고 추가로 학습한 내용들</h2>

<p>스프링 부트는 component-scan을 통해 component를 찾고 bean을 생성한다.<br />
이 과정에서 우리가 설정한 bean들이 생성된다.<br />
그리고 이 과정에서 spring boot의 auto configuration에 의해 추가적인 bean들도 함께 생성된다.</p>

<h3 id="spring-boot-autoconfiguration이란">Spring Boot AutoConfiguration이란?</h3>

<ul>
  <li>클래스 패스에 존재하는 dependecy를 기반으로 spring 애플리케이션을 자동으로 구성하는 방법</li>
  <li>스프링 부트는 web, h2, jdbc등 여러 자동 설정을 제공 (starter)</li>
  <li>특정 Bean을 정의할 필요 없기 때문에 개발이 더 빠르고 쉬워짐</li>
  <li>스프링부트에선 <code class="highlighter-rouge">@SpringBootApplication</code>에 있는 <code class="highlighter-rouge">EnableAutoConfiguration</code> 로 가능</li>
</ul>

<h3 id="springbootautoconfiguration">@SpringBootAutoConfiguration</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/024b6568-3a66-4a6f-b4c3-1eaeee3ea27d/image.png" style="zoom: 50%;" /></p>

<ul>
  <li><code class="highlighter-rouge">@SpringBootConfiguration</code> : 스프링의 <code class="highlighter-rouge">@Configuration</code>을 대체하는 스프링 부트 전용 설정 어노테이션</li>
  <li><code class="highlighter-rouge">@EnableAutoConfiguration</code> : auto configuration 기능을 사용하겠다는 설정. 클래스 패스에 지정된 내용을 기반으로 설정을 자동화. 일반적으로 <code class="highlighter-rouge">@ComponentScan</code> 와 함께 쓰임</li>
</ul>

<p><strong>그런데 우리가 정의한 Bean과 Spring Boot가 정의한 Bean이 충돌하면? 또한 불필요한 Bean들도 같이 생성된다면?</strong></p>

<p><code class="highlighter-rouge">@Condition</code>과 <code class="highlighter-rouge">@ConditionalOnXxx</code>을 이용해서 이와 같은 문제를 해결한다.</p>

<h3 id="springfactories">spring.factories</h3>

<p>위의 두 어노테이션을 살펴보기 전에 auto configuration에 필요한 파일들을 살펴보자.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/0e864065-e901-4be2-a736-ba56b5d7e8c6/image.png" style="zoom:33%;" /></p>

<h4 id="auto-configure">Auto Configure</h4>

<p><img src="https://images.velog.io/images/new_wisdom/post/06db6a39-a4bd-40f3-bb11-cbd13c55994b/image.png" style="zoom: 50%;" /></p>

<p><code class="highlighter-rouge">spring-boot-autoconfigure/META-INF/spring.factories</code> 에는 스프링 부트가 미리 정의해둔 auto configuration 정보가 들어있다.<br />
여기에는 자동 설정의 target 클래스 목록들이 나열되어 있고, 여기에 선언된 클래스들이 <code class="highlighter-rouge">@EnableConfiguration</code> 사용 시 target이 된다.</p>

<h3 id="conditional-conditionalonxxx">@Conditional? @ConditionalOnXxx?</h3>

<ul>
  <li>Sprig 4.0부터 추가된 어노테이션</li>
</ul>

<p><code class="highlighter-rouge">spring.factories</code> 에 있는 클래스들 중 익숙한 <code class="highlighter-rouge">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</code> 를 예시로 보자.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/a41c8243-04ba-424e-b466-c592dd5502b1/image.png" alt="" /></p>

<ul>
  <li><code class="highlighter-rouge">@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })</code> 설정을 통해 해당 클래스 파일이 존재해야 설정을 활성화 함을 명시</li>
  <li><code class="highlighter-rouge">@ConditionalOnMissingBean(type = "io.r2dbc.spi.ConnectionFactory")</code> 설정을 통해 해당 Bean이 존재하지 않을 경우 설정을 활성화 함을 명시</li>
</ul>

<p>이러한 설정들 덕분에 <code class="highlighter-rouge">우리가 정의한 Bean과 Spring Boot가 정의한 Bean이 충돌하는 문제, 불필요한 Bean들이 생성되는 문제 등</code>을 해결할 수 있다.</p>

<h4 id="autoconfigurationimportfilter">AutoConfigurationImportFilter</h4>

<p>그런데 사실 auto configuration에서 이 <code class="highlighter-rouge">@Condition</code> 을 무조건 타는 것이 아니다.<br />
<code class="highlighter-rouge">spring.factories</code> 에는 <code class="highlighter-rouge">AutoConfigurationImportFilter</code> 설정이 존재한다.<br />
아래와 같은 필터들은 각 AutoConfiguration이 가진 <code class="highlighter-rouge">@Conditional</code> 을 가지고 조건을 만족하는지 필터링을 수행한다.<br />
조건이 맞지 않을 경우, AutoConfiguration이 동작하지 않도록 제외시키는 역할을 한다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/6180dd11-d6e2-4e23-9146-da32cbaaba32/image.png" style="zoom: 50%;" /></p>

<ul>
  <li><strong>OnBeanCondition</strong> : 특정 bean들의 존재유무에 대해서 다루는 필터
    <ul>
      <li><code class="highlighter-rouge">@ConditionalOnBean, @ConditionalOnMissingBean, @ConditionalOnSingleCandidate</code></li>
    </ul>
  </li>
  <li><strong>OnClassCondition</strong> : 특정 class들의 존재유무에 대해서 다루는 필터
    <ul>
      <li><code class="highlighter-rouge">@ConditionalOnClass, @ConditionalOnMissingClass</code></li>
    </ul>
  </li>
  <li><strong>OnWebApplicationCondition</strong> : WebApplicationContext의 존재유무에 대해서 다루는 필터
    <ul>
      <li><code class="highlighter-rouge">@ConditionalOnWebApplication, @ConditionalOnNotWebApplication</code></li>
    </ul>
  </li>
</ul>

<p><strong>그렇다면 이 자동 설정들은 어떻게 불러와질까?</strong></p>

<h3 id="importautoconfigurationimportselectorclass">@Import(AutoConfigurationImportSelector.class)</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/024b6568-3a66-4a6f-b4c3-1eaeee3ea27d/image.png" style="zoom: 50%;" /></p>

<p><code class="highlighter-rouge">@SpringbootApplication</code> 어노테이션 내부에 있던 <code class="highlighter-rouge">@Import(AutoConfigurationImportSelector.class)</code> 는 자동 설정을 지원해주며, import하고 있는 AutoConfigurationImportSelector.class가 <code class="highlighter-rouge">META-INF/spring.factories</code> 에 정의된 자동 설정할 클래스들을 불러온다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📌 MVC 패턴</title>
	  <link>//mvc-pattern</link>
	  <author></author>
	  <pubDate>2021-05-26T19:18:00+09:00</pubDate>
	  <guid>//mvc-pattern</guid>
	  <description><![CDATA[
	     <h2 id="mvc-패턴">MVC 패턴</h2>

<ul>
  <li>디자인 패턴</li>
  <li>Model View Controller 3가지로 구분한 패턴</li>
  <li>유지보수가 편해지는 코드 구성 방식</li>
</ul>

<h2 id="웹-애플리케이션-아키텍쳐의-역사">웹 애플리케이션 아키텍쳐의 역사</h2>

<h3 id="jsp로-구성한-웹-애플리케이션의-아키텍쳐--모델1">(JSP로 구성한) 웹 애플리케이션의 아키텍쳐 : 모델1</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/6a9d8528-65ae-4e83-be32-c2d033b36fab/image.png" style="zoom:67%;" /></p>

<ul>
  <li>구성 : JSP + JavaBeand(Service)</li>
  <li>뷰와 로직이 섞임</li>
  <li>장점 : 구조가 단순</li>
  <li>단점 : 출력과 로직 코드가 섞여 유지보수가 어렵다.</li>
</ul>

<h3 id="jsp로-구성한-웹-애플리케이션의-아키텍쳐--모델2">(JSP로 구성한) 웹 애플리케이션의 아키텍쳐 : 모델2</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/07291db1-f256-4786-b4ac-7e9fe76049de/image.png" style="zoom:67%;" /></p>

<ul>
  <li>구성 : JavaBean(Service) + JSP + 서블릿</li>
  <li>MVC 구조</li>
  <li>장점 : 뷰와 로직이 분리되어 유지보수가 쉽다.</li>
  <li>단점 : 복잡하므로 작은 프로젝트에서는 오히려 과할 수 있다.</li>
</ul>

<hr />

<h3 id="mvc-흐름">MVC 흐름</h3>

<ol>
  <li>사용자는 원하는 기능을 처리하기 위한 모든 요청을 컨트롤러에 보낸다.</li>
  <li>컨트롤러는 모델을 사용하고, 모델은 알맞은 비즈니스 로직을 수행한다.</li>
  <li>컨트롤러는 가용자에게 보여줄 뷰를 선택한다.</li>
  <li>선택된 뷰는 사용자에게 알맞는 결과 화면을 보여준다. 이 때 사용자에게 보여줄 데이터는 컨트롤러를 통해서 전달받는다.</li>
</ol>

<h3 id="model">Model</h3>

<ul>
  <li>값과 기능을 가지고 있는 객체</li>
  <li>비즈니스 로직을 수행</li>
</ul>

<h3 id="view">View</h3>

<ul>
  <li>모델에 포함된 데이터의 시각화</li>
</ul>

<h3 id="controller">Controller</h3>

<ul>
  <li>모델 객체로의 데이터 흐름을 제어</li>
  <li>모델과 뷰의 중개자 역할</li>
  <li>뷰와 모델의 역할을 분리</li>
</ul>

<h3 id="why-mvc">Why MVC?</h3>

<ul>
  <li>각 컨포넌트의 코드 결합도를 낮출 수 있음</li>
  <li>코드의 재사용성을 높일 수 있음</li>
  <li>구현자들 간의 커뮤니케이션 효율성을 높일 수 있음</li>
</ul>

<hr />

<h2 id="mvc-많이-실수하는-부분들">MVC 많이 실수하는 부분들…</h2>

<h3 id="model에서-view의-접근-또는-역할-수행">Model에서 View의 접근 또는 역할 수행</h3>

<ul>
  <li>도메인에서 비즈니스 로직이 아닌 출력에 대한 로직은 별도로 분리하자
    <ul>
      <li>ex) toString()</li>
    </ul>
  </li>
</ul>

<h4 id="view에서-일어나는-과한-값-검증과-예외처리">View에서 일어나는 과한 값 검증과 예외처리</h4>

<ul>
  <li>View에서 검증을 하면 뒤의 로직은 신경쓰지 않아도 되니 편리하다고는 느낄 수 있음</li>
  <li>하지만 단일 책임 원칙을 위반함 (입력 채널이 달라질 경우 유효성 테크 로직도 옮겨야함)</li>
  <li>값 형식은 유효하지만, 도메인 모델에서 확인해야할 부분들은 생성자에서 체크
    <ul>
      <li>ex) 이름은 몇 글자 이상이어야 한다.</li>
    </ul>
  </li>
</ul>

<h4 id="view에서-일어나는-비즈니스-로직">View에서 일어나는 비즈니스 로직</h4>

<ul>
  <li>모델을 생성하거나 모델끼리 연산을 하는 로직</li>
</ul>

<h4 id="controller는-최대한-가볍게">Controller는 최대한 가볍게</h4>

<ul>
  <li>로직은 최대한 배제하고 model과 view의 연결 역할만 하도록 구현</li>
</ul>

<h3 id="service의-등장-지금은-이런게-있구나-정도만-">Service의 등장 (지금은 이런게 있구나 정도만 )</h3>

<h4 id="controller에서-중복이-발생한다">Controller에서 중복이 발생한다.</h4>

<ul>
  <li>별도의 객체로 분리</li>
  <li>별도의 메서드로 분이</li>
</ul>

<p>이러다 서비스 레이어가 추가되었다!</p>

<h3 id="service란">Service란?</h3>

<ul>
  <li>비즈니스 로직을 수행하는 메서드를 가지고 있는 객체</li>
  <li>비즈니스 메서드를 별도의 서비스 객체에서 구현하도록 하고 컨트롤러는 서비스 객체를 사용</li>
  <li>하나의 트랜잭션을 가짐</li>
</ul>

<hr />

<h2 id="mvc를-지키면서-코딩하는-방법">MVC를 지키면서 코딩하는 방법</h2>

<h3 id="model은-controller와-view에-의존하지-않아야-한다">Model은 Controller와 View에 의존하지 않아야 한다.</h3>

<ul>
  <li>Model 내부에 Controller와 View에 관련된 코드가 있으면 안됨</li>
  <li>model은 데이터와 관련된 코드이니 언제든지 정제된 코드만 꺼내쓸 수 있도록</li>
</ul>

<h3 id="view는-model에만-의존해야하고-controller에-의존하면-안된다">View는 Model에만 의존해야하고, Controller에 의존하면 안된다.</h3>

<ul>
  <li>View 내부에 Model의 코드만 있을 수 있고, Controller의 코드가 있으면 안됨</li>
</ul>

<h3 id="vuew가-model로부터-데이터를-받을-때는-사용자마다-다르게-보여주어야-하는-데이터에-대해서만-받아야-함">Vuew가 Model로부터 데이터를 받을 때는 사용자마다 다르게 보여주어야 하는 데이터에 대해서만 받아야 함</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/c0d6e97c-ad21-4276-be29-6a32d23e6544/image.png" style="zoom: 33%;" /></p>

<p>빨간 부분이 사용자마다 다르게 보여져야하는 부분이다.</p>

<p>또는 자동차 경주 게임에서 <code class="highlighter-rouge">-</code>(대시) 같은 경우</p>

<p><strong>View는 사용자한테 보이는 UI와 모델로부터 받은 데이터가 합쳐지는 부분이다.</strong></p>

<h3 id="controller는-model과-view에-의존해도-된다">Controller는 Model과 View에 의존해도 된다.</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/e1c75904-1aee-4eca-b71d-14d23f3d25cd/image.png" style="zoom:33%;" /></p>

<ul>
  <li>Controller 내부에는 Model과 View의 코드가 있을 수 있다.</li>
</ul>

<h3 id="view가-model로부터-데이터를-받을-때-반드시-controller에서-받아야-한다">View가 Model로부터 데이터를 받을 때, 반드시 Controller에서 받아야 한다.</h3>

<hr />

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=ogaXW6KPc8I">[10분 테코톡] 🧀 제리의 MVC 패턴</a></li>
  <li><a href="https://www.youtube.com/watch?v=uoVNJkyXX0I&amp;t=161s">[10분 테코톡] 👩🏻‍💻👨🏻‍💻해리&amp;션의 MVC 패턴</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>📌 DTO와 VO</title>
	  <link>//dto-and-vo</link>
	  <author></author>
	  <pubDate>2021-05-26T19:18:00+09:00</pubDate>
	  <guid>//dto-and-vo</guid>
	  <description><![CDATA[
	     <h2 id="dto">DTO</h2>

<ul>
  <li>Data Transfer Object (데이터 전송 객체)</li>
  <li>계층 간 데이터 교환을 위해 사용하는 객체</li>
  <li>로직을 갖고 있지 않은 순수한 데이터 객체</li>
  <li>데이터를 전송하는 바구니</li>
  <li>getter/setter 메서드만을 가짐</li>
</ul>

<hr />

<h2 id="vo">VO</h2>

<ul>
  <li>value Object (값 객체)</li>
  <li>값 그 자체를 표현하는 객체</li>
  <li>서로 다른 이름을 가진 VO의 인스턴스가 모든 속성 값이 같다면 같은 객체</li>
  <li>equals / hashCode를 오버라이드 필수</li>
  <li>객체의 불변성을 보장</li>
  <li>로직을 포함할 수 있음</li>
</ul>

<hr />

<h2 id="dto-vs-vo">DTO VS VO</h2>

<p>웹 개발에서 사용하는 VO는 사실 DTO이다.<br />
혼동의 원인은..?</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/59d6ae10-7b6d-4ab6-b99a-10266f2627ff/image.png" style="zoom:50%;" /></p>

<p>이 책에서 getter와 setter가 있고, 데이터 전송을 위해 사용하는 객체는 VO라고 정의해버렸다.<br />
(후에는 변경되었긴했지만)</p>

<h4 id="dto를-vo처럼-불변-객체로-사용하면-얻을-수-있는-이점">DTO를 VO처럼 불변 객체로 사용하면 얻을 수 있는 이점?</h4>

<p>DTO가 전송하고자 하는 데이터가 전송 과정 중 변조되지 않음을 보장할 수 있음</p>

<hr />

<h2 id="entity">Entity</h2>

<ul>
  <li>실제 DB의 테이블과 매핑되는 클래스</li>
  <li>id로 구분</li>
  <li>로직을 포함할 수 있음</li>
</ul>

<h4 id="entity를-dto대신-사용할-수-있지-않을까">Entity를 DTO대신 사용할 수 있지 않을까?</h4>

<p>사용할수는 있지만, <br />
View에서 표현하는 속성값들이 요청에 따라 계속 달라질 수 있는데,<br />
 그 때마다 Entity의 속성값을 변경하면 영속성 모델을 표현한 Entity의 순수성이 모호해지기 때문에 Controller에 쓸 DTO와 Entity 클래스는 분리하는 것이 좋다.</p>

<hr />

<h2 id="정리">정리</h2>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>DTO</th>
      <th>VO</th>
      <th>Entity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>용도</td>
      <td>레이어 간의 데이터 전송</td>
      <td>의미 있는 값을 표현</td>
      <td>DB 테이블과 매핑되는 클래스</td>
    </tr>
    <tr>
      <td>가변 / 불변</td>
      <td>가변 객체</td>
      <td>불변 객체</td>
      <td>가변 객체</td>
    </tr>
    <tr>
      <td>로직 포함 여부</td>
      <td>로직을 포함할 수 없음</td>
      <td>로직을 포함할 수 있음`</td>
      <td>로직을 포함할 수 없음</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="추가----dto를-어디-계층까지-사용하여야-할까">추가 -  DTO를 어디 계층까지 사용하여야 할까</h2>

<h3 id="서비스-레이어가-가장-적합하다고-생각한다">서비스 레이어가 가장 적합하다고 생각한다</h3>

<h4 id="service-레이어의-정의">Service 레이어의 정의</h4>

<ul>
  <li>어플리케이션의 경계를 정의하고 비즈니스 로직 등 도메인을 캡슐화하는 역할</li>
  <li>즉 도메인을 보호</li>
  <li>도메인을 표현 계층에서 사용할 경우 결합도가 증가하여 도메인 변경이 Controller의 변경을 촉발한다.</li>
  <li>이는 유지보수의 문제로도 이어질 수 있다.</li>
</ul>

<h4 id="controller가-dto를-생성하면-생기는-문제">Controller가 DTO를 생성하면 생기는 문제</h4>

<ul>
  <li>Controller가 DTO를 완벽하게 도메인에서 객체로 구성한 뒤 서비스에게 넘겨주려면 복잡한 경우 Controller가 여러 서비스나 Repository에 의존하게 된다.</li>
  <li>Controller가 여러 도메인 객체들의 정보를 조합해서 DTO를 생성해야하는 경우 결국 Service 로직이 Controller에 포함되게 된다.</li>
</ul>

<hr />

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=J_Dr6R0Ov8E&amp;t=4s">[10분 테코톡] 🎼라흐의 DTO vs VO</a></li>
  <li><a href="https://woowacourse.github.io/javable/post/2021-04-25-dto-layer-scope/">DTO의 사용 범위에 대하여</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>📌 전략패턴</title>
	  <link>//ocp-stretegy-pattern</link>
	  <author></author>
	  <pubDate>2021-05-24T19:18:00+09:00</pubDate>
	  <guid>//ocp-stretegy-pattern</guid>
	  <description><![CDATA[
	     <h3 id="if---else의-문제점">if - else의 문제점</h3>

<p><strong>example</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculate</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">isFirstGuest</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isLastGuest</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">Item</span> <span class="n">item</span> <span class="o">:</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isFirstGuest</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.9</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">item</span><span class="o">.</span><span class="na">isFresh</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.8</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">isFirstGuest</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.8</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="기능이-추가될-경우">기능이 추가될 경우</h4>

<ul>
  <li>새로운 조건문을 직접 추가해주어야 한다.</li>
  <li>때문에 추가되는 기능들이 많아질 수롣 코드 블럭도 점점 증가한다.</li>
  <li>이럴 경우 유지보수성이 떨어진다.</li>
</ul>

<h4 id="누락될-위험">누락될 위험</h4>

<ul>
  <li>(안 좋은 예시이지만) 같은 기능을 하는 로직을 서로 다른 클래스에서 사용하기 위해 복붙을 했을 경우, 한 쪽의 기능이 변경되면 이를 복붙한 모든 클래스를 전부 수정해주어야 한다.</li>
</ul>

<p><strong>때문에 if-else를 사용하면 유지보수가 어렵다.</strong></p>

<hr />

<h2 id="ocp---open-close-principle-개방-폐쇄의-원칙">OCP - Open Close Principle (개방 폐쇄의 원칙)</h2>

<p>소프트웨어 구성요소(컴포넌트, 클래스, 모듈, 함수)는 <strong>확장에 대해서는 개방되어야 하지만 변경에 대해서는 폐쇄</strong>되어야 한다.<br />
기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.<br />
기존 코드의 변경이 작으며, 확장이 쉽다는 장점이 있다.</p>

<h3 id="적용-방법">적용 방법</h3>

<ul>
  <li>상속(is-a)</li>
  <li>컴포지션(has-a)</li>
</ul>

<h3 id="컴포지션">컴포지션</h3>

<h4 id="변경확장될-것과-변하지-않을-것을-구분한다">변경(확장)될 것과 변하지 않을 것을 구분한다.</h4>

<h4 id="이-두-모듈이-만나는-지점에-인터페이스를-정의한다">이 두 모듈이 만나는 지점에 인터페이스를 정의한다.</h4>

<h4 id="구현에-의존하기보다-정의한-인터페이스에-의존하도록-코드를-작성한다">구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성한다.</h4>

<h3 id="예시">예시</h3>

<ul>
  <li>List와 ArrayList의 관계
    <ul>
      <li>타입 선언은 List이지만 인스턴스를 생성할 때는 그 구현체인 ArrayList로 생성한다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="전략-패턴">전략 패턴</h2>

<ul>
  <li>디자인 패턴 중 가장 많이 쓰임
    <ul>
      <li><strong>디자인 패턴이란?</strong> (소프트웨어) 디자인 + (공통적으로 마주치는 문제를 해결하는 방법의) 패턴</li>
    </ul>
  </li>
  <li>동적으로 전략 수정 가능</li>
  <li>행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 함</li>
  <li>새로운 기능의 추가가 기존 코드에 영향을 미치지 못하게 하므로 OCP를 만족</li>
  <li>기존 코드 변경없이 행위를 자유롭게 바꿀 수 있게 해주는 OCP를 준수한 디자인 패턴</li>
</ul>

<p><strong>➕ GoF의 디자인 패턴</strong>에서의 전략패턴</p>

<ul>
  <li>동일 계열의 알고리즘군을 정의하고 (walk, run, fly, rocket)</li>
  <li>각 알고리즘을 캡슐화하며(MoveStrategy)</li>
  <li>이들을 상호교환이 가능하도록 만든다.</li>
</ul>

<h4 id="전략이란">전략이란?</h4>

<p>어떤 목적을 달성하기 위해 일을 수행하는 방식.<br />
비즈니스 규칙, 문제를 해결하는 알고리즘 등 (Random, Reverse, Nothing)</p>

<h3 id="구성">구성</h3>

<h4 id="context">Context</h4>

<ul>
  <li>전략 패턴을 이용하는 역할을 수행</li>
  <li>필요에 따라 동적으로 구체적인 전략을 바꿀 수 있도록 함 (setter 또는 DI)</li>
</ul>

<h4 id="strategy">Strategy</h4>

<ul>
  <li>인터페이스나 추상 클래스로 외부에서 동일한 방식으로 알고리즘을 호출하는 방법 명시</li>
</ul>

<h4 id="concreatestrategy">ConcreateStrategy</h4>

<ul>
  <li>전략패턴에서 명시한 알고리즘을 실제로 구현한 클래스</li>
</ul>

<h3 id="example">Example</h3>

<p><strong>배민 로봇 이동 전략 예시</strong></p>

<ul>
  <li>Walk</li>
  <li>Run</li>
  <li>Fly</li>
  <li>Rocket</li>
</ul>

<p><strong>초기 배달 로봇</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Robot</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"배달 로봇"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"걸어서 배달합니당."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>그런데 이제 달리는 로봇도 추가하게 되었다면,</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunningRobot</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"배달 로봇"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"뛰어서 배달합니당."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이후에 날으는 로봇, 로켓으로 배달하는 로봇이 생기는 경우를 생각해보자.<br />
이를 먼저 상속으로 해결하는 경우, 아래와 같이 구현할 수 있다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/559aed96-a6f0-45b8-8c0a-2812d05e29b5/image.png" alt="" /></p>

<p>그런데 여기서 로봇에 온도 조절 기능을 추가할 경우, 아래와 같이 구현할 수 있다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/944eed9b-c7a4-476d-9221-4f416fe5a0eb/image.png" alt="" /></p>

<h4 id="-문제점">🤔 문제점?</h4>

<ul>
  <li><strong>메서드 수정이 어렵다.</strong>
    <ul>
      <li>“걸어서 배달하는 로봇”이 “빠르게 걸어서 배달합니다”로 변할 경우 모든 클래스를 순회하면서 메서드들을 수정해주어야 한다.</li>
    </ul>
  </li>
  <li><strong>새로운 기능 추가가 어렵다.</strong>
    <ul>
      <li>한국어, 영어, 중국어를 말하는 기능이 추가된다면 추상 클래스에 말하기 기능이 추가될 것이고, 이를 상속받는 클래스에 기능에 따라 다른 각각의 메서드를 구현해주어야 한다.</li>
    </ul>
  </li>
</ul>

<p><strong>이를 해결하는 것이 바로 전략패턴이다!</strong></p>

<p><img src="https://images.velog.io/images/new_wisdom/post/71c8e746-2de7-4fbc-9e1a-300ff0229c65/image.png" alt="" /></p>

<ul>
  <li>이동전략 : 걷기, 달리기, 날기 등의 로봇의 행위를 정의한다.</li>
  <li>온도 전략 : cold, warm, hot등을 정의한다.</li>
</ul>

<p>로봇을 생성할 때 각각의 전략을 주입해주어 로봇은 전략의 행위를 실행하게 된다.</p>

<p><strong>이렇게 되면 문제점이 어떻게 해결될까?</strong></p>

<ul>
  <li><strong>메서드 수정이 용이하다.</strong>
    <ul>
      <li>“걸어서 배달하는 로봇”이 “빠르게 걸어서 배달합니다”로 변할 경우 walk 부분만 변경해주면 된다.</li>
    </ul>
  </li>
  <li>새로운 기능 추가가 용이하다.
    <ul>
      <li>한국어, 영어, 중국어를 말하는 기능이 추가된다면 이에 따른 새로운 전략의 행위를 정의해주고, 로봇을 생성할 때 전략을 함께 주입해주면 된다.</li>
    </ul>
  </li>
  <li>만약 이동방식이 도중에 변경된다면?
    <ul>
      <li>setter등을 통해 객체 생성 후 전략을 변경할 수 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="jdk에서의-전략패턴">JDK에서의 전략패턴</h3>

<h4 id="comparator">Comparator</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">T</span> <span class="n">o1</span><span class="o">,</span> <span class="n">T</span> <span class="n">o2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Comparator가 전략이고 개발자마다 custom하게 정의한 Comparator구현을 <code class="highlighter-rouge">sort()</code>라는 컨텍스트에서 사용하고 있다.<br />
개발자는 상황에 맞게 비교 전략을 구현할 수 있게 하여 기존 코드의 수정없이 확장을 이룰 수 있다.</p>

<hr />

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=vNsZXC3VgUA&amp;t=24s">[10분 테코톡] 📣 완태의 전략패턴</a></li>
  <li>[<a href="https://www.youtube.com/watch?v=90ZDvHl8ROE">10분 테코톡] 👾베디의 OCP와 전략패턴</a></li>
</ul>


	  ]]></description>
	</item>


</channel>
</rss>
