<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>NewWisdom.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>I want to be a person who gives you new wisdom.</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>📝 객체지향 설계 강의 노트</title>
	  <link>//%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-%EA%B0%95%EC%9D%98-%EB%85%B8%ED%8A%B8</link>
	  <author></author>
	  <pubDate>2021-03-23T19:18:00+09:00</pubDate>
	  <guid>//%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-%EA%B0%95%EC%9D%98-%EB%85%B8%ED%8A%B8</guid>
	  <description><![CDATA[
	     <p><img src="https://user-images.githubusercontent.com/43840561/114287351-1fde3300-9aa1-11eb-851c-61060904867d.png" alt="image" style="zoom: 67%;" /></p>

<p>랜덤넘버는 구현체이니까  Number로 받자</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287370-38e6e400-9aa1-11eb-94d8-e5f4a08b1f16.png" alt="image" style="zoom:67%;" /></p>

<p>이러면 모두가 움직이는데 ?</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287377-4bf9b400-9aa1-11eb-9bec-94738f02d078.png" alt="image" style="zoom:67%;" /></p>

<h3 id="의존성-주입-di">의존성 주입 DI</h3>

<p>스프링 프레임 워크는 DI를 구현하도록 강제되어 있다.<br />
의존성 주입을 위해서는 스프링을 써야한다는 말이 있는데 그렇지 않다.</p>

<p>스프링 프레임 워크를 쓰지 않은 채로 DI를 해본 적이 있습니까 ?</p>

<h4 id="생성자-의존성-주입">생성자 의존성 주입</h4>

<p>❓ randomNumbers를 객체의 변수로 두고있는데, move()의 인수로 넘겨받는 것은 어떨까요?<br />
-&gt; 상관 없음</p>

<p>move 메서드를 사용할 때마다 객체를 생성해야하니</p>

<p>인자가 많아졌을 떄는 생성자를 전달하는 것이 좋을 수도..</p>

<p>❓ 의존성 주입을 위한 setter는 괜찮나요 ?<br />
-&gt; 어떤 객체냐에 따라 다른데, 지금은 Cars의 상태 데이터를 가지고 있는 현제 예시에서는 
final로 선언해주는 것이 좋다.  setter 써도 상관은 없다.</p>

<p>Dependency Injection인데 객체가 다른 객체에 의존하는 것을 외부에서 주입하는 경우를 DI라고 하지 않을까여..?</p>

<p>setter를 사용하는 부분은 전략패턴이 좋은 예시가 되지않을까요?</p>

<p>저는 내부 로직을 객체로 추출할 수 있을때 추출한 후 주입받아 사용하는 식으로 변경할 때  ‘DI한다’ 하는거 같아요</p>

<p>객체지향적 설계는 기본적으로 객체간의 협력을 만들어내는 일이고, 이를 가능하게 하기 위해서는 객체간의 의존성이 필요해요.<br />
-&gt; 그럼 setter를 활용할 수 있지않을까용</p>

<p>의존성을 DI가 아닌 내부에서 만들어 줄 수도 있지만, 이렬 결우 강한 결합성을 가지기 때문에 변경에 자유롭지 않아 DI가 필요하다고 생각해요</p>

<h3 id="유지보수하기-좋은-코드">유지보수하기 좋은 코드</h3>

<p>작은 코드가 유지보수하기 쉽다.<br />
클래스가 작으면 메서드와 프러퍼티가 더 가까이 있을 수 있기 때문에 응집도가 높아진다.<br />
간단히 말해 각각 메서드가 모든 필드를 사용한다.</p>

<h3 id="불변-객체로-만드세요">불변 객체로 만드세요</h3>

<p>함수형 프로그래밍은 side eggect를 만들지 않는다.<br />
가변 객체는 말고 불변 객체를 만들어야 side effect가 생기지 않는다.<br />
불변 객체로 만들다보면 인스턴스가 많아져서 성능이 떨어진다 .</p>

<p>-&gt; 이는 캐싱 전략을 통해 해소하자</p>

<p>불변 객체로 만들다 성능 이슈가 생기면 가변 객체나 캐싱을 사용해라</p>

<p>모든 클래스를 불변으로 만들면 유지보수가 쉽다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287403-7fd4d980-9aa1-11eb-9ad9-fb92c32a2374.png" alt="image" style="zoom:67%;" /></p>

<p>현재 불변 객체가 아니다. <br />
Position이 final이 아니다. <br />
c메소드들이 car를 리턴하도록 변경한다  ?</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287412-8f542280-9aa1-11eb-9727-f9e93b5a60a3.png" alt="image" style="zoom:67%;" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287413-9418d680-9aa1-11eb-9567-4f945bf8cc3d.png" alt="image" style="zoom:67%;" /></p>

<p>요거는 가변 객체</p>

<p>사이드 이펙트가 밝생할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287422-a72ba680-9aa1-11eb-85b9-2b8b618d9288.png" alt="image" style="zoom:50%;" /></p>

<p>값을 바꾸면 계속 새로운 객체를 만들죠 ?</p>

<p>무슨 개소리야 할 수 있지만 분명히 다르다.  근데 계속 객체를 할당 받아야 하네</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287441-bca0d080-9aa1-11eb-8e21-85791e04d06c.png" alt="image" style="zoom: 67%;" /></p>

<p>상태가 바뀌면 계속 새로운 것을 반환해주어야 하니…</p>

<p>불변 객체는 list 내부의 상태 데이터를 추가하고 뺴는 것도 불변 객체 이다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287451-d510eb00-9aa1-11eb-97a0-e90cf46af43a.png" alt="image" style="zoom:67%;" /></p>

<p>이렇게 clear하는 것도 허용이다.</p>

<p>❓그렇다면, 메모리의 주솟값이 불변이면, 메모리의 주솟값이 참조하고 있는 값이 변경되도 불변이다 라고 보는 건가요?<br />
-&gt; 그렇다.</p>

<h4 id="불변-객체와-상수-객체의-차이에-대해-공부해-보세요">불변 객체와 상수 객체의 차이에 대해 공부해 보세요.</h4>

<h3 id="불변-객체로-구현하면-좋은-점">불변 객체로 구현하면 좋은 점</h3>

<ul>
  <li>식별자 가변성 문제가 없다.</li>
  <li>실패 원자성이 있다 - 완전하고 견고한 상태의 객체를 가지거나, 실패하거나 둘 중 하나만 가능하다.</li>
  <li>시간적 결합을 제거할 수 있다. - 가변 객체가 많은 경우 연산들의 순서를 일일이 기억해야한다.</li>
  <li>사이드 이펙트를 제거할 수 있다.</li>
  <li>null 참조를 없앨 수 있다.</li>
  <li>스레드 세이프하다.</li>
  <li>더 작고 더 단순한 객체를 구현할 수 있다.</li>
</ul>

<h3 id="public-상수를-사용하지-마세요-">public 상수를 사용하지 마세요.. ?</h3>

<p>상수라고 불리는 <code class="highlighter-rouge">public static final</code> 프로퍼티는 객체 사이의 데이터를 공유하기 위해 사용한다.<br />
사용하지 말라는 이유는 객체들은 어떤 것도 공유해서는 안되기 때문이다.<br />
독립적이어야 하며, 닫혀 있어야 한다.</p>

<p>하지만 일반적으로는 public 상수를 쓰는게 관례이다.</p>

<p><strong>상수를 쓸거면 객체로 만들어라??</strong><br />
OOP에서 퍼블릭 상수를 절대로 사용하지 말라고 한다.<br />
사소한 상수라도 항상 작은 클래스를 이용해 대체할 것을 추천한다. <br />
enum도 public static final을 쓰는 건데 쓰지 마라!</p>

<p><strong>그냥 설계가 완벽하다 싶을 때 도전해라 ^^</strong></p>

<p>인스턴스 변수는 4개 이하로… 근데. 
번외로 데코레이터 필드는 허용된다고 생각합니다.</p>

<p>position, name의 클래스 접근자를 없애는 것은 ??<br />
그러면 패키지 내부의 결합도를 낮출 수 있고, 인터페이스로 다 만들려면 너무 많아지는 문제점 해결</p>

<p>스프링 프레임 뭐크는 객체들의 의존성을 없앤다.</p>

<p>스프링 프레임워크를 위한 강의였따.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📝 엘레강트 오브젝트 뽀개기 1 강의 정리</title>
	  <link>//%EC%97%98%EB%A0%88%EA%B0%95%ED%8A%B8-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%BD%80%EA%B0%9C%EA%B8%B0-1-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</link>
	  <author></author>
	  <pubDate>2021-03-20T19:18:00+09:00</pubDate>
	  <guid>//%EC%97%98%EB%A0%88%EA%B0%95%ED%8A%B8-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%BD%80%EA%B0%9C%EA%B8%B0-1-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</guid>
	  <description><![CDATA[
	     <p>강의를 들으며 정리하기 ✍️</p>

<h2 id="엘레강트-오브젝트">엘레강트 오브젝트</h2>

<p><img src="https://user-images.githubusercontent.com/43840561/111856837-ca66a880-8970-11eb-903f-b93200975d2e.png" alt="image" style="zoom:50%;" /></p>

<ul>
  <li>
    <p>문자열과 원시값을 포장해라</p>
  </li>
  <li>
    <p>반환 값은 모두 일급 컬렉션</p>

    <p><img src="https://user-images.githubusercontent.com/43840561/111856864-fc780a80-8970-11eb-9ada-2c99c659bcfd.png" alt="image" style="zoom:50%;" /></p>
  </li>
</ul>

<h3 id="인자의-값으로-null을-절대-허용하지-마세요">인자의 값으로 null을 절대 허용하지 마세요</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="nf">find</span><span class="o">(</span><span class="n">String</span> <span class="n">mask</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mask</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// .</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
<span class="c1">// .</span>
<span class="o">}</span> <span class="o">}</span>
</code></pre></div></div>

<p>null을 체크하는 로직을 구현하는 것은 객체를 무시하는 것이다.<br />
mask 객체를 존중했다면 조건의 존재 여부를 객체 스스로 결정하게 했을 것이다.<br />
이를 위해 <strong>원시 값과 문자열을 포장</strong>하면 null을 허용하지 않을 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857492-216e7c80-8975-11eb-8c28-ef1e68a6c3ba.png" alt="image" /></p>

<p>이 부분이 randomNumber를 무시하는 것이 아닌가.<br />
randomNumber를 객체로 만든다. (원시값 포장).</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857526-77432480-8975-11eb-92c2-3abaeb7ccbd3.png" alt="image" style="zoom:50%;" /></p>

<p>객체에게 메시지를 보내도록 리팩토링한다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857586-e02a9c80-8975-11eb-84d0-74f7930af1bc.png" alt="image" style="zoom:50%;" /></p>

<p>테스트 가능하게 오버라이딩.</p>

<p>RandomNumber의 null 체크 안해줘도 되나 ? <br />
이 메서드가 외부에 쓰인다면 고민해봐야하지만, 내부에서만 move가 호출되면 
null 체크를 굳이 안해줘도 좋다. 
내가 컨트롤할 수 있는 범위라면 안해도 될 것 같다.<br />
<code class="highlighter-rouge">move()</code> 를 사용하는 범위가 어디까지인지에 따라 null 체크 여부가 달린 것 같다.</p>

<h3 id="final이거나-abstract-이거나">final이거나 abstract 이거나</h3>

<p>상속은 객체들의 관계를 복잡하게 만드니 최대한 자제하고,<br />
final이나 abstract로 만들어라</p>

<p>변수에 <code class="highlighter-rouge">final</code> 을 붙이면 재할당이 불가능하지만, 메서드에 붙이면 오버라이딩이 불가하다.<br />
클래스에 <code class="highlighter-rouge">final</code> 은 상속을 불가능하게 한다.</p>

<p>final 클래스가 테스트 가능하도록 하는 법.
인터페이스로 만든다.</p>

<p>RandomNumber 클래스를 final로 만들고 Number 인터페이스를 만든다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857934-5e883e00-8978-11eb-8472-ac523772cb3b.png" alt="image" style="zoom:67%;" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857943-7069e100-8978-11eb-8e53-dd4b5f7d6b2c.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/111858087-862bd600-8979-11eb-91b5-49a3004f38d8.png" alt="image" style="zoom:50%;" /></p>

<p>그러면 이렇게 Number 인터페이스와 의존 관계를 맺는다. <br />
인터페이스와 의존 관계를 맺는게 final 클래스와 의존 관계를 맺는 것 보다 테스트가 더 용이하다.</p>

<p>클래스에 final을 붙이는 것은 좋은 습관이다.<br />
final을 테스트하고 싶으면 인터페이스를 추출하면 된다.</p>

<p>인터페이스 구현체가 여러개가 되면 중복들이 많아지는데, 
이 중복을 어떻게 없애나 ?<br />
인터페이스 구현체 중간에 추상 클래스를 둔다.<br />
Car - 인터페이스 <br />
AbstractCar - 추상 클래스<br />
Sonatar - 클래스</p>

<p>이러면 추상 클래스의 필요성을 느낄 수 있을 것이다.</p>

<p>근데 default 메소드를 사용하면 안되나 ?</p>

<p>포비는 default 를 남용하지 않는다.  추상 클래스를 쓰는게 더 좋다.</p>

<p>중복을 제거할 때 추상 클래스의 인스턴스 변수, 즉 인스턴스에 종속된 메서드면 default 메서드를 만들기 어려울 수 있다.  default 메서드를 만들 수 있는 경우, 없는 경우가 있으니 잘 구별.<br />
추상 클래스는 상태를 가지니 상태를 활용할 수 있다.</p>

<p>상속 때 부모 클래스에 있는 인스턴스 변수를 private로 막아라 ! <br />
그래야 캡슐화가 잘 되었다고 한다. <br />
접근할 때는 메서드를 통해 접근해라</p>

<h3 id="-er로-끝나는-이름을-사용하지-마세요">-er로 끝나는 이름을 사용하지 마세요</h3>

<p>클래스 이름을 지을 때 좋은 가이드.</p>

<p>클래스는 객체를 만들어 내는 역할일 뿐이다 (객체의 Factory).<br />
클래스는 객체를 만들고, 추적하고, 적절한 시점에 파괴한다 (라이프 사이클 관리).</p>

<p>클래스를 객체의 템플릿으로 바라보는 것은 클래스를 수동적인 존재로 만드는 것이다.<br />
클래스는 객체의 능동적인 관리자이다.<br />
객체를 꺼내거나 반환하는 저장소이다.</p>

<h4 id="클래스-이름을-짓는-방식">클래스 이름을 짓는 방식</h4>

<p>클래스의 객체들이 <strong>무엇을 하는지</strong> 가 아닌, <strong>무엇인지</strong> 에 기반해 지어라.</p>

<ul>
  <li><strong>무엇을 하는지</strong>로 이름을 지은 잘못된 예</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CashFormatter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">CashFormatter</span><span class="o">(</span><span class="kt">int</span> <span class="n">dollars</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">format</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"$ %d"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">dollars</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>무엇인지를 기반으로 객체의 역량을 나타내도록 이름을 지어야 한다.</p>

<ul>
  <li><strong>무엇인지</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="kt">int</span> <span class="n">dollars</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">usd</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"$ %d"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">dollars</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>객체는 객체의 외부 세계와 내부 세계를 이어주는 연결장치가 아니고,<br />
내부에 캡슐화된 데이터를 다루기 위해 요청할 수 있는 절차의 집합도 아니다.<br />
객체는 <strong>캡슐화된 데이터의 대표자</strong>이다.</p>

<p>무엇인지로 객체를 추출하면 무엇을 하는지까지 포괄하는 것이 아닌가. <br />
무엇을 하는지는 수동적인 존재가 된다.</p>

<p>메서드에서는 protected를 사용할 수 있는데 변수에는 사용하지 않는 것이 좋다.<br />
DTO는 모르겠는데 도메인 객체에서는 무조건 인스턴스 변수는 private여야 한다.</p>

<p>“무엇인지” 생각하지 않고 “무엇을 하는지”를 먼저 생각하고 설계하지 말라</p>

<p>처음에 메세지를 정하고 객체의 협력을 구상해야하는데 이를 하기 위해는 “무엇을 하는지”가 아니라 객체가 “무엇인지” 부터 생각을 해야하는 것 같아요. 객체가 무엇인지 생각하고 책임을 부여하면서 “무엇을 하는지” 가 된다.</p>

<p>이미 er과 or을 가지고 있는 것들은 써도 되지만, 나머지는 자제하라</p>

<p>CashFormatter가 아닌 FomattedCash는 어때 ?<br />
CashFormatter는<code class="highlighter-rouge">format()</code> 이외의 기능을 가지면 부자연스럽기 때문이다.</p>

<h3 id="메서드-이름을-신중하게-선택하세요">메서드 이름을 신중하게 선택하세요</h3>

<p>메서드 명은 무조건 동사가 아니다.</p>

<h4 id="빌더builder의-이름은-명사로">빌더(builder)의 이름은 명사로</h4>

<p>반환타입이 void가 아닌 메서드로, 무언가를 만들어 새로운 객체를 반환한다.<br />
이 메서드의 명은 항상 <strong>명사</strong>여야 한다.<br />
형용사를 덧붙여 메서드의 의미를 좀 더 풍부하게 설명하는 명사로 나타낼 수도 있다.</p>

<p>Ex) float speed(), Employee employee(), String parsedCell()</p>

<h4 id="조정자manipulator의-이름은-동사로">조정자(manipulator)의 이름은 동사로</h4>

<p>반환타입이 void인 메서드로 엔티티를 수정하는 메서드이다.<br />
이 메서드 명은 항상 <strong>동사</strong>여야 한다.<br />
부사를 덧붙여 메서드의 문맥과 목적에 관한 풍부한 정보를 제송하는 동사로 나타낼 수 있다.</p>

<p>ex) void save(String content), void quicklyPrint(int id);</p>

<h4 id="잘못된-예시">잘못된 예시</h4>

<p>boolean put(String key, Float value);</p>

<p>이 메서드는 <code class="highlighter-rouge">PutOperation</code> 과 같은 클래스를 추가해 <code class="highlighter-rouge">save()</code> , <code class="highlighter-rouge">success()</code> 메서드로 분리한다.</p>

<h4 id="빌더와-조정자로-분리---빌더는-명사다">빌더와 조정자로 분리 - 빌더는 명사다</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Bakery</span> <span class="o">{</span>
    <span class="n">Food</span> <span class="nf">cookBrownie</span><span class="o">();</span>
    <span class="n">Drink</span> <span class="nf">brewCupOfCoffee</span><span class="o">(</span><span class="n">String</span> <span class="n">flavor</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">cookBrownie()</code> , <code class="highlighter-rouge">brewCupOfCoffee()</code> 는 실제로는 객체의 메서드가 아니고, 프로시저이다.<br />
객체는 자신의 의무를 수행하는 방법을 알고 있고, 존중해줘야하는 살아있는 유기체이다.<br />
단순한 명령에 따르지 않고, 계약에 기반해 일하고 싶어한다.</p>

<p>하지만 관념적인 부분은 포기해도 괜찮다 !</p>

<p>getXxx()는 내부적으로 xxx를 가지고 있을 것이라는 것을 드러내지만,<br />
명사를 사용하면 그 메서드 내부에 로직이 있는지를 숨길 수 있다.</p>

<h4 id="빌더와-조정자로-분리---조정자는-동사다">빌더와 조정자로 분리 - 조정자는 동사다</h4>

<p>ex) DJ에게 음악을 틀어달라고 요청할 때</p>

<ul>
  <li>방법 1. 음악을 틀어주세요.</li>
  <li>방법 2. 음악을 틀고, 현재 볼륨 상태를 말해주세요.</li>
</ul>

<p>이 중 방법 1가 더 객체를 존중하고 있다.<br />
그 객체가 알아서 하겠지 ! 를 생각해라. 객체를 믿어라.</p>

<p>print도 매개변수가 다르니 <code class="highlighter-rouge">print()</code> 로 통일할 수 있다.</p>

<h4 id="빌더와-조정자로-분리-3---빌더와-조정자-혼합하기">빌더와 조정자로 분리 3 - 빌더와 조정자 혼합하기</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Document</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">write</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">content</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>값을 반환하고 있는 write를 빌더와 조정자로 분리한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Document</span> <span class="o">{</span>
    <span class="n">OutputPipe</span> <span class="nf">output</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">OutputPipe</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">content</span><span class="o">);</span>
    <span class="kt">int</span> <span class="nf">bytes</span><span class="o">();</span>
    <span class="kt">long</span> <span class="nf">time</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="빌더와-조정자로-분리---boolean-값을-반환하는-경우-형용사로-지어라">빌더와 조정자로 분리 - Boolean 값을 반환하는 경우 형용사로 지어라</h4>

<p>빌더이지만, 가독성을 위해 형용사로 지어라.</p>

<h3 id="생성자-하나를-주-생성자로-만드세요">생성자 하나를 주 생성자로 만드세요</h3>

<p><strong>클래스는 2~3개의 메서드와 5~10개의 생성</strong>자를 포함해야한다.</p>

<p>생성자가 많고 메서드가 적을 수록 응집도가 높고 견고한 클래스가 된다.<br />
생성자가 많을 수록 클라이언트가 클래스를 더 편하게 사용할 수 있다.</p>

<ul>
  <li>주 생성자 : 프로퍼티를 초기화한다. 오직 주 생성자만 담당한다.</li>
  <li>부 생성자 : 주 생성자를 호출한다.</li>
</ul>

<p>인자수가 적은 수부터 많은 순으로, 주 생성자는 마지막에 둔다.</p>

<p>테스트를 위한 생성자는 좋다 ! 하지만 메서드 추가는 옳지 않다 !
생성자 여러개를 테스트 할 때 다른 타입 매개변수의 생성자 동등성을 테스트 하면 된다.</p>

<p><em>뷰에서 List 정도로 가공은 할 수 있을 것 같다.</em></p>

<p>좋은 객체는 모든 메서드가 각각 모든 인스턴스 변수를 사용하고 있다 (100%는 어렵다).</p>

<h3 id="문서를-작성하는-대신-테스트를-만들어라">문서를 작성하는 대신 테스트를 만들어라</h3>

<p>주석이 없어도 클래스명과 메서드만을 봐도 무슨일을 하는지 알 수 있게,<br />
테스트를 통해  메서드의 의도를 알도록 하라.</p>

<p>깔끔하게 만든다라는 것은 단위 테스트도 만든다는 의미이다.<br />
단위 테스트는 클래스의 일부이고 독립적인 개체가 아니다.</p>

<h3 id="생성자에-코드를-넣지-마세요">생성자에 코드를 넣지 마세요</h3>

<p>인자에 손을 대지 말라는 의미이다.</p>

<ul>
  <li>잘못된 예시</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">dlr</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>생성자에 코드가 있을 경우 객체 변환과 관련한 예외를 제어할 수 없다.</p>

<ul>
  <li>좋은 예시</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringAsInteger</span><span class="o">(</span><span class="n">dlr</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringAsInteger</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">source</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">StringAsInteger</span><span class="o">(</span><span class="n">String</span> <span class="n">txt</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">source</span> <span class="o">=</span> <span class="n">txt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">intValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">source</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>이렇게 리팩토링을 하면 실제로 객체를 사용하는 시점까지의 객체 변환 작업은 연기된다.<br />
생성자에 코드가 없을 경우 성능 최적화가 더 쉬워 실행 속도가 더 빨라진다.</p>

<p>진정한 객체지향에서 인스턴스화란 더 작은 객체들을 조합해서 더 큰 객체를 만드는 것이다.</p>

<p>객체의 변환을 뒤로 미뤄 파싱이 여러번 실행되지 않도록  데코레이터(decorator)를 추가해 파싱 결과를 캐싱할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CachedNumber</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">origin</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cached</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">);</span>
    <span class="kd">public</span> <span class="nf">CachedNumber</span><span class="o">(</span><span class="n">Number</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>
<span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">intValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">intValue</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CachedNumber</span><span class="o">(</span><span class="k">new</span> <span class="n">StringAsInteger</span><span class="o">(</span><span class="n">dlr</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>


	  ]]></description>
	</item>


</channel>
</rss>
