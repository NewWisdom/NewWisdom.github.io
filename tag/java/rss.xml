<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>NewWisdom.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>I want to be a person who gives you new wisdom.</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>📝 객체지향 설계 강의 노트</title>
	  <link>//%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-%EA%B0%95%EC%9D%98-%EB%85%B8%ED%8A%B8</link>
	  <author></author>
	  <pubDate>2021-03-23T19:18:00+09:00</pubDate>
	  <guid>//%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-%EA%B0%95%EC%9D%98-%EB%85%B8%ED%8A%B8</guid>
	  <description><![CDATA[
	     <p><img src="https://user-images.githubusercontent.com/43840561/114287351-1fde3300-9aa1-11eb-851c-61060904867d.png" alt="image" style="zoom: 67%;" /></p>

<p>랜덤넘버는 구현체이니까  Number로 받자</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287370-38e6e400-9aa1-11eb-94d8-e5f4a08b1f16.png" alt="image" style="zoom:67%;" /></p>

<p>이러면 모두가 움직이는데 ?</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287377-4bf9b400-9aa1-11eb-9bec-94738f02d078.png" alt="image" style="zoom:67%;" /></p>

<h3 id="의존성-주입-di">의존성 주입 DI</h3>

<p>스프링 프레임 워크는 DI를 구현하도록 강제되어 있다.<br />
의존성 주입을 위해서는 스프링을 써야한다는 말이 있는데 그렇지 않다.</p>

<p>스프링 프레임 워크를 쓰지 않은 채로 DI를 해본 적이 있습니까 ?</p>

<h4 id="생성자-의존성-주입">생성자 의존성 주입</h4>

<p>❓ randomNumbers를 객체의 변수로 두고있는데, move()의 인수로 넘겨받는 것은 어떨까요?<br />
-&gt; 상관 없음</p>

<p>move 메서드를 사용할 때마다 객체를 생성해야하니</p>

<p>인자가 많아졌을 떄는 생성자를 전달하는 것이 좋을 수도..</p>

<p>❓ 의존성 주입을 위한 setter는 괜찮나요 ?<br />
-&gt; 어떤 객체냐에 따라 다른데, 지금은 Cars의 상태 데이터를 가지고 있는 현제 예시에서는 
final로 선언해주는 것이 좋다.  setter 써도 상관은 없다.</p>

<p>Dependency Injection인데 객체가 다른 객체에 의존하는 것을 외부에서 주입하는 경우를 DI라고 하지 않을까여..?</p>

<p>setter를 사용하는 부분은 전략패턴이 좋은 예시가 되지않을까요?</p>

<p>저는 내부 로직을 객체로 추출할 수 있을때 추출한 후 주입받아 사용하는 식으로 변경할 때  ‘DI한다’ 하는거 같아요</p>

<p>객체지향적 설계는 기본적으로 객체간의 협력을 만들어내는 일이고, 이를 가능하게 하기 위해서는 객체간의 의존성이 필요해요.<br />
-&gt; 그럼 setter를 활용할 수 있지않을까용</p>

<p>의존성을 DI가 아닌 내부에서 만들어 줄 수도 있지만, 이렬 결우 강한 결합성을 가지기 때문에 변경에 자유롭지 않아 DI가 필요하다고 생각해요</p>

<h3 id="유지보수하기-좋은-코드">유지보수하기 좋은 코드</h3>

<p>작은 코드가 유지보수하기 쉽다.<br />
클래스가 작으면 메서드와 프러퍼티가 더 가까이 있을 수 있기 때문에 응집도가 높아진다.<br />
간단히 말해 각각 메서드가 모든 필드를 사용한다.</p>

<h3 id="불변-객체로-만드세요">불변 객체로 만드세요</h3>

<p>함수형 프로그래밍은 side eggect를 만들지 않는다.<br />
가변 객체는 말고 불변 객체를 만들어야 side effect가 생기지 않는다.<br />
불변 객체로 만들다보면 인스턴스가 많아져서 성능이 떨어진다 .</p>

<p>-&gt; 이는 캐싱 전략을 통해 해소하자</p>

<p>불변 객체로 만들다 성능 이슈가 생기면 가변 객체나 캐싱을 사용해라</p>

<p>모든 클래스를 불변으로 만들면 유지보수가 쉽다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287403-7fd4d980-9aa1-11eb-9ad9-fb92c32a2374.png" alt="image" style="zoom:67%;" /></p>

<p>현재 불변 객체가 아니다. <br />
Position이 final이 아니다. <br />
c메소드들이 car를 리턴하도록 변경한다  ?</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287412-8f542280-9aa1-11eb-9727-f9e93b5a60a3.png" alt="image" style="zoom:67%;" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287413-9418d680-9aa1-11eb-9567-4f945bf8cc3d.png" alt="image" style="zoom:67%;" /></p>

<p>요거는 가변 객체</p>

<p>사이드 이펙트가 밝생할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287422-a72ba680-9aa1-11eb-85b9-2b8b618d9288.png" alt="image" style="zoom:50%;" /></p>

<p>값을 바꾸면 계속 새로운 객체를 만들죠 ?</p>

<p>무슨 개소리야 할 수 있지만 분명히 다르다.  근데 계속 객체를 할당 받아야 하네</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287441-bca0d080-9aa1-11eb-8e21-85791e04d06c.png" alt="image" style="zoom: 67%;" /></p>

<p>상태가 바뀌면 계속 새로운 것을 반환해주어야 하니…</p>

<p>불변 객체는 list 내부의 상태 데이터를 추가하고 뺴는 것도 불변 객체 이다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287451-d510eb00-9aa1-11eb-97a0-e90cf46af43a.png" alt="image" style="zoom:67%;" /></p>

<p>이렇게 clear하는 것도 허용이다.</p>

<p>❓그렇다면, 메모리의 주솟값이 불변이면, 메모리의 주솟값이 참조하고 있는 값이 변경되도 불변이다 라고 보는 건가요?<br />
-&gt; 그렇다.</p>

<h4 id="불변-객체와-상수-객체의-차이에-대해-공부해-보세요">불변 객체와 상수 객체의 차이에 대해 공부해 보세요.</h4>

<h3 id="불변-객체로-구현하면-좋은-점">불변 객체로 구현하면 좋은 점</h3>

<ul>
  <li>식별자 가변성 문제가 없다.</li>
  <li>실패 원자성이 있다 - 완전하고 견고한 상태의 객체를 가지거나, 실패하거나 둘 중 하나만 가능하다.</li>
  <li>시간적 결합을 제거할 수 있다. - 가변 객체가 많은 경우 연산들의 순서를 일일이 기억해야한다.</li>
  <li>사이드 이펙트를 제거할 수 있다.</li>
  <li>null 참조를 없앨 수 있다.</li>
  <li>스레드 세이프하다.</li>
  <li>더 작고 더 단순한 객체를 구현할 수 있다.</li>
</ul>

<h3 id="public-상수를-사용하지-마세요-">public 상수를 사용하지 마세요.. ?</h3>

<p>상수라고 불리는 <code class="highlighter-rouge">public static final</code> 프로퍼티는 객체 사이의 데이터를 공유하기 위해 사용한다.<br />
사용하지 말라는 이유는 객체들은 어떤 것도 공유해서는 안되기 때문이다.<br />
독립적이어야 하며, 닫혀 있어야 한다.</p>

<p>하지만 일반적으로는 public 상수를 쓰는게 관례이다.</p>

<p><strong>상수를 쓸거면 객체로 만들어라??</strong><br />
OOP에서 퍼블릭 상수를 절대로 사용하지 말라고 한다.<br />
사소한 상수라도 항상 작은 클래스를 이용해 대체할 것을 추천한다. <br />
enum도 public static final을 쓰는 건데 쓰지 마라!</p>

<p><strong>그냥 설계가 완벽하다 싶을 때 도전해라 ^^</strong></p>

<p>인스턴스 변수는 4개 이하로… 근데. 
번외로 데코레이터 필드는 허용된다고 생각합니다.</p>

<p>position, name의 클래스 접근자를 없애는 것은 ??<br />
그러면 패키지 내부의 결합도를 낮출 수 있고, 인터페이스로 다 만들려면 너무 많아지는 문제점 해결</p>

<p>스프링 프레임 뭐크는 객체들의 의존성을 없앤다.</p>

<p>스프링 프레임워크를 위한 강의였따.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📝 엘레강트 오브젝트 뽀개기 1 강의 정리</title>
	  <link>//%EC%97%98%EB%A0%88%EA%B0%95%ED%8A%B8-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%BD%80%EA%B0%9C%EA%B8%B0-1-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</link>
	  <author></author>
	  <pubDate>2021-03-20T19:18:00+09:00</pubDate>
	  <guid>//%EC%97%98%EB%A0%88%EA%B0%95%ED%8A%B8-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%BD%80%EA%B0%9C%EA%B8%B0-1-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</guid>
	  <description><![CDATA[
	     <p>강의를 들으며 정리하기 ✍️</p>

<h2 id="엘레강트-오브젝트">엘레강트 오브젝트</h2>

<p><img src="https://user-images.githubusercontent.com/43840561/111856837-ca66a880-8970-11eb-903f-b93200975d2e.png" alt="image" style="zoom:50%;" /></p>

<ul>
  <li>
    <p>문자열과 원시값을 포장해라</p>
  </li>
  <li>
    <p>반환 값은 모두 일급 컬렉션</p>

    <p><img src="https://user-images.githubusercontent.com/43840561/111856864-fc780a80-8970-11eb-9ada-2c99c659bcfd.png" alt="image" style="zoom:50%;" /></p>
  </li>
</ul>

<h3 id="인자의-값으로-null을-절대-허용하지-마세요">인자의 값으로 null을 절대 허용하지 마세요</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="nf">find</span><span class="o">(</span><span class="n">String</span> <span class="n">mask</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mask</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// .</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
<span class="c1">// .</span>
<span class="o">}</span> <span class="o">}</span>
</code></pre></div></div>

<p>null을 체크하는 로직을 구현하는 것은 객체를 무시하는 것이다.<br />
mask 객체를 존중했다면 조건의 존재 여부를 객체 스스로 결정하게 했을 것이다.<br />
이를 위해 <strong>원시 값과 문자열을 포장</strong>하면 null을 허용하지 않을 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857492-216e7c80-8975-11eb-8c28-ef1e68a6c3ba.png" alt="image" /></p>

<p>이 부분이 randomNumber를 무시하는 것이 아닌가.<br />
randomNumber를 객체로 만든다. (원시값 포장).</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857526-77432480-8975-11eb-92c2-3abaeb7ccbd3.png" alt="image" style="zoom:50%;" /></p>

<p>객체에게 메시지를 보내도록 리팩토링한다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857586-e02a9c80-8975-11eb-84d0-74f7930af1bc.png" alt="image" style="zoom:50%;" /></p>

<p>테스트 가능하게 오버라이딩.</p>

<p>RandomNumber의 null 체크 안해줘도 되나 ? <br />
이 메서드가 외부에 쓰인다면 고민해봐야하지만, 내부에서만 move가 호출되면 
null 체크를 굳이 안해줘도 좋다. 
내가 컨트롤할 수 있는 범위라면 안해도 될 것 같다.<br />
<code class="highlighter-rouge">move()</code> 를 사용하는 범위가 어디까지인지에 따라 null 체크 여부가 달린 것 같다.</p>

<h3 id="final이거나-abstract-이거나">final이거나 abstract 이거나</h3>

<p>상속은 객체들의 관계를 복잡하게 만드니 최대한 자제하고,<br />
final이나 abstract로 만들어라</p>

<p>변수에 <code class="highlighter-rouge">final</code> 을 붙이면 재할당이 불가능하지만, 메서드에 붙이면 오버라이딩이 불가하다.<br />
클래스에 <code class="highlighter-rouge">final</code> 은 상속을 불가능하게 한다.</p>

<p>final 클래스가 테스트 가능하도록 하는 법.
인터페이스로 만든다.</p>

<p>RandomNumber 클래스를 final로 만들고 Number 인터페이스를 만든다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857934-5e883e00-8978-11eb-8472-ac523772cb3b.png" alt="image" style="zoom:67%;" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857943-7069e100-8978-11eb-8e53-dd4b5f7d6b2c.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/111858087-862bd600-8979-11eb-91b5-49a3004f38d8.png" alt="image" style="zoom:50%;" /></p>

<p>그러면 이렇게 Number 인터페이스와 의존 관계를 맺는다. <br />
인터페이스와 의존 관계를 맺는게 final 클래스와 의존 관계를 맺는 것 보다 테스트가 더 용이하다.</p>

<p>클래스에 final을 붙이는 것은 좋은 습관이다.<br />
final을 테스트하고 싶으면 인터페이스를 추출하면 된다.</p>

<p>인터페이스 구현체가 여러개가 되면 중복들이 많아지는데, 
이 중복을 어떻게 없애나 ?<br />
인터페이스 구현체 중간에 추상 클래스를 둔다.<br />
Car - 인터페이스 <br />
AbstractCar - 추상 클래스<br />
Sonatar - 클래스</p>

<p>이러면 추상 클래스의 필요성을 느낄 수 있을 것이다.</p>

<p>근데 default 메소드를 사용하면 안되나 ?</p>

<p>포비는 default 를 남용하지 않는다.  추상 클래스를 쓰는게 더 좋다.</p>

<p>중복을 제거할 때 추상 클래스의 인스턴스 변수, 즉 인스턴스에 종속된 메서드면 default 메서드를 만들기 어려울 수 있다.  default 메서드를 만들 수 있는 경우, 없는 경우가 있으니 잘 구별.<br />
추상 클래스는 상태를 가지니 상태를 활용할 수 있다.</p>

<p>상속 때 부모 클래스에 있는 인스턴스 변수를 private로 막아라 ! <br />
그래야 캡슐화가 잘 되었다고 한다. <br />
접근할 때는 메서드를 통해 접근해라</p>

<h3 id="-er로-끝나는-이름을-사용하지-마세요">-er로 끝나는 이름을 사용하지 마세요</h3>

<p>클래스 이름을 지을 때 좋은 가이드.</p>

<p>클래스는 객체를 만들어 내는 역할일 뿐이다 (객체의 Factory).<br />
클래스는 객체를 만들고, 추적하고, 적절한 시점에 파괴한다 (라이프 사이클 관리).</p>

<p>클래스를 객체의 템플릿으로 바라보는 것은 클래스를 수동적인 존재로 만드는 것이다.<br />
클래스는 객체의 능동적인 관리자이다.<br />
객체를 꺼내거나 반환하는 저장소이다.</p>

<h4 id="클래스-이름을-짓는-방식">클래스 이름을 짓는 방식</h4>

<p>클래스의 객체들이 <strong>무엇을 하는지</strong> 가 아닌, <strong>무엇인지</strong> 에 기반해 지어라.</p>

<ul>
  <li><strong>무엇을 하는지</strong>로 이름을 지은 잘못된 예</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CashFormatter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">CashFormatter</span><span class="o">(</span><span class="kt">int</span> <span class="n">dollars</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">format</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"$ %d"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">dollars</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>무엇인지를 기반으로 객체의 역량을 나타내도록 이름을 지어야 한다.</p>

<ul>
  <li><strong>무엇인지</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="kt">int</span> <span class="n">dollars</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">usd</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"$ %d"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">dollars</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>객체는 객체의 외부 세계와 내부 세계를 이어주는 연결장치가 아니고,<br />
내부에 캡슐화된 데이터를 다루기 위해 요청할 수 있는 절차의 집합도 아니다.<br />
객체는 <strong>캡슐화된 데이터의 대표자</strong>이다.</p>

<p>무엇인지로 객체를 추출하면 무엇을 하는지까지 포괄하는 것이 아닌가. <br />
무엇을 하는지는 수동적인 존재가 된다.</p>

<p>메서드에서는 protected를 사용할 수 있는데 변수에는 사용하지 않는 것이 좋다.<br />
DTO는 모르겠는데 도메인 객체에서는 무조건 인스턴스 변수는 private여야 한다.</p>

<p>“무엇인지” 생각하지 않고 “무엇을 하는지”를 먼저 생각하고 설계하지 말라</p>

<p>처음에 메세지를 정하고 객체의 협력을 구상해야하는데 이를 하기 위해는 “무엇을 하는지”가 아니라 객체가 “무엇인지” 부터 생각을 해야하는 것 같아요. 객체가 무엇인지 생각하고 책임을 부여하면서 “무엇을 하는지” 가 된다.</p>

<p>이미 er과 or을 가지고 있는 것들은 써도 되지만, 나머지는 자제하라</p>

<p>CashFormatter가 아닌 FomattedCash는 어때 ?<br />
CashFormatter는<code class="highlighter-rouge">format()</code> 이외의 기능을 가지면 부자연스럽기 때문이다.</p>

<h3 id="메서드-이름을-신중하게-선택하세요">메서드 이름을 신중하게 선택하세요</h3>

<p>메서드 명은 무조건 동사가 아니다.</p>

<h4 id="빌더builder의-이름은-명사로">빌더(builder)의 이름은 명사로</h4>

<p>반환타입이 void가 아닌 메서드로, 무언가를 만들어 새로운 객체를 반환한다.<br />
이 메서드의 명은 항상 <strong>명사</strong>여야 한다.<br />
형용사를 덧붙여 메서드의 의미를 좀 더 풍부하게 설명하는 명사로 나타낼 수도 있다.</p>

<p>Ex) float speed(), Employee employee(), String parsedCell()</p>

<h4 id="조정자manipulator의-이름은-동사로">조정자(manipulator)의 이름은 동사로</h4>

<p>반환타입이 void인 메서드로 엔티티를 수정하는 메서드이다.<br />
이 메서드 명은 항상 <strong>동사</strong>여야 한다.<br />
부사를 덧붙여 메서드의 문맥과 목적에 관한 풍부한 정보를 제송하는 동사로 나타낼 수 있다.</p>

<p>ex) void save(String content), void quicklyPrint(int id);</p>

<h4 id="잘못된-예시">잘못된 예시</h4>

<p>boolean put(String key, Float value);</p>

<p>이 메서드는 <code class="highlighter-rouge">PutOperation</code> 과 같은 클래스를 추가해 <code class="highlighter-rouge">save()</code> , <code class="highlighter-rouge">success()</code> 메서드로 분리한다.</p>

<h4 id="빌더와-조정자로-분리---빌더는-명사다">빌더와 조정자로 분리 - 빌더는 명사다</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Bakery</span> <span class="o">{</span>
    <span class="n">Food</span> <span class="nf">cookBrownie</span><span class="o">();</span>
    <span class="n">Drink</span> <span class="nf">brewCupOfCoffee</span><span class="o">(</span><span class="n">String</span> <span class="n">flavor</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">cookBrownie()</code> , <code class="highlighter-rouge">brewCupOfCoffee()</code> 는 실제로는 객체의 메서드가 아니고, 프로시저이다.<br />
객체는 자신의 의무를 수행하는 방법을 알고 있고, 존중해줘야하는 살아있는 유기체이다.<br />
단순한 명령에 따르지 않고, 계약에 기반해 일하고 싶어한다.</p>

<p>하지만 관념적인 부분은 포기해도 괜찮다 !</p>

<p>getXxx()는 내부적으로 xxx를 가지고 있을 것이라는 것을 드러내지만,<br />
명사를 사용하면 그 메서드 내부에 로직이 있는지를 숨길 수 있다.</p>

<h4 id="빌더와-조정자로-분리---조정자는-동사다">빌더와 조정자로 분리 - 조정자는 동사다</h4>

<p>ex) DJ에게 음악을 틀어달라고 요청할 때</p>

<ul>
  <li>방법 1. 음악을 틀어주세요.</li>
  <li>방법 2. 음악을 틀고, 현재 볼륨 상태를 말해주세요.</li>
</ul>

<p>이 중 방법 1가 더 객체를 존중하고 있다.<br />
그 객체가 알아서 하겠지 ! 를 생각해라. 객체를 믿어라.</p>

<p>print도 매개변수가 다르니 <code class="highlighter-rouge">print()</code> 로 통일할 수 있다.</p>

<h4 id="빌더와-조정자로-분리-3---빌더와-조정자-혼합하기">빌더와 조정자로 분리 3 - 빌더와 조정자 혼합하기</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Document</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">write</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">content</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>값을 반환하고 있는 write를 빌더와 조정자로 분리한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Document</span> <span class="o">{</span>
    <span class="n">OutputPipe</span> <span class="nf">output</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">OutputPipe</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">content</span><span class="o">);</span>
    <span class="kt">int</span> <span class="nf">bytes</span><span class="o">();</span>
    <span class="kt">long</span> <span class="nf">time</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="빌더와-조정자로-분리---boolean-값을-반환하는-경우-형용사로-지어라">빌더와 조정자로 분리 - Boolean 값을 반환하는 경우 형용사로 지어라</h4>

<p>빌더이지만, 가독성을 위해 형용사로 지어라.</p>

<h3 id="생성자-하나를-주-생성자로-만드세요">생성자 하나를 주 생성자로 만드세요</h3>

<p><strong>클래스는 2~3개의 메서드와 5~10개의 생성</strong>자를 포함해야한다.</p>

<p>생성자가 많고 메서드가 적을 수록 응집도가 높고 견고한 클래스가 된다.<br />
생성자가 많을 수록 클라이언트가 클래스를 더 편하게 사용할 수 있다.</p>

<ul>
  <li>주 생성자 : 프로퍼티를 초기화한다. 오직 주 생성자만 담당한다.</li>
  <li>부 생성자 : 주 생성자를 호출한다.</li>
</ul>

<p>인자수가 적은 수부터 많은 순으로, 주 생성자는 마지막에 둔다.</p>

<p>테스트를 위한 생성자는 좋다 ! 하지만 메서드 추가는 옳지 않다 !
생성자 여러개를 테스트 할 때 다른 타입 매개변수의 생성자 동등성을 테스트 하면 된다.</p>

<p><em>뷰에서 List 정도로 가공은 할 수 있을 것 같다.</em></p>

<p>좋은 객체는 모든 메서드가 각각 모든 인스턴스 변수를 사용하고 있다 (100%는 어렵다).</p>

<h3 id="문서를-작성하는-대신-테스트를-만들어라">문서를 작성하는 대신 테스트를 만들어라</h3>

<p>주석이 없어도 클래스명과 메서드만을 봐도 무슨일을 하는지 알 수 있게,<br />
테스트를 통해  메서드의 의도를 알도록 하라.</p>

<p>깔끔하게 만든다라는 것은 단위 테스트도 만든다는 의미이다.<br />
단위 테스트는 클래스의 일부이고 독립적인 개체가 아니다.</p>

<h3 id="생성자에-코드를-넣지-마세요">생성자에 코드를 넣지 마세요</h3>

<p>인자에 손을 대지 말라는 의미이다.</p>

<ul>
  <li>잘못된 예시</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">dlr</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>생성자에 코드가 있을 경우 객체 변환과 관련한 예외를 제어할 수 없다.</p>

<ul>
  <li>좋은 예시</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringAsInteger</span><span class="o">(</span><span class="n">dlr</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringAsInteger</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">source</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">StringAsInteger</span><span class="o">(</span><span class="n">String</span> <span class="n">txt</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">source</span> <span class="o">=</span> <span class="n">txt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">intValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">source</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>이렇게 리팩토링을 하면 실제로 객체를 사용하는 시점까지의 객체 변환 작업은 연기된다.<br />
생성자에 코드가 없을 경우 성능 최적화가 더 쉬워 실행 속도가 더 빨라진다.</p>

<p>진정한 객체지향에서 인스턴스화란 더 작은 객체들을 조합해서 더 큰 객체를 만드는 것이다.</p>

<p>객체의 변환을 뒤로 미뤄 파싱이 여러번 실행되지 않도록  데코레이터(decorator)를 추가해 파싱 결과를 캐싱할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CachedNumber</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">origin</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cached</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">);</span>
    <span class="kd">public</span> <span class="nf">CachedNumber</span><span class="o">(</span><span class="n">Number</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>
<span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">intValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">intValue</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CachedNumber</span><span class="o">(</span><span class="k">new</span> <span class="n">StringAsInteger</span><span class="o">(</span><span class="n">dlr</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>


	  ]]></description>
	</item>

	<item>
	  <title>📖 Java 람다의 변수 범위</title>
	  <link>//Java-%EB%9E%8C%EB%8B%A4%EC%9D%98-%EB%B3%80%EC%88%98-%EB%B2%94%EC%9C%84</link>
	  <author></author>
	  <pubDate>2021-03-19T19:18:00+09:00</pubDate>
	  <guid>//Java-%EB%9E%8C%EB%8B%A4%EC%9D%98-%EB%B3%80%EC%88%98-%EB%B2%94%EC%9C%84</guid>
	  <description><![CDATA[
	     <h3 id="람다의-변수-범위">람다의 변수 범위</h3>

<p><img src="https://user-images.githubusercontent.com/43840561/111862130-956d4c80-8996-11eb-9abd-c2bef47886d9.png" alt="image" /></p>

<p>물론 위의 코드는 미션을 위해 일단 구현만을 목적으로 많은 리팩토링이 필요하니 참고 🥲<br />
미션을 진행하다가 for 문 내에 stream을 쓰게 되었는데, i의 값을 람다식 내에서 사용하려니 컴파일 에러가 났다.<br />
“Variable used in lambda expression should be final or effectively final”
즉 람다식에서 사용되는 변수는 final이거나 effectively final이어야 한다.</p>

<p>effectively final은 무엇이며, 람다의 변수 범위를 정확히 짚고 넘어가자.</p>

<h3 id="람다의-변수-범위-1">람다의 변수 범위</h3>

<p>다음과 같은 Lambda 클래스가 있고, 각각의 메서드를 호출해 클래스 필드인 <code class="highlighter-rouge">name</code>이 어떻게 바뀌는지 살펴본다 🔎</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lambda</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">example1</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">example2</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">10</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">example3</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">15</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/43840561/111862546-58568980-8999-11eb-8fb0-6ac25fc92285.png" alt="image" /></p>

<p>이에 대한 출력 결과는 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111862548-5ee50100-8999-11eb-9962-0697067614f8.png" alt="image" /></p>

<p>위 예제에서 람다식에서는 자신을 감싼 메서드나 클래스에 속한 변수에 접근을 할 수 있다.<br />
예제는 람다에 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수를 사용하고 있는데 이러한 변수를 <strong>자유 변수</strong>라고 부른다.</p>

<p>그렇다면 다시 맨 처음 오류를 가져와서 … 
<img src="https://user-images.githubusercontent.com/43840561/111862130-956d4c80-8996-11eb-9abd-c2bef47886d9.png" alt="image" /></p>

<p>이 부분에서 왜 자유 변수인 i를 final이나 effectvely final로 선언하라는 것일까 ?</p>

<p>먼저 <strong>지역 변수</strong>는 JVM에서 스택 영역에 저장이 된다. <br />
그리고 실제 메모리와 다르게 JVM에서 이 스택 영역은 스레드 마다 별도의 스택이 생성된다. <br />
따라서 지역 변수는 한 스레드 안에서만 사용이 되며, 스레드끼리 공유하지 못한다.</p>

<p>지역 변수와 다르게 인스턴스 변수는 힙 영역에 생성되어 서로 다른 스레드끼리도 공유할 수 있는 공유 변수이다.</p>

<p><strong>람다</strong>는 각각 별도의 스레드에서 실행이 가능하다.<br />
위 예제에서 각각의 메서드는 i를 증가시키는 것이 아니라 람다를 리턴할 뿐이다.<br />
실행 흐름 상 메서드를 호출한 스레드의 스택에 지역 변수인 i가 생성이 되는데,<br />
람다식을 반환한 후에는 해당 함수가 종료되었으니 메모리에서 i가 사라질 것이다. <br />
그렇지만 반환된 람다식은 다른 스레드에서 호출될 수 있는데, i가 GC에 의해 정리되어 접근할 수 없는 문제가 발생할 수 있다.</p>

<p>때문에 실행 시점에 지역 변수가 사라질 것을 방지하기 위해서 이 자유 변수의 복사본을 만들어서 동작한다. 
이 복사본을 가지고 동작할 예정인데, 이 복사본 값이 바뀌어 버리면 의도하지 않은 결과가 생길 수 있으므로 컴파일 단계에서<br />
final 또는 effectively final로 선언해 변수를 신뢰할 수 있게 만드는 것이다.<br />
이를 <strong>람다 캡처링</strong>이라고 한다.</p>

<p>위 문제에서 컴파일 에러가 뜨는 것은 i가 스코프 밖에 있어 값이 변할 수 있어 신뢰할 수 없다.<br />
때문에 인텔리제이가 권해주는 방법을 쓰면 i를 스코프 안 변수에 새로 할당해서 사용하게 된다.<br />
<img src="https://user-images.githubusercontent.com/43840561/111863899-7de79100-89a1-11eb-8ed3-6c685817269d.png" alt="image" /></p>

<p>여기서 i는 <code class="highlighter-rouge">final</code> 로 선언되지는 않았지만, 자바 8에서 추가된 effectively final로 선언된 것이다.<br />
effectively final은 final로 선언되지 않아도 컴파일러가 해당 변수가 변경되지 않았다고 판단할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111863962-d61e9300-89a1-11eb-85f8-b7e0a7d5ef7e.png" alt="image" /></p>

<p>만약 effectively final인 i의 값을 바꾸려 한다면 이렇게 컴파일 오류가 발생한다.</p>

<p>파도 파도 끝없는 람다의 세계 🤸‍♀️</p>

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://perfectacle.github.io/2019/06/30/java-8-lambda-capturing/">(Java) 람다 캡처링과 final 제약조건</a></li>
  <li><a href="https://futurecreator.github.io/2018/08/02/java-lambda-variable-scope/">Java Lambda (5) 변수 범위</a></li>
  <li><a href="https://jeong-pro.tistory.com/211">자바 람다에서 final이거나 final처럼 쓰인 지역 변수만 접근할 수 있는 이유</a></li>
</ul>

<hr />

<h3 id="enum-map">Enum Map</h3>


	  ]]></description>
	</item>

	<item>
	  <title>📝 Java8 Lambda, Stream API 강의 정리</title>
	  <link>//Java8-Lambda,-Stream-API-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</link>
	  <author></author>
	  <pubDate>2021-03-16T19:18:00+09:00</pubDate>
	  <guid>//Java8-Lambda,-Stream-API-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</guid>
	  <description><![CDATA[
	     <h2 id="함수형-프로그래밍의-장점-">함수형 프로그래밍의 장점 ?</h2>

<h3 id="관심사의-분리">관심사의 분리</h3>

<p>관심사의 분리란 무엇일까? 예제를 들어보자.</p>

<p><code class="highlighter-rouge">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);</code> 리스트에 있는 <strong>원소마다 콜론을 추가</strong>하려 한다.</p>

<h4 id="이때-foreach-를-사용한다면-">이때 <code class="highlighter-rouge">forEach()</code> 를 사용한다면 ?</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">ForEach</span><span class="err">를</span><span class="n">_</span><span class="err">활용하여</span><span class="n">_</span><span class="err">콜론을</span><span class="n">_</span><span class="err">추가하는</span><span class="n">_</span><span class="err">문자열</span><span class="n">_</span><span class="err">작성</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">StringBuilder</span> <span class="n">stringBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="n">Integer</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">number</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">" : "</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">3</span><span class="o">,</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>나는 <strong>원소마다 콜론 추가하는 것</strong>을 원하는데, forEach문을 작성하니 이를 어떻게(How) 구현할지에 집중하고 있는 것 같다.</p>

<h4 id="그렇다면-함수형-프로그래밍의-일종인-stream을-사용한다면-">그렇다면 함수형 프로그래밍의 일종인 Stream을 사용한다면 ?</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="n">Stream</span><span class="err">을</span><span class="n">_</span><span class="err">활용하여</span><span class="n">_</span><span class="err">콜론을</span><span class="n">_</span><span class="err">추가하는</span><span class="n">_</span><span class="err">문자열</span><span class="n">_</span><span class="err">작성</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">valueOf</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">joining</span><span class="o">(</span><span class="n">COLON_DELIMITER</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>요소마다 콜론을 결합하는 것</strong>을 메소드를 사용함으로서 개발자인 내가 무엇을(What)을 수행할 것인지에 집중할 수 있다.</p>

<h3 id="side-effect가-발생하지-않는다">Side Effect가 발생하지 않는다.</h3>

<ul>
  <li>Side Effect란 ? 함수 내의 실행으로 인해 함수 외부가 영향을 받는 것</li>
</ul>

<p>함수형 프로그래밍의 특징은 지역 변수만을 변경할 수 있고, 매개변수를 변경하지 않는다. <br />
즉, 함수는 같은 인수값으로 함수를 호출했을 때 항상 같은 값을 반환한다. (이 때 다른 값을 반환하는 Random, Scanner 등은 함수가 아니다).<br />
만약 함수에 참조하는 객체가 있다면 그 객체는 불변이어야 하며, 해당 객체의 모든 참조 필드도 불변 객체를 직접 참조해야 한다. <br />
함수 내에서 생성한 객체의 필드는 갱신할 수 있지만, 새로 생성한 필드의 갱신은 외부에 노출되면 안된다. <br />
또한 다음에 메서드를 다시 호출한 결과에 영향을 미치지 않으며, 어떠한 예외도 일으키지 않아야 한다. <br />
값이 변경되는 것을 허용한 객체를 멀티 스레드 프로그램에서 접근한다면, 값이 일정하지 않을 것이다.</p>

<p>하지만 단순히 구조만으로 순수성이 보장되지는 않고, 입력에 참조값이 오는 경우는 Side-Effect가 생긴다. 
이에 대한 내용은 <strong>참조 투명성</strong>을 살펴보자.</p>

<h4 id="참조-투명성">참조 투명성</h4>

<p>참조 투명성은 함수가 함수 외부의 영향을 받지 않는 것을 의미한다.<br />
또, 함수의 결과는 입력 파라미터에만 의존하고, 함수 외부 세계(입력 콘솔, 파일, 데이터 베이스 등)에서 데이터를 읽지 않는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">a</span><span class="o">++;</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 예제의 경우 원시 타입인 a의 값을 바꾸었는데, 자바의 원시타입의 매개변수는 call by value (메서드 호출 시 기본 자료형의 값을 인자로 전달하는 방식) 형태로 전달이 되어, 함수를 벗어나도 a에는 영향이 없다.<br />
여기서 인자로 참조 변수를 넣어주면 어떤 일이 발생할 수 있을까?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">position</span><span class="o">(</span><span class="n">Position</span> <span class="n">a</span><span class="o">,</span> <span class="n">Position</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">a</span><span class="o">.</span><span class="na">setX</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">getX</span><span class="o">())</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 참조 변수를 넘겨주면 함수 안에서 참조 변수의 값을 바꿀 수도 있기 때문에 side effect가 발생할 수 있다.<br />
함수형 프로그래밍은 이런 Side Effect가 발생하지 않는, 참조 투명성이어야 한다.</p>

<h3 id="일급-객체">일급 객체</h3>

<p>함수형 프로그래밍은 함수인 메서드가 일급 객체임을 말하는데, 일급 객체는 다음과 같은 특성을 가진다.</p>

<ul>
  <li>변수나 데이터에 할당할 수 있어야 한다.</li>
  <li>객체의 매개변수로 넘길 수 있어야 한다.</li>
  <li>객체의 반환 값으로 리턴할 수 있어야 한다.</li>
</ul>

<p>자바8 이전까지, 메서드는 일급 객체가 아니었지만, 자바8의 익명 함수의 등장으로 메서드도 일급 객체로 다룰 수 있게 되었다.<br />
또 이 익명 함수를 좀 더 단순화 한 것이 바로 람다 표현식(lambda expression)이다.</p>

<h3 id="boxing과-unboxing">Boxing과 UnBoxing</h3>

<p>원시 타입이 래퍼 클래스로 변환하는 것을 Boxing이라고 하며,<br />
래퍼 클래스를 원시 타입으로 형변환 하는 것을 UnBoxing이라고 한다. <br />
JDK1.5부터는 래퍼 클래스와 기본 자료형 사이의 변환을 자동으로 해주는 Auto Boxing과 Auto UnBoxing 기능을 지원한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">Integer</span> <span class="n">integer</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// Auto Boxing</span>
<span class="n">Integer</span> <span class="n">integer1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">777</span><span class="o">);</span> <span class="c1">// 명시적 Boxing</span>

<span class="kt">int</span> <span class="n">primitive</span> <span class="o">=</span> <span class="n">integer</span><span class="o">;</span> <span class="c1">// Auto UnBoxing</span>
</code></pre></div></div>

<p>#### Auto Boxing이 일어나는 예</p>

<p>자바에서는 래퍼 클래스에 대한 연산이 시도될 때, 연산을 하려는 두 객체를 Auto Unboxing을 하여 원시타입으로 변환 후,<br />
연산을 수행하게 된다. 래퍼 클래스와 원시 타입 간 연산도 동일하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="n">Integer</span> <span class="n">integer127</span> <span class="o">=</span> <span class="mi">127</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
  <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">127</span><span class="o">)</span>
  <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">integer127</span><span class="o">)</span>
  <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
<span class="o">);</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
  <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">128</span><span class="o">)</span>
  <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">integer127</span><span class="o">))</span>
  <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
<span class="o">);</span>
</code></pre></div></div>

<p>두 스트림 연산에서 원시 타입 <code class="highlighter-rouge">int</code> 인 값들의 Stream을 만들고 각각 래퍼 클래스 <code class="highlighter-rouge">Integer</code> 와 비교를 할 때 Auto Boxing이 일어난다.<br />
이때, <code class="highlighter-rouge">findFirst().get()</code> 을 하게 된다면 래퍼 클래스가 반환된다.<br />
이렇게 되면 각각 원시 타입에 Auto Boxing이 일어나니, <br />
원시 타입에 대한 스트림은 기본형 특화 스트림 (IntStream, LongStream, DoubleStream)을 사용하는 것이 성능상 좋다.</p>

<p>➕ 수업 예제에서 이 부분이 왜 127과 128로 나누었을까 크루들이랑 이야기를 했다.<br />
Integer 래퍼 클래스는 127까지 인스턴스를 미리 생성해 두기 때문에 <code class="highlighter-rouge">==</code> 연산자로도 비교가 가능하지만 (주소값을 비교하는 것이다),<br />
128부터는 새로운 인스턴스를 반환하기 때문에 동일성 검사인 <code class="highlighter-rouge">equals()</code> 를 사용해 반환한다.</p>

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://jinwooe.wordpress.com/2017/12/21/%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC-side-effect-%EC%B0%B8%EC%A1%B0-%ED%88%AC%EB%AA%85%EC%84%B1-referential-transparency/">부수 효과 (Side Effect), 참조 투명성 (Referential Transparency)</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>📖 Functional Interface</title>
	  <link>//Functional-Interface</link>
	  <author></author>
	  <pubDate>2021-03-06T19:18:00+09:00</pubDate>
	  <guid>//Functional-Interface</guid>
	  <description><![CDATA[
	     <h2 id="함수형-인터페이스">함수형 인터페이스</h2>
<p>자바 8부터 자바는 객체지향 언어일 뿐만 아니라 함수형 언어도 지원할 수 있게되었다.</p>

<p>자바에서는 숫자, 문자 같은 원시 타입, 클래스를 통해 정의하는 참조 타입 객체들이<br />
일급 객체가 될 수 있지만, <br />
(함수형 인터페이스가 등장하기 전까지는) 함수에 해당하는 메서드는 일급 객체가 아니었다.</p>

<p>덕분에 오늘 뜯어 볼 Functional Interface의 등장으로,<br />
객체 안에만 존재했던 함수(메서드)를 일급 객체로 다룰 수 있게되었다.</p>

<p><strong>🤔 일급 객체…?</strong><br />
어떤 개체가 다음 3가지 조건을 만족하는 경우, 이를 일급 객체라고 말한다.</p>

<ul>
  <li>파라미터로 전달할 수 있다.</li>
  <li>반환값으로 사용할 수 있다.</li>
  <li>변수나 데이터 구조 안에 담을 수 있다.</li>
  <li>할당에 사용된 이름과 관계없이 고유한 구별이 가능하다.</li>
</ul>

<p>자세한 내용은 <a href="https://isooo.github.io/etc/2019/11/13/%EC%9D%BC%EA%B8%89%EA%B0%9D%EC%B2%B4.html">이 글</a>을 참고하면 좋을 것 같다.</p>

<h3 id="함수형-인터페이스-정의하기">함수형 인터페이스 정의하기</h3>
<p>인터페이스에 추상 메소드가 딱 하나만 존재하는 것을 함수형 인터페이스라고 한다.<br />
자바의 람다식은 함수형 인터페이스를 통해서만 다뤄진다.<br />
함수형 인터페이스는 람다식과 인터페이스 메소드가 1:1로 연결되기 위해, <br />
<strong>추상 메소드가 단 하나뿐인 인터페이스</strong>이다.<br />
(static, defualt 메서드는 제외다.)</p>

<p>자바에서는 이를 <code class="highlighter-rouge">@FunctionalInterface</code> 어노테이션을 사용하여 나타낸다.<br />
참고로 어노테이션을 붙일 경우 컴파일러에서 어노테이션이 붙은 엔티티가 <br />
단일 추상메서드를 갖춘 인터페이스인지 검사하니 붙이도록 하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">Calculate</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="nf">cal</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="미리-정의되어-있는-함수형-인터페이스">미리 정의되어 있는 함수형 인터페이스</h2>
<h3 id="javautilfunction-패키지">java.util.function 패키지</h3>
<p>제네릭 메서드로 정의한다면, 매개변수나 반환 타입이 달라도 문제가 되지 않는다.<br />
때문에 자바 패키지에서는 자주 쓰이는 형식의 메서드를 함수형 인터페이스로<br />
미리 정의해 놓았다.<br />
사실 매번 람다식을 위해 함수형 인터페이스를 정의하는 것은 귀찮은 일이니<br />
가급적 이 패키지의 함수형 인터페이스를 사용하자!</p>

<h4 id="표준으로-정의된-대표적-함수형-인터페이스와-그-안에-있는-추상-메소드">표준으로 정의된 대표적 함수형 인터페이스와 그 안에 있는 추상 메소드</h4>

<table>
  <thead>
    <tr>
      <th>함수형 인터페이스</th>
      <th>추상 메서드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">Predicate&lt;T&gt;</code></td>
      <td><code class="highlighter-rouge">boolean test(T t)</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Supplier&lt;T&gt;</code></td>
      <td><code class="highlighter-rouge">T get()</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Consumer&lt;T&gt;</code></td>
      <td><code class="highlighter-rouge">void accept(T t)</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">Funtion&lt;T, R&gt;</code></td>
      <td><code class="highlighter-rouge">R apply(T t)</code></td>
    </tr>
  </tbody>
</table>

<h3 id="predicatet"><code class="highlighter-rouge">Predicate&lt;T&gt;</code></h3>

<p>매개변수 타입 T, 반환타입 Boolean</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">test</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span> 
</code></pre></div></div>
<ul>
  <li>매개변수가 2개인 경우 <code class="highlighter-rouge">BiPredicate&lt;T, U&gt;</code></li>
</ul>

<p>전달된 인자를 대상으로 true, false를 반환해야하는 상황에 유용하게 사용된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">PredicateDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">sum</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">lst</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">lst</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>       
        
        <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="o">);</span>
    
        <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">sum</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"짝수 합: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">sum</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"홀수 합: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">sum(Predicate&lt;Integer&gt; p, List&lt;Integer&gt; lst)</code>에는 <br />
<code class="highlighter-rouge">boolean test(Integer t)</code> 메소드 정의에 해당하는 람다식을 작성해서 전달해야한다.</p>

<h3 id="suppliert"><code class="highlighter-rouge">Supplier&lt;T&gt;</code></h3>
<p>매개변수 없음, 반환 타입 T</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span> <span class="nf">get</span><span class="o">();</span>
</code></pre></div></div>
<p>단순히 무언가를 반환해야 할 때 사용된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">SupplierDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">makeIntList</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>    
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">spr</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
        <span class="o">};</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">makeIntList</span><span class="o">(</span><span class="n">spr</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>

        <span class="n">list</span> <span class="o">=</span> <span class="n">makeIntList</span><span class="o">(</span><span class="n">spr</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">makeIntList(Supplier&lt;Integer&gt; s, int n)</code> 는 정수를 담고 있는 컬렉션 인스턴스를 반환한다. <br />
첫 번째 인자에서 컬렌션 인스턴스에 담을 정수의 생성 방법을 결정할 수 있다.</p>

<h3 id="consumert"><code class="highlighter-rouge">Consumer&lt;T&gt;</code></h3>
<p>매개변수 타입 T, 반환 타입 없음</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span>
</code></pre></div></div>
<ul>
  <li>매개변수가 2개일 경우 <code class="highlighter-rouge">BiConsumer&lt;T, U&gt;</code></li>
</ul>

<p>전달 인자를 소비하는 형태로 매개변수와 반환형이 선언되어 있다.<br />
전달된 인자를 가지고 어떤 결과를 보여야 할 때 유용하게 사용된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ConsumerDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Consumer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        
        <span class="n">c</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">"Pineapple"</span><span class="o">);</span>    <span class="c1">// 출력이라는 결과를 보인다.</span>
        <span class="n">c</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">"Strawberry"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="funtiont-r"><code class="highlighter-rouge">Funtion&lt;T, R&gt;</code></h3>
<p>매개변수 타입 T, 반환타입 R</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">R</span> <span class="nf">apply</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span>
</code></pre></div></div>
<ul>
  <li>매개변수가 2개인 경우  <code class="highlighter-rouge">BiFunction&lt;T, U, R&gt;</code></li>
</ul>

<p>전달한 인자와 반환 값이 모두 존재하는 가장 보편적인 형태이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FunctionDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
    <span class="n">Function</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">toInt</span> <span class="o">=</span> <span class="n">value</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>

    <span class="n">Integer</span> <span class="n">number</span> <span class="o">=</span> <span class="n">toInt</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"100"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="함수형-인터페이스의-장점">함수형 인터페이스의 장점?</h3>
<p>이 부분은 여러 자료를 찾아보면서 스스로 생각해본 부분이다.</p>
<h4 id="간결한-표현과-가독성">간결한 표현과 가독성</h4>
<h4 id="행위도-값value처럼-쓰일-수-있다">행위도 값(value)처럼 쓰일 수 있다</h4>
<p>1~100까지의 짝수 합을 구하는 로직을 함수형 인터페이스를 사용하지 않고,<br />
함수형 인터페이스를 사용하여 두 가지 코드를 확인해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">evenSum</span><span class="o">()</span> <span class="o">{</span>  
   <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
         <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">evenSum</span><span class="o">()</span> <span class="o">{</span>  
   <span class="k">return</span> <span class="n">IntStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
         <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span><span class="mi">0</span><span class="o">)</span>
         <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">filter()</code>의 선언부를 보면 다음과 같다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/36ce9ae6-d645-4754-9b55-408a3509599a/image.png" style="zoom:50%;" /></p>

<p><code class="highlighter-rouge">Predicate&lt;&gt;</code> 함수형 인터페이스를 받기 때문에 조건에 대한 함수를 매개변수로 받아,<br />
행위 자체를 값으로 받고 있다.<br />
또한 이 덕분에 filter()에 매개변수로 행위가 어떤 것인지 람다식으로 명시적으로 드러내며 <br />
넘겨주기 때문에 직관성을 높인다고도 생각한다. (맞는지는 모르겠으나 개인적 생각🥲)</p>

<p>함수형 인터페이스의 명확한 장점을 말하고 싶은데,<br />
잘 정리가 안된다.<br />
이에 대해 <a href="http://ruaa.me/why-functional-matters/">함수형 프로그램의 장점</a>을 읽어 보는 것이 좋을 것 같다(❓)</p>
<h2 id="참고-자료">참고 자료</h2>
<ul>
  <li><a href="https://jogeum.net/18">자바로 함수형 인터페이스 사용하기 (Functional Interface)</a></li>
  <li><a href="https://woowacourse.github.io/javable/post/2020-07-17-Functional-Interface/">Functional Interface란</a></li>
  <li><a href="http://ruaa.me/why-functional-matters/">왜 함수형 프로그래밍이 좋을까?</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>1</title>
	  <link>//1</link>
	  <author></author>
	  <pubDate>2021-03-05T19:18:00+09:00</pubDate>
	  <guid>//1</guid>
	  <description><![CDATA[
	     <h2 id="추상-클래스">추상 클래스</h2>

<p><strong>간단히 말하면…</strong><br />
클래스를 설계도라 하면, 추상 클래스는 <strong>미완성 설계도</strong>에 비유할 수 있다.<br />
(여기서 클래스가 미완성이라는 것은 추상 메서드를 포함하고 있다는 의미이다.)</p>

<p>예를 들면, 같은 크기의TV라도 기능의 차이에 따라 여러 종류의 모델이 있지만<br />
설계도 90은 동일할테니, 어느정도 틀을 갖춘 상태에서 진행하는 것이 좋다.<br />
이때 사용할 수 있는 것이 <strong>추상 클래스</strong>이다.</p>

<h4 id="추상-메서드-">추상 메서드 ?</h4>

<p>선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다.<br />
추상 메서드는 상속받는 클래스에 따라 달라질 수 있다.</p>

<h3 id="추상-클래스-규칙">추상 클래스 규칙</h3>

<ul>
  <li>추상 클래스는 키워드 <code class="highlighter-rouge">abstract</code>를 붙여 표현한다.
추상 메서드를 포함하지 않은 클래스에서도 <code class="highlighter-rouge">abstract</code>를 붙여서 추상 클래스로 지정할 수도 있다.</li>
  <li>클래스를 abstract로 지정하면 <code class="highlighter-rouge">new</code>를 통해 객체를 직접 생성할 수 없다.</li>
  <li>메소드에 abstract를 사용할 경우 interface의 메소드와 같이 구현 부분은 없다.</li>
  <li>abstract로 선언한 메소드를 자식 클래스에서 반드시 구현해야 한다. (오버라이딩)
이는 자식 클래스에서 추상 메서드를 반드시 구현하도록 강제하는 것이다.</li>
</ul>

<p>다음 예제를 보면서 추상 클래스에 대해 알아보자 !</p>

<h4 id="exmaple">Exmaple</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Player</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">pause</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">currentPos</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Player</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pause</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">currentPos</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 지정된 위치에서 재생을 시작하는 기능 수행되도록 작성</span>
    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">(</span><span class="kt">int</span> <span class="n">pos</span><span class="o">);</span>
    <span class="c1">// 재생을 즉시 멈추는 기능을 수행하도록 작성</span>
    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">pause</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pause</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pause</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">play</span><span class="o">(</span><span class="n">currentPos</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">pause</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">stop</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Player 추상 클래스는 <br />
VCR이나 Audio 같은 재생이 가능한 기기의 부모 클래스가 될 수 있다.<br />
이제 Player 추상 클래스를 상속받는 CDPlayer 클래스를 만들어보자 🔨</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CDPlayer</span> <span class="kd">extends</span> <span class="n">Player</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">play</span><span class="o">(</span><span class="kt">int</span> <span class="n">pos</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 구현 생략</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 구현 생략</span>
    <span class="o">}</span>

    <span class="c1">//CDPlayer 클래스에 추가로 정의된 멤버</span>
    <span class="kt">int</span> <span class="n">currentTrack</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">nextTrack</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">currentTrack</span><span class="o">++;</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">preTrack</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">currentTrack</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">currentTrack</span><span class="o">--;</span>
        <span class="o">}</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>부모 클래스의 추상메서드를 CDPlayer에 맞게 오버라이딩해주고, <br />
CDPlayer만의 새로운 멤버들을 추가해주었다.</p>

<h2 id="인터페이스">인터페이스</h2>

<p><strong>간단히 말하면…</strong><br />
인터페이스는 일종의 추상 클래스로, 추상 메서드를 갖지만 <br />
추상 클래스보다 추상화 정도가 높아<br />
추상 클래스와 달리 몸통을 갖춘 일반 메서드, 멤버 변수를 구성원으로 가질 수 없다.<br />
추상 클래스를 미완성 설계도라 하면, 인터페이스는 구현된 것은 아무 것도 없는, <br />
밑그림만 그려진 <strong>기본 설계도</strong>라고 할 수 있다.</p>

<h3 id="인터페이스-규칙">인터페이스 규칙</h3>

<ul>
  <li>추상 클래스처럼 불완전한 것이기 때문에 그 자체만으로 사용되기 보다,
다른 클래스를 작성하는데 도움을 줄 목적으로 작성된다.</li>
  <li>일반 메서드 또는 멤버 변수를 구성원으로 가질 수 없다.</li>
  <li>모든 멤버 변수는 <code class="highlighter-rouge">public static final</code>이어햐 하며, 이를 생략할 수 있다.</li>
  <li>모든 메서드는 <code class="highlighter-rouge">public abtract</code>이어야 하며, 이를 생략할 수 있다.
(단, JDK1.8부터 static 메서드와 default 메서드를 사용할 수 있다.)</li>
</ul>

<p><strong>🤔 public static final의 사용 목적 ?</strong><br />
인터페이스 변수는 아무 인스턴스도 존재하지 않는 시점이기 떄문에 스스로 초기화 될 권한이 없다.<br />
때문에 <code class="highlighter-rouge">public static final</code>를 사용해 구현 객체의 같은 상태를 보장한다.</p>

<h3 id="인터페이스의-다중-상속">인터페이스의 다중 상속</h3>

<p>인터페이스는 인터페이스로부터만 상속받을 수 있으며,<br />
클래스와 달리 다중상속을 받는 것이 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Movable</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">move</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Attackable</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">attack</span><span class="o">(</span><span class="n">Unit</span> <span class="n">u</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Fightable</span> <span class="kd">extends</span> <span class="n">Movable</span><span class="o">,</span> <span class="n">Attackable</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p>클래스의 상속과 마찬가지로 자식 인터페이스는 부모 인터페이스에 정의된 멤버 모두 상속받는다.</p>

<p><strong>인터페이스가 다중 상속이 가능한 이유는?</strong>
인터페이스는 abstract 메소드만을 가지고 있는데,<br />
이를 상속할 경우 상속하는 클래스에서 무조건 그 메서드를 구현해주어야 하는데,<br />
이 경우 다중 상속하고 있는 인터페이스들에 동일한 메서드가 존재한다 하더라도,<br />
그 내부 구현은 정의되지 않았으니 문제될 것이 없기 때문이 아닐까 한다.</p>

<p>그런데 이제 인터페이스에서 default 메서드를 구현할 수 있는데<br />
두개의 인터페이스를 다중 상속하는 경우, <br />
이 default 메소드가 중복이 되면 어떻게 되는거지?</p>

<p>이 질문에 대한 답을 테스트 해보았다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/3bff8105-2d84-4583-ad1b-e208b362f524/image.png" style="zoom:50%;" /></p>

<p>동일한 <code class="highlighter-rouge">printStatic()</code> 을 가진 인터페이스 C와 B를 상속하는 <br />
인터페이스 A는 <code class="highlighter-rouge">printStatic()</code>를 무조건 오버라이딩하게 되어 있었다…<br />
만약 중복 메서드가 없을 경우 오버라이딩을 하지 않아도 컴파일 에러가 나지 않는다.</p>

<h4 id="-tip">🍯 Tip</h4>

<p>인터페이스 명은 대부분 “~을 할 수 있는”의 의미인 <code class="highlighter-rouge">able</code>로 끝나는 것들이 많다고 한다.<br />
그 이유는 어떤 기능 또는 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서다.<br />
때문에 그 인터페이스를 구현하는 클래스는 “~를 할 수 있는” 능력을 갖추었다는 의미이기도 하다.</p>

<h2 id="추상-클래스-vs-인터페이스">추상 클래스 VS 인터페이스</h2>

<h4 id="공통점-">공통점 ?</h4>

<p>먼저 추상 클래스와 인터페이스의 공통점을 찾아보자. <br />
추상 클래스와 인터페이스 둘 다 <strong>가지고 있는 추상 메서드를 구현하도록 강제한다.</strong><br />
또 <strong>인스턴스화가 불가능</strong>하다.</p>

<p>그렇다면 추상 클래스 안에 원하는 것만 추상 메서드를 여러개 두거나,<br />
전부 추상 메서드로 만들면 되어 추상 클래스가 인터페이스 역할을 할 수 있다.<br />
만약 모든 클래스가 인터페이스만 사용해서 구현한다면,<br />
모든 클래스에서 공통으로 필요한 기능들은 각각 오버라이딩 하게 되니 코드의 중복이 발생한다.<br />
때문에 이 공통으로 필요한 기능들을 부모 클래스에서 일반 메서드로 구현한<br />
추상클래스를 상속 받아 자식 클래스에서 사용할 수 있도록 하면 될거같은데…<br />
<strong>왜 인터페이스는 왜 필요한걸까? 🤔</strong></p>

<h3 id="접근자">접근자</h3>

<p><strong>인터페이스</strong>에서 모든 변수는 <code class="highlighter-rouge">public static final</code>, <br />
모든 메소드는 <code class="highlighter-rouge">public abstract</code>이다.<br />
하지만 <strong>추상 클래스</strong>에서는 <code class="highlighter-rouge">static</code>이나 <code class="highlighter-rouge">final</code>이 아닌 필드를 가질 수 있고, <br />
<code class="highlighter-rouge">public, protected, private</code> 모두 가질 수 있다.</p>

<p>개인적인 생각으로는 인터페이스만을 구현하면 <code class="highlighter-rouge">public static final</code>만을 사용해<br />
구현 객체의 같은 상태를 공유할수 밖에 없는데,<br />
추상 클래스는 <code class="highlighter-rouge">static</code>이나 <code class="highlighter-rouge">final</code>이 아닌 필드또한 가질 수 있기 때문에 <br />
추상 클래스를  상속 받은 객체들이 같은 상태를 가지고 있을 수 있다.</p>

<h3 id="다중-상속-여부">다중 상속 여부</h3>

<p><strong>인터페이스</strong>를 구현하는 클래스는 다른 여러개 인터페이스를 함께 구현할 수 있다.<br />
하지만 자바에서는 다중 상속을 지원하지 않기 때문에 여러 추상 클래스를 상속할 수 없다.</p>

<h3 id="사용-의도">사용 의도</h3>

<p>물론 다중 상속 여부의 차이는 있지만 이것이 포인트가 아니라,<br />
이에 따른 사용 목적이 다르다는 것에 포인트를 맞춰보자.<br />
위에서 말한 다중 상속 여부에 따라 추상 클래스와 인터페이스의 사용 의도 또한 다르다.</p>

<p><strong>추상 클래스</strong>는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로,<br />
상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며 <br />
부모 클래스가 가진 기능들을 구현해야할 경우 사용한다.</p>

<p><strong>인터페이스</strong>는 상속 관계를 타고 올라갔을 때 <br />
다른 조상 클래스를 상속하더라도, 같은 기능이 필요할 경우 사용한다.<br />
클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용한다.</p>

<h4 id="exmaple-1">Exmaple</h4>

<p>아래와 같은 관계를 갖는 예제를 살펴본다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/af9d99ef-28f2-483f-a261-161cb979fb4a/image.png" style="zoom:50%;" /></p>

<p>제일 부모 클래스인 Creature은 생물에 대한 Abstract Class이다.<br />
각 생물은 구분에 따라 Animal 또는 Plant를 상속한다.<br />
그리고 각각이 할 수 있는 추가적인 기능들을 인터페이스로 구현했다.</p>

<p>Animal을 상속받는 Amazzi(나^^), Dog, Cat은 Plant와 다르게<br />
bark(짖다) 할 수 있으니 Barkable 인터페이스를 구현하였다.</p>

<p>여기서 눈여겨 볼 것은 바로 Eatable인데, <br />
Eatable 인터페이스는 현재 상속 관계가 다른 Amazzi(나^^), Dog, Cat, FlyHellPlant에게<br />
공통적인 기능인 Eat 기능을 인터페이스를 사용함으로 같은 기능을 구현하도록 강제하고 있다.</p>

<p>그러면 결국 이 4가지 클래스 모두 생물 클래스를 상속하고 있는데,<br />
생물 클래스에 eat이라는 추상 메서드를 만들면 안되는가?라고 생각할 수 있지만<br />
Plant를 상속받은 Rose는 eat 메소드를 가질 수 없다.</p>

<p>그러면 어떻게하지 🤷‍♀️</p>

<p>이때 바로 인터페이스로 따로 선언을 해주어 각각 eat을 할 수 있는 <br />
클래스에 implements해주어 만들어 주면 <strong>가독성이 올라가며 유지보수 또한 쉬워진다.</strong></p>

<h3 id="각각의-적절한-사용-케이스-정리">각각의 적절한 사용 케이스 정리</h3>

<h4 id="추상-클래스-1">추상 클래스</h4>

<ul>
  <li>관련성이 높은 클래스 간에 코드를 공유하고 싶은 경우</li>
  <li>추상 클래스를 상속 받을 클래스들이 공통으로 가지는 메소드와 필드가 많거나, 
public이외의 접근자(protected, private) 선언이 필요한 경우</li>
  <li>non-static, non-final 필드 선언이 필요한 경우 (각 인스턴스에서 상태 변경을 위한 메소드가 필요한 경우)</li>
</ul>

<h4 id="인터페이스-1">인터페이스</h4>

<ul>
  <li>서로 관련성이 없는 클래스들이 인터페이스를 구현하게 되는 경우. 
ex) Comparable, Cloneable 인터페이스는 여러 클래스들에서 구현되는데, 구현클래스들 간에 관련성이 없다.</li>
  <li>특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동이 구현되는지는 신경쓰지 않는 경우.</li>
  <li>다중상속을 허용하고 싶은 경우</li>
</ul>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li>[[JAVA] 추상클래스 VS 인터페이스 왜 사용할까? 차이점, 예제로 확인 :: 마이자몽](</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>📖 상속에 대하여</title>
	  <link>//%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%8B%E1%85%A6-%E1%84%83%E1%85%A2%E1%84%92%E1%85%A1%E1%84%8B%E1%85%A7</link>
	  <author></author>
	  <pubDate>2021-03-04T19:18:00+09:00</pubDate>
	  <guid>//%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%E1%84%8B%E1%85%A6-%E1%84%83%E1%85%A2%E1%84%92%E1%85%A1%E1%84%8B%E1%85%A7</guid>
	  <description><![CDATA[
	     <p>강의시간에 배운 상속 개념에 추가로 공부한 내용을 정리해본다 ✍️</p>

<h2 id="상속">상속</h2>
<p><strong>먼저 상속이란 ?</strong>
기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.<br />
예제를 보명서 상속의 필요성을 파악해보자 !</p>

<h3 id="example">Example</h3>
<p>카페에서 커피와 차를 판매한다.<br />
커피와 차를 준비하는 과정을 살펴보자.</p>

<h4 id="커피">커피</h4>
<ul>
  <li>물을 끓인다.</li>
  <li>커피머신으로 커피를 내린다.</li>
  <li>컵에 붓는다.</li>
  <li>설탕과 우유를 추가한다.
    <h4 id="차">차</h4>
  </li>
  <li>물을 끓인다.</li>
  <li>차 티백을 담근다.</li>
  <li>컵에 붓는다.</li>
  <li>레몬을 추가한다.</li>
</ul>

<p>그렇다면 각각의 과정들을 코드로 구현해본다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Coffee</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">prepareRecipe</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">boilWater</span><span class="o">();</span>
        <span class="n">brewCoffeeMachine</span><span class="o">();</span>
        <span class="n">pourInCup</span><span class="o">();</span>
        <span class="n">addSugarAndMilk</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">boilWater</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"물을 끓인다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">brewCoffeeMachine</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"커피머신으로 커피를 내린다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pourInCup</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"컵에 붓는다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addSugarAndMilk</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"설탕과 우유를 추가한다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tea</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">prepareRecipe</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">boilWater</span><span class="o">();</span>
        <span class="n">steepTeaBag</span><span class="o">();</span>
        <span class="n">pourInCup</span><span class="o">();</span>
        <span class="n">addLemon</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">boilWater</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"물을 끓인다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">steepTeaBag</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"티백을 담근다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pourInCup</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"컵에 붓는다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addLemon</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"레몬을 추가한다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Coffee 클래스와 Tea 클래스를 비교해보면 이상한 점을 느낄 수 있다.<br />
<code class="highlighter-rouge">prepareRecipe()</code>, <code class="highlighter-rouge">boilWater()</code>, <code class="highlighter-rouge">pourInCup()</code> <br />
이 세가지 메소드는 공통된 기능을 하지 않는가??</p>

<p>그렇다면 “이 중복된 부분을 어떻게 제거하느냐?”에 대한 해답으로<br />
바로 <strong>상속</strong>이 나온다.</p>

<p>그렇다면 두 클래스에서 공통된 부분을 추출하여 부모 클래스를 만들어본다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Beverage</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">boilWater</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"물을 끓인다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">pourInCup</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"컵에 붓는다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>공통된 기능을 묶은 부모 클래스인 Beverage를 상속 받는 각각의 클래스를 만들어본다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Coffee</span> <span class="kd">extends</span> <span class="n">Beverage</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">prepareRecipe</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">boilWater</span><span class="o">();</span>
        <span class="n">brewCoffeeMachine</span><span class="o">();</span>
        <span class="n">pourInCup</span><span class="o">();</span>
        <span class="n">addSugarAndMilk</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">brewCoffeeMachine</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"필터를 활용해 커피를 내린다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addSugarAndMilk</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"설탕과 우유를 추가한다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tea</span> <span class="kd">extends</span> <span class="n">Beverage</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">prepareRecipe</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">boilWater</span><span class="o">();</span>
        <span class="n">steepTeaBag</span><span class="o">();</span>
        <span class="n">pourInCup</span><span class="o">();</span>
        <span class="n">addLemon</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">steepTeaBag</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"티백을 담근다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addLemon</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"레몬을 추가한다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h3 id="extends">extends</h3>
<p>이렇게 상속은 <code class="highlighter-rouge">extends</code> 키워드로 이루어 진다.<br />
상속을 할 경우 멤버 필드와 메소드를 하위 클래스에서 그대로 상속하게 되는데,<br />
키워드의 의미대로 자식 클래스가 조상 클래스를 확장하는 의미로 해석할 수 있다.<br />
<strong>여기서 주의점 !</strong></p>

<ul>
  <li>생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.</li>
  <li>자식 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.</li>
  <li>private, default는 상속되지 않는다기 보다는 상속은 받지만 자식 클래스로부터의 접근이 제한된다.</li>
  <li>자바에서는 다중 상속을 지원하지 않는다.</li>
</ul>

<h2 id="오버라이딩">오버라이딩</h2>
<p>조상 클래스로부터 상속 받은 메서드의 내용을 변결하는 것<br />
자식 클래스에서 부모 클래스 메서드를 맞게 변경하는 경우 오버라이딩을 한다.</p>

<h3 id="오버라이딩의-조건">오버라이딩의 조건</h3>
<p>자식 클래스의 메소드에서 부모 클래스의 메소드와 다음 조건들이 같아야 한다.</p>
<ul>
  <li>메소드 명</li>
  <li>매개변수</li>
  <li>반환타입
    <h3 id="오버라이딩-주의점">오버라이딩 주의점</h3>
  </li>
  <li>접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.</li>
  <li>예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.</li>
  <li>인스턴스메서드를 static 메서드, 또는 그 반대로 변경할 수 없다.</li>
</ul>

<p><strong>🤔 조상 클래스에 정의된 static 메서드를 자손 클래스에서 똑같은 이름의 static 메서드로 정의할 수 있나?</strong><br />
가능은 하지만 각 클래스에 별개의 static 메서드를 정의한 것일 뿐 오버라이딩이 아니다.</p>

<h3 id="상속의-장점">상속의 장점</h3>
<ul>
  <li>중복된 코드를 줄일 수 있다.</li>
  <li>공통적 필드를 추가하거나, 수정할 때 부모 클래스에만 작업해주면 된다.</li>
</ul>

<h3 id="클래스간의-관계">클래스간의 관계</h3>
<p>상속을 통해 클래스간에 관계를 맺어주는데, <br />
이때 생기는 관계를 몇 가지 유형으로 나눠볼 수 있다.</p>

<h4 id="is-a-관계-is-a-relationship">is-a 관계 (is a relationship)</h4>
<p>is-a 관계는 일반적인 개념과 구체적인 개념과의 관계를 말한다.<br />
여기서 일반적인 개념 클래스는 상위 클래스인 부모 클래스를 뜻하고,<br />
구체적인 개념 클래스는 하위 클래스인 자식 클래스를 뜻한다.</p>

<p>말 그대로 <strong>“~은 ~이다.”라는 문장이 성립되어야 한다.</strong></p>
<ul>
  <li>Example
```java
public class Person{
String name; 
int age; 
}</li>
</ul>

<p>public class Student extends Person{
int number; 
int major; 
}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>위 예제에서는 Student 클래스가 Person 클래스를 상속받고 있다.  
"학생은 사람이다."처럼 이러한 관계를 is-a 관계라고 한다.

#### has-a 관계 (composition)
has-a 관계는 한 클래스가 다른 클래스를 소유한 관계이다.

말 그대로 **"~은 ~을 가지고 있다."라는 문장이 성립되어야 한다.**
* Example
```java
class Circle {
    Point point;
    int r;
} 

class Point {
    int x;
    int y;
}
</code></pre></div></div>
<p>위 예제에서는 Point 클래스를 재사용해서 Circle 클래스를 작성했다.<br />
하나의 거대한 클래스를 작성하는 것보다 단위별로 여러 개의 클래스를 작성한 후,<br />
이 단위 클래스들을 포함관계로 재사용하면 보다 간결하고 손쉽게 클래스를 작성할 수 있다.<br />
또 작성된 단위 클래스들은 다른 클래스를 작성하는데 재사용될 수 있다.</p>

<p>“~은 ~이다.” 또는 “~은 ~을 가지고 있다.” 문장을 만들어보고<br />
더 적합한 관계를 구현하는 것이 좋다.</p>

<p>(이펙티브 자바에 “상속보단 조합”이라는 개념이 있던데 이 부분도 정리해보아야겠다.)</p>

<h2 id="캐스팅">캐스팅</h2>
<p><strong>🤔 캐스팅이란 ?</strong>
타입을 변환하는 것을 말하며, 형변환이라고도 한다.<br />
기본형 변수와 같이 참조변수도 형변환이 가능한데, 상속 관계에 있는 클래스 사이에서만 가능하다.</p>

<p>이때, 기본형 참조형 변수의 형변환에서 자손 타입의 참조변수를 조상타입으로 <br />
형변환하는 경우에는 형변환을 생략할 수 있다.</p>

<h3 id="업캐스팅">업캐스팅</h3>
<p>자식 클래스의 참조변수를 부모 클래스의 참조변수로 변환하며, 형변환 생략이 가능하다.<br />
부모 클래스의 참조 변수가 자식 클래스로 객체화된 인스턴스를 가리킬 수 있다.<br />
때문에 다형성을 위해 사용된다.<br />
ex) 학생은 사람이다.</p>

<p>위에서 다뤘던 Student 예제로 확인해보자.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 참조변수 student를 이용하면 number, major에 접근 가능</span>
<span class="n">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">();</span>

<span class="c1">// 레퍼런스 person을 이용하면 Student 객체의 멤버 중 </span>
<span class="c1">// 오직 Person 클래스의 멤버만 접근이 가능하다.</span>
<span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="n">student</span><span class="o">;</span>
<span class="n">person</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"amazzi"</span><span class="o">;</span>
<span class="n">person</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

<span class="c1">// 아래 문장은 컴파일 오류가 난다.</span>
<span class="n">person</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="s">"12345678"</span><span class="o">;</span>
</code></pre></div></div>

<p>이처럼 업캐스팅을 하게되면 부모 클래스의 필드, 메서드에만 접근이 가능하다.</p>

<h3 id="다운캐스팅">다운캐스팅</h3>
<p>자식 클래스의 참조변수를 자식 타입의 참조변수로 변환하며, 형변환 생략이 불가능하다.<br />
자신의 고유한 특성을 잃은 서브 클래스의 객체를 다시 복구 시켜주는 것을 말한다. (업캐스팅 복구?)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 업캐스팅 먼저</span>
<span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="o">();</span>

<span class="c1">// 다운캐스팅</span>
<span class="n">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="o">(</span><span class="n">Student</span><span class="o">)</span> <span class="n">person</span><span class="o">;</span>

<span class="c1">// Ok</span>
<span class="n">student</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"amazzi"</span><span class="o">;</span>
<span class="n">student</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="s">"12345678"</span><span class="o">;</span>
</code></pre></div></div>

<p>꼭 업캐스팅이 먼저 선행이 되어야 한다.<br />
만약 다음과 같은 경우는 컴파일 오류는 나지 않지만 <code class="highlighter-rouge">ClassCastException</code> 런타임 오류가 발생한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="o">(</span><span class="n">Student</span><span class="o">)</span> <span class="k">new</span> <span class="n">Person</span><span class="o">();</span>
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>📖 BigDecimal에 관한 고찰</title>
	  <link>//BigDecimal%E1%84%8B%E1%85%A6-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%80%E1%85%A9%E1%84%8E%E1%85%A1%E1%86%AF</link>
	  <author></author>
	  <pubDate>2021-03-01T19:18:00+09:00</pubDate>
	  <guid>//BigDecimal%E1%84%8B%E1%85%A6-%E1%84%80%E1%85%AA%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%80%E1%85%A9%E1%84%8E%E1%85%A1%E1%86%AF</guid>
	  <description><![CDATA[
	     <p>이번 미션에서 <code class="highlighter-rouge">BigDecimal</code>에 대한 언급이 많았는데,<br />
<strong>도대체 그게 뭐지 🤷‍♀️ 나만 몰라 ❓</strong><br />
에서부터 출발한 BigDecimal에 대한 고찰 ~</p>

<p><del>이번주 회고에서 앞으로 포스팅을 내가 이해한 글을 설명하듯이 ! 작성하기로 다짐한
내용을 최대한 반영하려고 노력중 ✍️
누군가 이 글을 읽고 있다면 아 얘가 이런짓을 하고 있구나 가볍게 봐주길 ㅎㅎ 🙈</del></p>

<h2 id="bigdecimal을-왜-쓰지-">BigDecimal을 왜 쓰지 ?</h2>
<h4 id="test">Test</h4>
<p><img src="https://images.velog.io/images/new_wisdom/post/005a8086-2456-4ebb-9162-45a415ddb471/image.png" style="zoom:50%;" /></p>

<p>과연 위 테스트 케이스는 통과를 할까? 정답은 👀</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/1a1ea170-2681-4f65-b8af-842b4316a1ae/image.png" style="zoom:50%;" /></p>

<p>허허 어이없게도 실패합니다.<br />
왜 실패하냐구요 ?<br />
자바는 IEEE 754 부동 소수점 방식을 사용해서, <br />
정확한 실수를 저장하지 않고 최대한 완벽에 가깝기를 바라는 근사치 값을 저장하기 때문이다 !</p>

<p>지금은 단순히 개발자 하나가 테스트를 위해 작성한 코드이지만,<br />
금융권에서 달러를 다루는 개발자가 double을 이용해서 이런 사소한 값 차이가 발생한다면 🙃</p>

<p>그렇다면 이 문제를 어떻게 해결하느냐 !<br />
우리에겐 부동 소숫점 방식이 아닌, 정수를 이용해 실수를 표현하는 <code class="highlighter-rouge">java.math.BigDecimal</code> 클래스가 있다.</p>

<p>Java 언어에서 돈과 소수점을 다룬다면 BigDecimal은 <strong>선택이 아니라 필수</strong>다.</p>

<p>그렇다면 본격적으로 BigDecimal을 해부해 봅시다.</p>
<h2 id="bigdecimal-클래스">BigDecimal 클래스</h2>
<p><img src="https://images.velog.io/images/new_wisdom/post/239a603a-92ad-42c8-8db1-b9666e30b392/image.png" style="zoom:50%;" /></p>

<p><code class="highlighter-rouge">BigDecimal</code> 클래스의 일부를 가져왔다.<br />
여기서 간단하게 몇 가지 변수들의 쓰임 짚고 넘어가겠다.<br />
<em>참고로 BigDecimal은 불변 클래스임</em></p>

<h4 id="변수">변수</h4>
<ul>
  <li>intValue : 정수. 정수를 저장하는데 <code class="highlighter-rouge">BigInteger</code>를 사용한다.</li>
  <li>scale : 지수. 정확히는 소수점 첫째 자리부터 0이 아닌 수로 끝나는 위치까지의 총 소수점 자리수이다.</li>
  <li>precision : 정밀도. 정확히는 0이 아닌 수가 시작하는 위치부터 오른쪽부터 0이 아닌 수로 끝나는 위치까지의 총 자리수이다.
아래 출력 결과로 각 변수의 의미를 파악하자.</li>
  <li><img src="https://images.velog.io/images/new_wisdom/post/852fce1a-773b-423e-8925-a677f8bb63da/image.png" style="zoom:50%;" /></li>
</ul>

<h2 id="bigdecimal의-생성">BigDecimal의 생성</h2>
<p>BigDecimal의 생성 방법은 여러가지가 있는데, <br />
문자열로 숫자를 표현하는 것이 일반적이다.<br />
기본형 리터럴로는 표현할 수 있는 값의 한계가 있는데, 예를 들어<br />
double 타입의 값을 그대로 전달할 경우<br />
앞서 사칙연산 결과에서 본 것과 같이 예상과 다른 값을 얻을 수도 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">;</span>
<span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BigDecimal</span><span class="o">(</span><span class="s">"12345.6789"</span><span class="o">);</span>
<span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BigDecimal</span><span class="o">(</span><span class="mf">12345.678</span><span class="o">);</span> <span class="c1">// 오차가 날 수 있음</span>
<span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BigDecimal</span><span class="o">(</span><span class="mi">12345</span><span class="o">);</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">BigDecimal</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mf">12345.67</span><span class="o">);</span> <span class="c1">// 오차가 날 수 있음</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">BigDecimal</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">123456</span><span class="o">);</span>
</code></pre></div></div>

<p><img src="https://images.velog.io/images/new_wisdom/post/b2c32896-9f79-4931-871e-b38f26c09480/image.png" style="zoom:50%;" /></p>

<p>실제로 인텔리제이도 String으로 바꾸라고 알려준다 👀 똑똑이</p>

<h2 id="bigdecimal의-비교">BigDecimal의 비교</h2>
<p>BigDecimal은 <code class="highlighter-rouge">Comparable&lt;BigDecimal&gt;</code>를 구현하고 있기 때문에,<br />
<code class="highlighter-rouge">equals()</code>를 통해 내용을 비교할 수 있다.<br />
여기서 주의할 점은 <code class="highlighter-rouge">12.01</code>과 <code class="highlighter-rouge">12.010</code>은 같지 않다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/0eec192e-2454-4905-be4b-48aa984f4f6e/image.png" style="zoom:50%;" /></p>

<h2 id="bigdecimal의-타입-변환">BigDecimal의 타입 변환</h2>
<h3 id="문자열로-변환">문자열로 변환</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">String</span> <span class="nf">toPlainString</span><span class="o">();</span> <span class="c1">// 무조건 다른 기호 없이 숫자로만 표현</span>
<span class="n">String</span> <span class="nf">toString</span><span class="o">();</span> <span class="c1">// 필요시 지수 형태로 표현할 수도 있음</span>
</code></pre></div></div>

<p><img src="https://images.velog.io/images/new_wisdom/post/2be425da-32bf-497a-9f2e-47d2a96106a6/image.png" style="zoom:50%;" /></p>

<p>또 <code class="highlighter-rouge">Number</code>를 상속받고 있기 때문에 <code class="highlighter-rouge">Number</code>의 기본형으로 변환하는 메서드를 가지고 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">intValue</span><span class="o">()</span>
<span class="kt">long</span> <span class="nf">longValue</span><span class="o">()</span>
<span class="kt">float</span> <span class="nf">floatValue</span><span class="o">()</span>
<span class="kt">double</span> <span class="nf">doubleValue</span><span class="o">()</span>
</code></pre></div></div>

<p>또 BigDecimal을 정수형으로 변환하는 메서드 중,<br />
이름 끝에 <code class="highlighter-rouge">Exact</code>가 붙은 것은 변환 결과가 변환 타입 범위에 속하지 않으면<br />
<code class="highlighter-rouge">ArithmeticException</code>을 발생시킨다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/6e38065d-30b2-4c9d-91b4-9d539b5130a3/image.png" style="zoom:50%;" /></p>

<p>테스트 성공 !</p>

<h2 id="bigdecimal의-연산">BigDecimal의 연산</h2>
<p>먼저 기본적인 연산을 수행하는 메서드들이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BigDecimal</span> <span class="nf">add</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">subtract</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">multiply</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">divide</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">remainder</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">val</span><span class="o">)</span>
</code></pre></div></div>

<p><img src="https://images.velog.io/images/new_wisdom/post/b028fbb0-5e1d-4802-9cb6-ad0de651b9a1/image.png" style="zoom:50%;" /></p>

<p>테스트 성공 !</p>

<p><strong>참고로 BigDecimal은 불변 객체이기 때문에 
연산 후 반환 타입이 BigDecimal인 경우 새로운 인스턴스가 반환된다.</strong></p>

<p>추가로 다른 연산과 달리 <code class="highlighter-rouge">divide()</code>은 메서드가 다양한 버전으로 오버로딩 되어있다.<br />
어떻게 반올림할지(roundingMode), 몇 번째 자리(scale)에서 반올림 할건지를 지정할 수 있다.</p>

<h4 id="roundingmode">roundingMode</h4>
<p>반올림 처리 방법에 대한 것으로 BigDecimal에 정의된 다음 상수들에서 하나를 선택해 사용하면 된다.</p>
<ul>
  <li>CEILING – 올림</li>
  <li>FLOOR – 내림</li>
  <li>UP – 양수일 경우 올림, 음수일 경우 내림</li>
  <li>DOWN – 양수일 경우 내림, 음수일 경우 올림</li>
  <li>HALF_UP – 반올림(5이상 올림, 5미만 버림)</li>
  <li>HALF_EVEN – 반올림(반올림 자리의 값이 짝수면 HALF_DOWN, 홀수면 HALF_UP)</li>
  <li>HALF_DOWN – 반올림(6이상 올림, 6미만 버림)</li>
  <li>UNNECESSARY – 나눗셈 결과가 딱 떨어지지 않으면,<code class="highlighter-rouge">ArithmeticException</code> 발생</li>
</ul>

<h4 id="scale-변경">scale 변경</h4>
<p>소수점 위치를 바꾸고 싶을 때는 BigDecimal을 10으로 곱하거나 나누는 것이 아니라,<br />
<code class="highlighter-rouge">setScale()</code>을 통해 scale 값을 변경한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BigDecimal</span> <span class="nf">setScale</span><span class="o">(</span><span class="kt">int</span> <span class="n">newScale</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">setScale</span><span class="o">(</span><span class="kt">int</span> <span class="n">newScale</span><span class="o">,</span> <span class="kt">int</span> <span class="n">roundingMode</span><span class="o">)</span>
<span class="n">BigDecimal</span> <span class="nf">setScale</span><span class="o">(</span><span class="kt">int</span> <span class="n">newScale</span><span class="o">,</span> <span class="n">RounfingMode</span> <span class="n">mode</span><span class="o">)</span>
</code></pre></div></div>

<p>주의할 점은 <code class="highlighter-rouge">setScale()</code>로 scale을 줄이는 것은 10의 n제곱으로 나누는 것과 같으므로<br />
오차가 발생할 수 있으니 roundingMode를 지정하는 것이 좋다.</p>

<h2 id="생성자-대신-valueof를-사용해라-">생성자 대신 valueOf()를 사용해라 !</h2>
<p>이 부분은 개인적인 고찰이니 혹시나 이 글을 누군가 읽고 잘못된 부분이 있다면 반박 부탁드림다 🙈<br />
BigDecimal은 생성자와 정적 팩터리 메서드인 <code class="highlighter-rouge">valueOf()</code>를 사용해서 객체를 생성할 수 있는데,<br />
<strong>과연 두 개는 어떤 것이 다를까 ❓</strong></p>

<p>고것이 궁금해졌다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/12cdd08d-4e5e-4353-b820-8ff52f4a185c/image.png" style="zoom:50%;" /></p>

<p>일단 BigDecimal은 Integer클래스처럼 일부 값을 캐싱해 놓고 있다.<br />
왜일까 스스로 답을 해보았는데,</p>

<p>BigDecimal의 주생성자를 가보면,</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/6db0f234-25ad-4a33-9677-c7c7ecb84cac/image.png" style="zoom:50%;" /></p>

<p>정말 장황한 생성자를 볼 수 있다.<br />
때문에 BigDecimal이 성능이 느리다고도 하는데,<br />
내 생각에는 이러한 이유 때문에도 캐싱을 해논게 아닌가 싶다.</p>

<p>이쯤에서 정적 팩터리 메서드인<code class="highlighter-rouge">valueOf()</code>로 가보면,</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/df153dae-d768-461d-956c-996b2d689bf8/image.png" style="zoom:50%;" /></p>

<p>정적 팩터리 메서드는 static 변수인 캐싱 값에 바로 접근할 수 있다.<br />
때문에 이미 캐싱되어 있는 값이 존재한다면 생성자를 통하지 않고 그 값을 바로 반환한다.</p>

<p>➕ 
또 추가로<br />
double실수값을 생성자로 생성해도 연산결과가 정확하지 않을 수 있으니, <br />
<code class="highlighter-rouge">valueOf()</code>를 사용해서 생성하는 것이 좋다고도 한다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/8ec4f2b7-16ac-40a1-bacd-c8e21bb76b82/image.png" style="zoom:50%;" /></p>

<p>오호라 👀<br />
요즘 정적 팩터리 메서드와 캐싱개념들에 대해 살펴봤는데,<br />
BigDecimal을 뜯어보니 굉장히 흥미롭다 👻</p>

	  ]]></description>
	</item>

	<item>
	  <title>📖 Stream 부수기</title>
	  <link>//Stream-%E1%84%87%E1%85%AE%E1%84%89%E1%85%AE%E1%84%80%E1%85%B5</link>
	  <author></author>
	  <pubDate>2021-02-25T19:18:00+09:00</pubDate>
	  <guid>//Stream-%E1%84%87%E1%85%AE%E1%84%89%E1%85%AE%E1%84%80%E1%85%B5</guid>
	  <description><![CDATA[
	     <p>코드를 짜다보면 가독성과 간결함을 위해 stream을 자주 쓰게 된다.<br />
프리코스 때 Stream에 대해 정리했었으나,<br />
내가 쓴 글을 리팩토링(ㅎ) 해보면서 다시 개념을 익혀야 겠다.</p>

<h2 id="스트림">스트림?</h2>
<p>배열 또는 컬렉션 인스턴스에 저장된 데이터를 꺼내서 파이프에 흘려보낸다.</p>
<ul>
  <li>중간 연산 : 마지막이 아닌 위치에서 진행이 되어야 하는 연산</li>
  <li>최종 연산 : 마지막에 진행이 되어야 하는 연산
스트림은 중간 연산과 최종 연산을 진행하기 좋은 구조로 배치된 복사본이라 할 수 있다.</li>
</ul>

<h3 id="스트림의-특성">스트림의 특성</h3>
<h4 id="가독성과-간결함">가독성과 간결함</h4>
<p>컬렉션이나 배열에 데이터를 담고 원하는 결과를 얻기 위해 
for문과 Iterator를 이용해 작성한 코드는 가독성이 떨어지고 재사용성도 떨어진다.</p>

<h4 id="데이터-소스-추상화">데이터 소스 추상화</h4>
<p>어떤 메소드로 처리하기 위해 데이터 소스마다 다른 방식으로 다뤄야 하는 문제를
스트림을 통해 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 되었다.<br />
이는 코드의 재사용성을 가져온다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">listStream</span> <span class="o">=</span> <span class="n">strList</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">arrayStream</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">strArr</span><span class="o">);</span>

<span class="n">listStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="n">arrayStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<p>두 스트림의 데이터 소스는 서로 다르지만, 정렬하고 출력하는 방법은 같다.</p>

<h4 id="데이터-소스를-변경하지-않는다">데이터 소스를 변경하지 않는다.</h4>
<p>스트림은 데이터 소스로 부터 데이터를 읽기만 할 뿐, 
데이터 소스를 변경하지 않는다.<br />
필요시에만 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sortedList</span> <span class="o">=</span> <span class="n">listStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">Collections</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<h4 id="스트림은-일회용이다">스트림은 일회용이다.</h4>
<p>Iterator처럼 일회용이다. 한번 사용하면 닫혀서 다시 사용할 수 없다.<br />
필요하다면 스트림을 다시 생성해야한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">listStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">print</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">numOfElement</span> <span class="o">=</span> <span class="n">listStream</span><span class="o">.</span><span class="na">count</span><span class="o">();</span> <span class="c1">//에러- 스트림이 이미 닫혔다.</span>
</code></pre></div></div>

<h4 id="내부-반복">내부 반복</h4>
<p>스트림이 간결한 이유중 하나가 반복문을 메서드 내부에 숨기는 ‘내부 반복’ 덕분이다.<br />
<code class="highlighter-rouge">forEach()</code>는 스트림에 정의된 메서드 중의 하나로 매개변수에 대입된 
람다식을 데이터 소스의 모든 요소에 적용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<h2 id="스트림-생성하기">스트림 생성하기</h2>
<h3 id="스트림의-생성">스트림의 생성</h3>
<h4 id="메소드">메소드</h4>
<p>스트림 생성과 관련해 <code class="highlighter-rouge">Stream&lt;T&gt;</code> 인터페이스에 정의되어 있는 static 메소드는 두 개가 있다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static &lt;T&gt; Stream&lt;T&gt;(T t)
static &lt;T&gt; Stream&lt;T&gt; of(T...values)
</code></pre></div></div>
<p>이 메소드에 스트림 생성에 필요한 데이터를 인자로 직접 전달할 수 있다.</p>

<h4 id="example">Example</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class StreamOfStream {
    public static void main(String[] args) {
        // ex 1
        Stream.of(11, 22, 33, 44)
            .forEach(n -&gt; System.out.print(n + "\t"));
        System.out.println();

        // ex 2
        Stream.of("So Simple")
            .forEach(s -&gt; System.out.print(s + "\t"));
        System.out.println();

        // ex 3 세 개의 문자열로 이뤄진 스트림이 생성되는 것이 아닌
        // sl이 참조하는 하나의 인스턴스만 존재한다.
        List&lt;String&gt; sl = Arrays.asList("Toy", "Robot", "Box");
        Stream.of(sl)
            .forEach(w -&gt; System.out.print(w + "\t"));
        System.out.println();       
    }
}
</code></pre></div></div>
<p>of 메소드에 컬렉션 인스턴스를 전달하면 해당 인스턴스 하나로 이뤄진 스트림이 생성된다. <br />
하지만 배열을 전달하면 하나의 배열로 이뤄진 스트림이 생성되지 않고,<br />
배열에 저장된 요소로 이뤄진 스트림이 생성된다.</p>

<h3 id="배열">배열</h3>
<p>배열에 저장된 데이터를 대상으로 스트림을 생성할 때 호출되는 대표 메소드는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">satic</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">stream</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span> <span class="c1">// Arrays 클래스에 정의되어 있다</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">StringStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">"YOON"</span><span class="o">,</span> <span class="s">"LEE"</span><span class="o">,</span> <span class="s">"PARK"</span><span class="o">};</span>
        
        <span class="c1">// 스트림 생성</span>
        <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stm</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
        
        <span class="c1">// 최종 연산 진행</span>
        <span class="n">stm</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>forEach는 최종 연산이며 메소드의 매개변수형은 <code class="highlighter-rouge">Consumer&lt;T&gt;</code> 이므로 람다식을 인자로 전달해야하며, <br />
내부적으로 스트림 데이터를 하나씩 인자로 전달하면서 accept 메소드를 호출한다.</p>

<h3 id="컬렉션-인스턴스">컬렉션 인스턴스</h3>
<p>컬렉션 인스턴스를 대상으로 스트림을 생성할 때 호출되는 메소드는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">default</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">stream</span><span class="o">()</span>
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ListStream {
    public static void main(String[] args) {
        
        List&lt;String&gt; list = Arrays.asList("Toy", "Robot", "Box");
        
        list.stream()
          .forEach(s -&gt; System.out.print(s + "\t"));

        System.out.println();
    }
}
</code></pre></div></div>

<h3 id="특정-범위의-정수">특정 범위의 정수</h3>
<p><code class="highlighter-rouge">IntStream</code>과 <code class="highlighter-rouge">LongStream</code>은 지정된 범위의 연속된 정수를 스트림으로 생성해서
반환하는 <code class="highlighter-rouge">range()</code>와 <code class="highlighter-rouge">rangeClosed()</code>를 가지고 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IntStream intStream = IntStream.range(1, 5); // 1,2,3,4,
IntStream intStream = IntStream = Intstream.rangeClosed(1, 5); // 1,2,3,4,5 
</code></pre></div></div>
<p><code class="highlighter-rouge">range</code>는 end가 범위에 포함되지 않고 <code class="highlighter-rouge">rangeClosed</code>는 포함된다.</p>

<h3 id="람다식---iterate-generate">람다식 - iterate(), generate()</h3>
<p>Stream 클래스의 <code class="highlighter-rouge">iterate()</code>와 <code class="highlighter-rouge">generate()</code>는 람다식을 매개변수로 받아서,<br />
이 람다식에 의해 계산되는 값들을 요소로 하는 무한 스트림을 생성한다.</p>

<p>이때 생성되는 스트림은 무한하기 때문에 <code class="highlighter-rouge">limit()</code>를 호출하여 특정 사이즈로 제한해주는 것이 좋다.</p>
<h4 id="iterate">iterate()</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">evenStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
<span class="c1">// 0, 2, 4 ...</span>
</code></pre></div></div>
<p>씨드로 지정된 값부터 시작해서,  람다식에 의해 계산된 결과를 다시 시드 값으로 해서 
계산을 반복한다.</p>

<h4 id="generate">generate()</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">randomStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="nl">Math:</span><span class="o">:</span><span class="n">random</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">iterate()</code>처럼 람다식에 의해 계산되는 값을 요소로 하는 무한 스트림을 생성해서
반환하지만, <code class="highlighter-rouge">iterate()</code>와 달리 이전 결과를 이용해서 다음 요소를 계산하지 않는다.</p>

<h3 id="빈-스트림">빈 스트림</h3>
<p>요소가 하나도 없는 비어있는 스트림을 생성할 수도 있다.<br />
스트림에 연산을 수핸한 결과가 하나도 없을 때, null보다 빈 스트림을 반환하는게 낫다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span> <span class="n">emptyStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span> <span class="c1">// empty() 는 빈 스트림을 생성해서 반환한다.</span>
<span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">emptyStream</span><span class="o">.</span><span class="na">count</span><span class="o">();</span> <span class="c1">// count값은 0</span>
</code></pre></div></div>
<p>여기서 <code class="highlighter-rouge">count()</code>는 요소의 갯수를 반환한다.</p>

<h2 id="스트림의-연산">스트림의 연산</h2>
<h4 id="지연-처리">지연 처리</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyFirstStream2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ar</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>

        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">ar</span><span class="o">)</span> <span class="c1">// 스트림을 생성</span>
                        <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// filter 통과</span>
                        <span class="o">.</span><span class="na">sum</span><span class="o">();</span> <span class="c1">// sum을 통과시켜 그 결과를 반환</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위 예제에서 쓰인 두 메소드는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">IntStream</span> <span class="nf">stream</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span>
<span class="n">IntStream</span> <span class="nf">filter</span><span class="o">(</span><span class="n">IntPredicate</span> <span class="n">predicate</span><span class="o">)</span>
</code></pre></div></div>
<p>filter와 sum 메소드는 IntStream의 인스턴스 메소드이다.</p>

<p>스트림의 연산은 “지연 처리” 방식으로 동작한다.<br />
최종 연산이 수행 되기 전까지는 중간 연산이 수행되지 않는다.</p>

<p>위 예제에서는 sum이 호출될 때까지 filter의 호출 결과는 스트림에 반영되지 않는다.<br />
최종 연산인 sum이 호출되어야만 filter의 호출 결과가 스트림에 반영된다.<br />
이처럼 최종 연산이 생략되면 중간 연산이 의미가 없다.</p>

<h3 id="스트림의-중간-연산">스트림의 중간 연산</h3>
<p>연산 결과가 스트림인 연산으로, 스트림에 연속해서 중간 연산할 수 있다.</p>
<h3 id="filter-필터링">filter (필터링)</h3>
<p>스트림을 구성하는 데이터 중 일부를 조건에 따라 걸러내는 행위를 의미한다.</p>
<h4 id="메소드-1">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span> <span class="c1">// Stream&lt;T&gt;에 존재</span>
</code></pre></div></div>
<p>매개변수 형이 Predicate이므로 test 메소드의 구현에 해당하는 람다식을 
인자로 전달해야 한다.<br />
내부적으로 스트림 데이터를 하나씩 인자로 전달하면서 test를 호출하고,<br />
그 결과가 true이면 해당 데이터를 스트림에 남긴다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FilterStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ar</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">ar</span><span class="o">)</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// 홀수만 통과</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"Toy"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">,</span> <span class="s">"Box"</span><span class="o">);</span>
        <span class="n">sl</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">// 길이가 3이면 통과</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>       
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h3 id="map-맵핑">map (맵핑)</h3>
<p>스트림 요소에서 저장된 값 중에서 원하는 필드만 뽑아내거나 특정 형태로 변환해야 할 떄가 있다.<br />
맵핑을 진행하면 스트림의 데이터 형이 달라지는 특징이 있다.</p>

<h4 id="메소드-2">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span>
</code></pre></div></div>
<p>매개변수 형이 Function이므로 apply 메소드의 구현에 해당하는 람다식을 
인자로 전달해야 한다.<br />
내부적으로 스트림 데이터를 하나씩 인자로 전달하면서 apply를 호출하고,<br />
그 결과로 반환되는 값을 모아 새 스트림을 생성한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MapToInt</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"Box"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">,</span> <span class="s">"Simple"</span><span class="o">);</span>
        
        <span class="n">ls</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
          <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
          <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h4 id="map-vs-flatmap">map vs flatMap</h4>
<h5 id="map의-메소드">map의 메소드</h5>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span>
</code></pre></div></div>
<p>map에 전달할 람다식에서는 스트림을 구성할 데이터만 반환하면 된다.</p>
<h5 id="flatmap의-메소드">flatMap의 메소드</h5>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;&gt;</span> <span class="n">mapper</span><span class="o">)</span>
</code></pre></div></div>
<p>flatMap에 전달할 람다식에서는 스트림을 생성하고 이를 반환해야 한다.</p>

<h3 id="filter--map">filter &amp; map</h3>
<h4 id="example-1">example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
	<span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="o">)</span>
	<span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">getPrice</span><span class="o">())</span>
	<span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="sorted">sorted</h3>
<h4 id="메소드-3">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">sorted</span><span class="o">()</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">compatator</span><span class="o">)</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">sorted()</code>는 지정된 Comparator로 스트림을 정렬하는데, Comparator대신 
int 값을 반환하는 람다식을 사용할 수도 있다.<br />
Comparator를 지정하지 않으면 스트림 요소의 기본 정렬 기준으로 정렬한다.<br />
하지만 스트림 요소가 Comparable을 구현한 클래스가 아니면 예외가 발생한다.<br />
정렬에 사용되는 메서드의 개수가 많지만 기본적인 메서드는 <code class="highlighter-rouge">comparing()</code>이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">comparing</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">keyExtractor</span><span class="o">)</span>
<span class="n">comparing</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">keyExtractor</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">keyComparator</span><span class="o">)</span>
</code></pre></div></div>
<p>스트림 요소가 Comparable을 구현한 경우, 매개변수 하나짜리를 사용하면 되고,<br />
그렇지 않으면 추가적인 매개변수로 정렬기준(Comparator)을 따로 지정해줘야 한다.</p>

<p>정렬 조건을 추가할 때는 <code class="highlighter-rouge">thenComparing()</code>을 사용한다.</p>

<h4 id="example-2">Example</h4>
<p>학생 스트림을 반별, 성적순, 이름 순으로 정렬하는 예시이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">student</span><span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="nl">Student:</span><span class="o">:</span><span class="n">getBan</span><span class="o">)</span>
	<span class="o">.</span><span class="na">thenComparing</span><span class="o">(</span><span class="nl">Student:</span><span class="o">:</span><span class="n">getTOtalScore</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenComparing</span><span class="o">(</span><span class="nl">Student:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span>
        <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="peek">peek</h3>
<p>스트림을 이루는 모든 데이터 각각을 대상으로 특정 연산을 진행하는 행위를 “루핑”이라 한다.<br />
forEach는 루핑으로 최종연산이지만, 중간연산에도 루핑 메소드가 있다.</p>

<h4 id="메소드-4">메소드</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Stream&lt;T&gt;의 메소드
Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)
</code></pre></div></div>
<h4 id="example-3">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LazyOpStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 최종 연산이 생략된 스트림의 파이프 라인</span>
        <span class="c1">// 아무 것도 출력되지 않는다.</span>
        <span class="n">IntStream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
            <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">d</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

  
        <span class="c1">// 최종 연산이 존재하는 파이프 라인</span>
        <span class="n">IntStream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
            <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">d</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">sum</span><span class="o">();</span>            
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="스트림의-최종-연산">스트림의 최종 연산</h2>
<p>최종 연산은 스트림의 요소를 소모해서 결과를 만들어낸다.<br />
그래서 최종 연산 후에는 스트임니 닫혀 더 이상 사용할 수 없다.<br />
최종 연산의 결과는 스트림의 요소의 합과 같은 단일 값이거나, <br />
스트림의 요소가 담긴 배열 또는 컬렉션일 수 있다.</p>

<h3 id="foreach">forEach</h3>
<p>지정된 작업을 스트림의 모든 요소에 대해 수행한다.
주의할 점은 <code class="highlighter-rouge">forEach()</code>는 스트림의 요소를 소모하면서 작업을 수행하므로 같은 스트림에 <code class="highlighter-rouge">forEach()</code>를 두 번 호출할 수 없다.</p>

<h4 id="메소드-5">메소드</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Stream&lt;T&gt;의 메소드
void forEach(Consumer&lt;? super T&gt; action)
</code></pre></div></div>
<p><code class="highlighter-rouge">peek()</code>과 달리 스트림의 요소를 소모하는 최종 연산이기 때문에 반환형이 void이다.</p>

<h3 id="reduce">reduce</h3>
<p>스트림 요소를 줄여나가면서 연산을 수행하고 최종 결과를 반환한다.<br />
처음 두 요소를 가지고 연산한 결과를 가지고 그 다음 요소와 연산한다.<br />
이 과정에서 스트림의 요소를 하나씩 소모하게 되며, 스트림의 모든 요소를 소모하면 그 결과를 반환한다.</p>

<p>스트림의 요소가 하나도 없는 경우, 초기값이 반환되므로 반환타입이 <code class="highlighter-rouge">Optional&lt;T&gt;</code>가 아니라 <code class="highlighter-rouge">T</code>이다.</p>
<h4 id="메소드-6">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">T</span> <span class="n">identity</span><span class="o">,</span> <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">)</span> <span class="c1">// Stream&lt;T&gt;에 존재</span>
</code></pre></div></div>
<p>reduce는 전달하는 람다식에 의해 연산의 내용이 결정된다.</p>

<p><strong><code class="highlighter-rouge">BinaryOperator&lt;T&gt;</code>의 추상 메소드</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T apply(T t1, T t2)
</code></pre></div></div>
<p>reduce 호출 시 메소드 apply에 대한 람다식을 인자로 전달해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ReduceStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"Box"</span><span class="o">,</span> <span class="s">"Simple"</span><span class="o">,</span> <span class="s">"Complex"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">);</span>
        
        <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">lc</span> <span class="o">=</span> 
            <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> 
               <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
                   <span class="k">return</span> <span class="n">s1</span><span class="o">;</span>
               <span class="k">else</span> 
                   <span class="k">return</span> <span class="n">s2</span><span class="o">;</span>                   
            <span class="o">};</span>
        
        <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                      <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">lc</span><span class="o">);</span> <span class="c1">// 스트림이 빈 경우 빈 문자열 반환</span>
      
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span> <span class="c1">// Complex</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>reduce 메소드는 스트림이 빈 경우에 첫 번째 인자로 전달된 값을 반환한다.</p>
<h3 id="allmatch-anymatch-nonematch">allMatch, anyMatch, noneMatch</h3>
<p>스트림의 요소에 대해 지정된 조건에 모든 요소가 일치하는 지, 일부가 일치하는지,<br />
아니면 어떤 요소도 일치하지 않는지 확인하는데 사용할 수 있다.</p>

<h4 id="메소드-7">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">allMatch</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span>

<span class="kt">boolean</span> <span class="nf">anyMatch</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span>

<span class="kt">boolean</span> <span class="nf">noneMatch</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span>
</code></pre></div></div>
<ul>
  <li>allMatch : 스트림의 데이터가 조건을 모두 만족하는가?</li>
  <li>anyMatch : 스트림의 데이터가 조건을 하나라도 만족하는가?</li>
  <li>noneMatch : 스트림의 데이터가 조건을 하나도 만족하지 않는가?
    <h3 id="findany-findfirst">findAny, findFirst</h3>
    <p><code class="highlighter-rouge">filter()</code>와 함께 쓰여서 조건에 맞는 스트림의 요소가 있는지 확인하는데 사용된다.<br />
둘의 반환 타입은 <code class="highlighter-rouge">Optionsnal&lt;T&gt;</code>이며, 스트림의 요소가 없을 때 빈 Optional 객체를 반환한다.</p>
  </li>
</ul>

<h4 id="example-4">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">student</span><span class="o">.</span><span class="na">filer</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getTotalScore</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">).</span><span class="na">findFirst</span><span class="o">();</span>
</code></pre></div></div>
<h3 id="collect">collect</h3>
<p>파이프라인을 통해서 가공되고 걸러진 데이터를 최종 연산 과정에서 별도로 저장이 필요할 때 사용한다.</p>
<h4 id="메소드-8">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Stream&lt;T&gt;의 메소드</span>
<span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span> 
				<span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">,</span>
                <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">combiner</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="example-5">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CollectStringStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"Box"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">,</span> <span class="s">"Toy"</span><span class="o">};</span>
        <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">words</span><span class="o">);</span>
        
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">)</span>
                          <span class="o">.</span><span class="na">collect</span><span class="o">(</span>
                              <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(),</span>
                              <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">),</span>
                              <span class="o">(</span><span class="n">lst1</span><span class="o">,</span> <span class="n">lst2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">lst1</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">lst2</span><span class="o">));</span>
    
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ls</span><span class="o">);</span> <span class="c1">// [Box, Toy]</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>첫 번째 매개변수인 람다식을 기반으로 데이터를 저장할 저장소를 생성한다.<br />
두 번째 매개변수인 람다식에서의 첫 번째 매개변수(c)는 
collect의 첫번째 인자를 통해서 생성된 컬렉션 인스턴스이며,<br />
두 번째 매개변수(s)는 스트림을 이루는 데이터 이다.<br />
세 번째 매개변수인 람다식은 병렬 스트림이 아닌 순차 스트림일 경우 사용되지 않는다.</p>

<h2 id="collect-1">collect()</h2>
<p>스트림의 요소를 수집하는 최종 연산으로 <code class="highlighter-rouge">reduce()</code>와 유사하다.<br />
collect()가 스트림의 요소를 수집하려면, 어떻게 수집할 것인가에 대한 방법이 정의되어<br />
있어야 하는데, 이 방법을 정의한 것이 컬렉터이다.</p>

<h3 id="컬렉터">컬렉터</h3>
<p>컬렉터는 <code class="highlighter-rouge">Collector</code> 인터페이스를 구현한 것으로, 직접 구현할 수도 있고 미리 작성된 것을 사용할 수도 있다.<br />
다양한 static 메서드를 가지고 있다.</p>

<ul>
  <li>collect() : 스트림의 최종연산, 매개변수로 컬렉터를 필요로 한다.</li>
  <li>Collector : 인터페이스. 컬렉터는 이 인터페이스를 구현해야한다.</li>
  <li>Collectors : 클래스. static 메서드로 미리 작성된 컬렉터를 제공한다.</li>
</ul>

<p>Collector는 인터페이스이기 때문에 직접 구현해서 컬렉터를 만들어야 한다.</p>

<h3 id="collect-2">collect()</h3>
<p><code class="highlighter-rouge">collect()</code>는 매개변수 타입이 Collector인데, 매개변수가 Collector를 구현한 클래스의 객체여야 한다.<br />
<code class="highlighter-rouge">collect()</code>는 이 객체에 구현된 방법대로 스트림의 요소를 수집한다.<br />
<em>sort()할 때 Comparator가 필요한 것처럼 colllect()할 때는 Collector가 필요하다.</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Object</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Collector</span> <span class="n">collector</span><span class="o">)</span> 
</code></pre></div></div>

<h3 id="스트림을-컬렉션과-배열로-반환">스트림을 컬렉션과 배열로 반환</h3>
<ul>
  <li><code class="highlighter-rouge">toList()</code>, <code class="highlighter-rouge">toSet()</code>, <code class="highlighter-rouge">toMap()</code>, <code class="highlighter-rouge">toCollection()</code>, <code class="highlighter-rouge">toArray()</code></li>
</ul>

<p>스트림의 모든 요소를 컬렉션에 수집하려면, Collectors 클래스의 <code class="highlighter-rouge">toList()</code>와 같은 메서드를 사용하면 된다.<br />
특정 컬렉션을 지정하려면 <code class="highlighter-rouge">toCollection()</code>에 해당하는 컬렉션의 
생성자 참조를 매개변수로 넣어주면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toCollection</span><span class="o">(</span><span class="n">toCollection</span><span class="o">(</span><span class="nl">ArrayList:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
</code></pre></div></div>

<p>Map은 키와 값의 쌍으로 저장해야하니 객체의 어떤 필드를 키로 사용할지와 값으로 사용할지를 지정해줘야 한다.<br />
아래 예제는 스트림에서 사람의 주민번호를 키로 하고, 값으로 Person 객체를 그대로 저장한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Person</span><span class="o">&gt;</span> <span class="n">map</span>  <span class="o">=</span> <span class="n">personStream</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toMap</span><span class="o">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">.</span><span class="na">getRegId</span><span class="o">(),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">));</span>
</code></pre></div></div>

<h2 id="참고-자료">참고 자료</h2>
<ul>
  <li>자바의 정석</li>
  <li>윤성우의 열혈 자바 프로그래밍</li>
</ul>

<hr />
<p>자주 사용하던 스트림을 정리하니까 각 메소드의 사용 목적이 명확해졌다 🙃<br />
또 Collector와 Collectors는 뭐가 다른지 궁금했는데 정리되었다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📖 Exception에 대하여</title>
	  <link>//Exception%E1%84%8B%E1%85%A6-%E1%84%83%E1%85%A2%E1%84%92%E1%85%A1%E1%84%8B%E1%85%A7</link>
	  <author></author>
	  <pubDate>2021-02-24T19:18:00+09:00</pubDate>
	  <guid>//Exception%E1%84%8B%E1%85%A6-%E1%84%83%E1%85%A2%E1%84%92%E1%85%A1%E1%84%8B%E1%85%A7</guid>
	  <description><![CDATA[
	     <p>오늘 수업 시간에 자바의 Exception에 대해 배웠다.<br />
수업을 듣고 들은 내용을 자바의 정석의 예외 처리를 함께 보면서 정리 ✍️</p>

<h2 id="프로그램-오류-종류">프로그램 오류 종류</h2>
<ul>
  <li>컴파일 에러 - 컴파일 시에 발생하는 에러</li>
  <li>런타임 에러 - 실행 시에 발생하는 에러</li>
  <li>논리적 에러 - 실행은 되지만, 의도와 다르게 동작하는 것</li>
</ul>

<p>프로그램에서 실행 도중 발생할 수 있는 모든 경우의 수를 고려해 이에 대한 적절한 대비가 필요하다!</p>

<h3 id="error와-exception의-차이">Error와 Exception의 차이?</h3>
<h4 id="error">Error</h4>
<p>애플리케이션이 정상적으로 동작하는데 심각한 문제가 있는 경우 사용한다.<br />
ex) 메모리 부족이나 스택오버플로우 등</p>

<p>개발자가 Error를 사용하는 일은 거의 없다고 한다.</p>

<h4 id="exception">Exception</h4>
<p>비즈니스 로직 상에서 에러가 발생하는 경우 사용한다. <br />
발생하더라도 수습이 가능하여 프로그래머가 이에 대한 적절한 처리를 할 수 있다.</p>

<h2 id="예외-클래스-계층-구조">예외 클래스 계층 구조</h2>
<p><img src="https://images.velog.io/images/new_wisdom/post/b3233d4f-d9e9-4c54-991b-5a0d24430cfb/pngwing.com.png" style="zoom:67%;" /></p>

<p>모두 Throwable을 상속하고 있으며, 여기서부터 Error와 Exception이 발생한다.<br />
여기서 모든 예외의 조상은 Exception 클래스이다.</p>

<p>또 예외 클래스들은 두 개의 그룹으로 나뉘어 질 수 있다.</p>
<ul>
  <li>RuntimeException 클래스와 그 자손 클래스들</li>
  <li>Exception 클래스와 그 자손 클래스들</li>
</ul>

<p>이 글에서는 RuntimeException 클래스와 그 자손 클래스들을 <strong>Checked Exception</strong>이라 하고,<br />
Exception 클래스와 그 자손 클래스들을 <strong>Unchecked Exception</strong>이라고 하겠다.</p>

<h3 id="checked-exception">Checked Exception</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">lotto.view.ErrorView</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomException</span> <span class="kd">extends</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">CustomException</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ErrorView</span><span class="o">.</span><span class="na">printErrorMessage</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<p>…</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">CustomException</span> <span class="o">{</span>
        <span class="n">LottoNumber</span> <span class="n">lottoNumber</span> <span class="o">=</span> <span class="n">LottoNumber</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Exception을 상속받아 사용하는 경우 컴파일 시점에 Exception을 확인할 수 있다. <br />
만약 컴파일 시점에 Exception에 대한 처리(try/catch)를 하지 않을 경우 컴파일 에러가 발생한다.<br />
Exception이 발생하는 메소드에서 throws 예약어를 활용해<br />
Exception을 호출 메소드에 전달해야 한다.</p>

<p>상위 메서드로 throw를 던지는 행위는 상위 메서드들의 책임이 그만큼 증가하기 때문에,<br />
그리 좋은 방법 같지는 않다.</p>

<h3 id="unchecked-exception">Unchecked Exception</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IllegalLottoNumberException</span> <span class="kd">extends</span> <span class="n">IllegalArgumentException</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IllegalLottoNumberException</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ErrorView</span><span class="o">.</span><span class="na">printIllegalLottoNumberMessage</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>…</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">LottoNumber</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MIN_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">45</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Pattern</span> <span class="n">NUMBER_PATTERN</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"^[0-9]*$"</span><span class="o">);</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LottoNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">validateLottoNumber</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateLottoNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isBlank</span><span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">||</span> <span class="n">isInvalidNumberFormat</span><span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">||</span> <span class="n">isInvalidLottoNumberRange</span><span class="o">(</span><span class="n">number</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalLottoNumberException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>Runtime Time Exception 이라고 한다.<br />
컴파일 시점에 Exception이 발생할 것인지의 여부를 판단할 수 없다.<br />
Exception이 발생하는 메소드에서 throws 예약어를 활용해 Exception을 처리할 필요가 없지만, 처리해도 무방하다.</p>

<h3 id="checked-exception-vs-unchecked-exception">Checked Exception VS Unchecked Exception</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>Checked Exception</th>
      <th>Unchecked Exception</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>확인 시점</td>
      <td>컴파일타임</td>
      <td>런타임</td>
    </tr>
    <tr>
      <td>처리</td>
      <td>반드시 예외 처리해야 한다.</td>
      <td>throws를 통해 그냥 던져도, 처리해도 상관 없다.</td>
    </tr>
    <tr>
      <td>대표 예외</td>
      <td>IOException, SQLException</td>
      <td>IllegalArgumentException, NullPointEception</td>
    </tr>
  </tbody>
</table>

<p>너무 치명적이면 Checked 쓰고,<br />
굳이 경고가 필요없고, 서비스 코드를 만드는 입장이라면 최상단에서 <br />
에러를 핸들링 할 수 있으니 Unchecked를 쓰는게 좋다.</p>

<p>참고로 코틀린에서는 Checked Exception은 코드만 늘어날 뿐이라 생각(?)해서 <br />
여러가지 이유로… Checked Exception이 없다고 한다.<br />
또 프로그래머 입장에서 메인과 같은 중앙에서 핸들링하는 녀석을 만들어 관리하는데,<br />
굳이 우리가 Checked Exception을 제공할 필요가 있냐는 말이다.</p>

<p>수업시간에 다양한 말들로 둘을 구분지어 보았는데,<br />
**Checked Exception는 **</p>

<ul>
  <li>내부 구현이 어떻게 되는지 알려주고 싶어!</li>
  <li>내가 집 수리할건데 손 다칠수도 있으니까 구급차 미리 불러!</li>
  <li>너 진짜 조심해야해!</li>
</ul>

<p>**Unchecked Exception는 **</p>
<ul>
  <li>내부에서 예외에 대한 방어가 있는데 클라이언트한테 공개는 안할거야, 대신 값을 잘 넣어주면 좋겠어.</li>
  <li>내가 집 수리할건데 아냐 다치지 않고 잘 할 수 있어!</li>
  <li>클라이언트가 입력할 값을 잘 알고 있겠지 ~</li>
</ul>

<p>이런 느낌으로 이야기가 나왔다.<br />
Checked인지 Unchecked인지는 <strong>클라이언트에게 얼마나 책임을 떠넘기느냐</strong>에 대한 관점으로 봐도 좋을 것 같다.</p>

<h2 id="예외-처리---try-catch문">예외 처리 - try-catch문</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="c1">// 예외 발생 가능성 있는 문장들</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception1</span> <span class="n">e1</span><span class="o">){</span>
    <span class="c1">// Exception1이 발생했을 경우, 처리하는 문장</span>
<span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception2</span> <span class="n">e2</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Exception2가 발생했을 경우, 처리하는 문장</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이렇게 하나의 try 블럭 다음에는 여러 종류의 예외를 처리할 수 있도록<br />
하나 이상의 catch 블럭이 올 수 있다.</p>

<h4 id="흐름">흐름</h4>
<p>try 블럭에서 예외가 발생하면, 예외가 발생한 위치 이후에 있는 <br />
try 블럭의 문장들은 수행되지 않는다.<br />
때문에 try 블럭에 포함시킬 코드의 범위를 잘 선택해야 한다.</p>

<p>예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 만들어진다.<br />
try블럭에서 예외가 발생되고, 첫 catch 문부터 차례대로 catch 블럭의<br />
괄호 내 선언된 참조변수의 종류와 생성된 예외 클래스의 인스턴스에 <code class="highlighter-rouge">instanceof</code>연산자를 이용해 검사한다.<br />
검사한 결과가 true인 블럭을 만날 때 까지 계속 검사한다.</p>

<h4 id="try에서-발생한-예외의-종류와-일치하는-단-하나의-catch-블럭만-수행된다">try에서 발생한 예외의 종류와 일치하는 단 하나의 catch 블럭만 수행된다.</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">number</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">LottoNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">LottoNumber</span> <span class="nf">from</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">CustomException</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">CustomException</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>다음과 같이 LottoNumber 객체를 <code class="highlighter-rouge">from()</code>으로 생성했을 때 <br />
<code class="highlighter-rouge">Exception</code>을 상속받고 있는 <code class="highlighter-rouge">CustomException</code>을 발생시킨다고 해보자.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/daa06d54-027d-44b4-aa16-4c4d985f3e72/image.png" style="zoom:50%;" /></p>

<p>인텔리제이에서도 알 수 있듯이 <code class="highlighter-rouge">CustomException</code>의 상위 클래스인 <br />
<code class="highlighter-rouge">Exception</code>을 미리 catch해주었기 때문에 하위 catch에서 <br />
<code class="highlighter-rouge">CustomException</code>를 잡는 것은 소용이 없다.</p>

<p>모든 예외 클래스는 Exception 클래스의 자손이므로, <br />
Exception 클래스 타입의 참조변수를 선언하면 해당 블럭에서 어떤 예외던지 처리된다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/aae681e5-9d55-4e86-99fe-da67d1cf9492/image.png" style="zoom:50%;" /></p>

<p>또 위와 같은 코드를 실행시켜보면 아래와 같은 출력 결과가 나온다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/20c67935-d673-4440-beb6-a943faf7d55d/image.png" style="zoom:50%;" /></p>

<p><strong>멀티 catch 블럭</strong><br />
JDK1.7부터 catch 블럭을 <code class="highlighter-rouge">|</code>을 이용해 하나의 catch 쁠럭으로 합칠 수 있게 되었다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/0ae3a6dd-c32e-47ff-8d0c-9788613a410e/image.png" style="zoom:50%;" /></p>

<p>하지만 이렇게 부모 자식 관계가 있다면 컴파일 에러가 발생한다.</p>

<h4 id="중첩된-try-catch">중첩된 try-catch</h4>
<p><img src="https://images.velog.io/images/new_wisdom/post/720fe0b3-6297-4a8e-85cb-4ad644451cd7/image.png" style="zoom:50%;" /></p>

<p>하나의 메서드 안에 여러개의 try-catch를 사용할 수 있으며,<br />
중첩으로도 사용이 가능하다.<br />
하지만 catch블럭 괄호 내 참조 변수는 catch 블럭 내에서 유효한데,<br />
위의 예제에서는 <code class="highlighter-rouge">e</code>의 참조변수의 영역이 서로 겹치기 때문에 컴파일 에러가 난다.</p>

<h2 id="custom-exception">Custom Exception</h2>
<p>기존에 정의된 예외 클래스 외에 필요에 따라 사용자 정의 클래스를 정의하여 사용할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyException</span> <span class="kd">extends</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">MyException</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span> 
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>생성시 string을 인자로 받아서 메시지로 저장할 수 있다.</p>

	  ]]></description>
	</item>


</channel>
</rss>
