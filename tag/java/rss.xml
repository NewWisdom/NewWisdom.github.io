<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>NewWisdom.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>I want to be a person who gives you new wisdom.</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>📝 객체지향 설계 강의 노트</title>
	  <link>//%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-%EA%B0%95%EC%9D%98-%EB%85%B8%ED%8A%B8</link>
	  <author></author>
	  <pubDate>2021-03-23T19:18:00+09:00</pubDate>
	  <guid>//%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-%EA%B0%95%EC%9D%98-%EB%85%B8%ED%8A%B8</guid>
	  <description><![CDATA[
	     <p><img src="https://user-images.githubusercontent.com/43840561/114287351-1fde3300-9aa1-11eb-851c-61060904867d.png" alt="image" style="zoom: 67%;" /></p>

<p>랜덤넘버는 구현체이니까  Number로 받자</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287370-38e6e400-9aa1-11eb-94d8-e5f4a08b1f16.png" alt="image" style="zoom:67%;" /></p>

<p>이러면 모두가 움직이는데 ?</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287377-4bf9b400-9aa1-11eb-9bec-94738f02d078.png" alt="image" style="zoom:67%;" /></p>

<h3 id="의존성-주입-di">의존성 주입 DI</h3>

<p>스프링 프레임 워크는 DI를 구현하도록 강제되어 있다.<br />
의존성 주입을 위해서는 스프링을 써야한다는 말이 있는데 그렇지 않다.</p>

<p>스프링 프레임 워크를 쓰지 않은 채로 DI를 해본 적이 있습니까 ?</p>

<h4 id="생성자-의존성-주입">생성자 의존성 주입</h4>

<p>❓ randomNumbers를 객체의 변수로 두고있는데, move()의 인수로 넘겨받는 것은 어떨까요?<br />
-&gt; 상관 없음</p>

<p>move 메서드를 사용할 때마다 객체를 생성해야하니</p>

<p>인자가 많아졌을 떄는 생성자를 전달하는 것이 좋을 수도..</p>

<p>❓ 의존성 주입을 위한 setter는 괜찮나요 ?<br />
-&gt; 어떤 객체냐에 따라 다른데, 지금은 Cars의 상태 데이터를 가지고 있는 현제 예시에서는 
final로 선언해주는 것이 좋다.  setter 써도 상관은 없다.</p>

<p>Dependency Injection인데 객체가 다른 객체에 의존하는 것을 외부에서 주입하는 경우를 DI라고 하지 않을까여..?</p>

<p>setter를 사용하는 부분은 전략패턴이 좋은 예시가 되지않을까요?</p>

<p>저는 내부 로직을 객체로 추출할 수 있을때 추출한 후 주입받아 사용하는 식으로 변경할 때  ‘DI한다’ 하는거 같아요</p>

<p>객체지향적 설계는 기본적으로 객체간의 협력을 만들어내는 일이고, 이를 가능하게 하기 위해서는 객체간의 의존성이 필요해요.<br />
-&gt; 그럼 setter를 활용할 수 있지않을까용</p>

<p>의존성을 DI가 아닌 내부에서 만들어 줄 수도 있지만, 이렬 결우 강한 결합성을 가지기 때문에 변경에 자유롭지 않아 DI가 필요하다고 생각해요</p>

<h3 id="유지보수하기-좋은-코드">유지보수하기 좋은 코드</h3>

<p>작은 코드가 유지보수하기 쉽다.<br />
클래스가 작으면 메서드와 프러퍼티가 더 가까이 있을 수 있기 때문에 응집도가 높아진다.<br />
간단히 말해 각각 메서드가 모든 필드를 사용한다.</p>

<h3 id="불변-객체로-만드세요">불변 객체로 만드세요</h3>

<p>함수형 프로그래밍은 side eggect를 만들지 않는다.<br />
가변 객체는 말고 불변 객체를 만들어야 side effect가 생기지 않는다.<br />
불변 객체로 만들다보면 인스턴스가 많아져서 성능이 떨어진다 .</p>

<p>-&gt; 이는 캐싱 전략을 통해 해소하자</p>

<p>불변 객체로 만들다 성능 이슈가 생기면 가변 객체나 캐싱을 사용해라</p>

<p>모든 클래스를 불변으로 만들면 유지보수가 쉽다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287403-7fd4d980-9aa1-11eb-9ad9-fb92c32a2374.png" alt="image" style="zoom:67%;" /></p>

<p>현재 불변 객체가 아니다. <br />
Position이 final이 아니다. <br />
c메소드들이 car를 리턴하도록 변경한다  ?</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287412-8f542280-9aa1-11eb-9727-f9e93b5a60a3.png" alt="image" style="zoom:67%;" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287413-9418d680-9aa1-11eb-9567-4f945bf8cc3d.png" alt="image" style="zoom:67%;" /></p>

<p>요거는 가변 객체</p>

<p>사이드 이펙트가 밝생할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287422-a72ba680-9aa1-11eb-85b9-2b8b618d9288.png" alt="image" style="zoom:50%;" /></p>

<p>값을 바꾸면 계속 새로운 객체를 만들죠 ?</p>

<p>무슨 개소리야 할 수 있지만 분명히 다르다.  근데 계속 객체를 할당 받아야 하네</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287441-bca0d080-9aa1-11eb-8e21-85791e04d06c.png" alt="image" style="zoom: 67%;" /></p>

<p>상태가 바뀌면 계속 새로운 것을 반환해주어야 하니…</p>

<p>불변 객체는 list 내부의 상태 데이터를 추가하고 뺴는 것도 불변 객체 이다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/114287451-d510eb00-9aa1-11eb-97a0-e90cf46af43a.png" alt="image" style="zoom:67%;" /></p>

<p>이렇게 clear하는 것도 허용이다.</p>

<p>❓그렇다면, 메모리의 주솟값이 불변이면, 메모리의 주솟값이 참조하고 있는 값이 변경되도 불변이다 라고 보는 건가요?<br />
-&gt; 그렇다.</p>

<h4 id="불변-객체와-상수-객체의-차이에-대해-공부해-보세요">불변 객체와 상수 객체의 차이에 대해 공부해 보세요.</h4>

<h3 id="불변-객체로-구현하면-좋은-점">불변 객체로 구현하면 좋은 점</h3>

<ul>
  <li>식별자 가변성 문제가 없다.</li>
  <li>실패 원자성이 있다 - 완전하고 견고한 상태의 객체를 가지거나, 실패하거나 둘 중 하나만 가능하다.</li>
  <li>시간적 결합을 제거할 수 있다. - 가변 객체가 많은 경우 연산들의 순서를 일일이 기억해야한다.</li>
  <li>사이드 이펙트를 제거할 수 있다.</li>
  <li>null 참조를 없앨 수 있다.</li>
  <li>스레드 세이프하다.</li>
  <li>더 작고 더 단순한 객체를 구현할 수 있다.</li>
</ul>

<h3 id="public-상수를-사용하지-마세요-">public 상수를 사용하지 마세요.. ?</h3>

<p>상수라고 불리는 <code class="highlighter-rouge">public static final</code> 프로퍼티는 객체 사이의 데이터를 공유하기 위해 사용한다.<br />
사용하지 말라는 이유는 객체들은 어떤 것도 공유해서는 안되기 때문이다.<br />
독립적이어야 하며, 닫혀 있어야 한다.</p>

<p>하지만 일반적으로는 public 상수를 쓰는게 관례이다.</p>

<p><strong>상수를 쓸거면 객체로 만들어라??</strong><br />
OOP에서 퍼블릭 상수를 절대로 사용하지 말라고 한다.<br />
사소한 상수라도 항상 작은 클래스를 이용해 대체할 것을 추천한다. <br />
enum도 public static final을 쓰는 건데 쓰지 마라!</p>

<p><strong>그냥 설계가 완벽하다 싶을 때 도전해라 ^^</strong></p>

<p>인스턴스 변수는 4개 이하로… 근데. 
번외로 데코레이터 필드는 허용된다고 생각합니다.</p>

<p>position, name의 클래스 접근자를 없애는 것은 ??<br />
그러면 패키지 내부의 결합도를 낮출 수 있고, 인터페이스로 다 만들려면 너무 많아지는 문제점 해결</p>

<p>스프링 프레임 뭐크는 객체들의 의존성을 없앤다.</p>

<p>스프링 프레임워크를 위한 강의였따.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📝 엘레강트 오브젝트 뽀개기 1 강의 정리</title>
	  <link>//%EC%97%98%EB%A0%88%EA%B0%95%ED%8A%B8-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%BD%80%EA%B0%9C%EA%B8%B0-1-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</link>
	  <author></author>
	  <pubDate>2021-03-20T19:18:00+09:00</pubDate>
	  <guid>//%EC%97%98%EB%A0%88%EA%B0%95%ED%8A%B8-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%BD%80%EA%B0%9C%EA%B8%B0-1-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</guid>
	  <description><![CDATA[
	     <p>강의를 들으며 정리하기 ✍️</p>

<h2 id="엘레강트-오브젝트">엘레강트 오브젝트</h2>

<p><img src="https://user-images.githubusercontent.com/43840561/111856837-ca66a880-8970-11eb-903f-b93200975d2e.png" alt="image" style="zoom:50%;" /></p>

<ul>
  <li>
    <p>문자열과 원시값을 포장해라</p>
  </li>
  <li>
    <p>반환 값은 모두 일급 컬렉션</p>

    <p><img src="https://user-images.githubusercontent.com/43840561/111856864-fc780a80-8970-11eb-9ada-2c99c659bcfd.png" alt="image" style="zoom:50%;" /></p>
  </li>
</ul>

<h3 id="인자의-값으로-null을-절대-허용하지-마세요">인자의 값으로 null을 절대 허용하지 마세요</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="nf">find</span><span class="o">(</span><span class="n">String</span> <span class="n">mask</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mask</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// .</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
<span class="c1">// .</span>
<span class="o">}</span> <span class="o">}</span>
</code></pre></div></div>

<p>null을 체크하는 로직을 구현하는 것은 객체를 무시하는 것이다.<br />
mask 객체를 존중했다면 조건의 존재 여부를 객체 스스로 결정하게 했을 것이다.<br />
이를 위해 <strong>원시 값과 문자열을 포장</strong>하면 null을 허용하지 않을 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857492-216e7c80-8975-11eb-8c28-ef1e68a6c3ba.png" alt="image" /></p>

<p>이 부분이 randomNumber를 무시하는 것이 아닌가.<br />
randomNumber를 객체로 만든다. (원시값 포장).</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857526-77432480-8975-11eb-92c2-3abaeb7ccbd3.png" alt="image" style="zoom:50%;" /></p>

<p>객체에게 메시지를 보내도록 리팩토링한다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857586-e02a9c80-8975-11eb-84d0-74f7930af1bc.png" alt="image" style="zoom:50%;" /></p>

<p>테스트 가능하게 오버라이딩.</p>

<p>RandomNumber의 null 체크 안해줘도 되나 ? <br />
이 메서드가 외부에 쓰인다면 고민해봐야하지만, 내부에서만 move가 호출되면 
null 체크를 굳이 안해줘도 좋다. 
내가 컨트롤할 수 있는 범위라면 안해도 될 것 같다.<br />
<code class="highlighter-rouge">move()</code> 를 사용하는 범위가 어디까지인지에 따라 null 체크 여부가 달린 것 같다.</p>

<h3 id="final이거나-abstract-이거나">final이거나 abstract 이거나</h3>

<p>상속은 객체들의 관계를 복잡하게 만드니 최대한 자제하고,<br />
final이나 abstract로 만들어라</p>

<p>변수에 <code class="highlighter-rouge">final</code> 을 붙이면 재할당이 불가능하지만, 메서드에 붙이면 오버라이딩이 불가하다.<br />
클래스에 <code class="highlighter-rouge">final</code> 은 상속을 불가능하게 한다.</p>

<p>final 클래스가 테스트 가능하도록 하는 법.
인터페이스로 만든다.</p>

<p>RandomNumber 클래스를 final로 만들고 Number 인터페이스를 만든다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857934-5e883e00-8978-11eb-8472-ac523772cb3b.png" alt="image" style="zoom:67%;" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/111857943-7069e100-8978-11eb-8e53-dd4b5f7d6b2c.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/43840561/111858087-862bd600-8979-11eb-91b5-49a3004f38d8.png" alt="image" style="zoom:50%;" /></p>

<p>그러면 이렇게 Number 인터페이스와 의존 관계를 맺는다. <br />
인터페이스와 의존 관계를 맺는게 final 클래스와 의존 관계를 맺는 것 보다 테스트가 더 용이하다.</p>

<p>클래스에 final을 붙이는 것은 좋은 습관이다.<br />
final을 테스트하고 싶으면 인터페이스를 추출하면 된다.</p>

<p>인터페이스 구현체가 여러개가 되면 중복들이 많아지는데, 
이 중복을 어떻게 없애나 ?<br />
인터페이스 구현체 중간에 추상 클래스를 둔다.<br />
Car - 인터페이스 <br />
AbstractCar - 추상 클래스<br />
Sonatar - 클래스</p>

<p>이러면 추상 클래스의 필요성을 느낄 수 있을 것이다.</p>

<p>근데 default 메소드를 사용하면 안되나 ?</p>

<p>포비는 default 를 남용하지 않는다.  추상 클래스를 쓰는게 더 좋다.</p>

<p>중복을 제거할 때 추상 클래스의 인스턴스 변수, 즉 인스턴스에 종속된 메서드면 default 메서드를 만들기 어려울 수 있다.  default 메서드를 만들 수 있는 경우, 없는 경우가 있으니 잘 구별.<br />
추상 클래스는 상태를 가지니 상태를 활용할 수 있다.</p>

<p>상속 때 부모 클래스에 있는 인스턴스 변수를 private로 막아라 ! <br />
그래야 캡슐화가 잘 되었다고 한다. <br />
접근할 때는 메서드를 통해 접근해라</p>

<h3 id="-er로-끝나는-이름을-사용하지-마세요">-er로 끝나는 이름을 사용하지 마세요</h3>

<p>클래스 이름을 지을 때 좋은 가이드.</p>

<p>클래스는 객체를 만들어 내는 역할일 뿐이다 (객체의 Factory).<br />
클래스는 객체를 만들고, 추적하고, 적절한 시점에 파괴한다 (라이프 사이클 관리).</p>

<p>클래스를 객체의 템플릿으로 바라보는 것은 클래스를 수동적인 존재로 만드는 것이다.<br />
클래스는 객체의 능동적인 관리자이다.<br />
객체를 꺼내거나 반환하는 저장소이다.</p>

<h4 id="클래스-이름을-짓는-방식">클래스 이름을 짓는 방식</h4>

<p>클래스의 객체들이 <strong>무엇을 하는지</strong> 가 아닌, <strong>무엇인지</strong> 에 기반해 지어라.</p>

<ul>
  <li><strong>무엇을 하는지</strong>로 이름을 지은 잘못된 예</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CashFormatter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">CashFormatter</span><span class="o">(</span><span class="kt">int</span> <span class="n">dollars</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">format</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"$ %d"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">dollars</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>무엇인지를 기반으로 객체의 역량을 나타내도록 이름을 지어야 한다.</p>

<ul>
  <li><strong>무엇인지</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="kt">int</span> <span class="n">dollars</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">usd</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"$ %d"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">dollars</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>객체는 객체의 외부 세계와 내부 세계를 이어주는 연결장치가 아니고,<br />
내부에 캡슐화된 데이터를 다루기 위해 요청할 수 있는 절차의 집합도 아니다.<br />
객체는 <strong>캡슐화된 데이터의 대표자</strong>이다.</p>

<p>무엇인지로 객체를 추출하면 무엇을 하는지까지 포괄하는 것이 아닌가. <br />
무엇을 하는지는 수동적인 존재가 된다.</p>

<p>메서드에서는 protected를 사용할 수 있는데 변수에는 사용하지 않는 것이 좋다.<br />
DTO는 모르겠는데 도메인 객체에서는 무조건 인스턴스 변수는 private여야 한다.</p>

<p>“무엇인지” 생각하지 않고 “무엇을 하는지”를 먼저 생각하고 설계하지 말라</p>

<p>처음에 메세지를 정하고 객체의 협력을 구상해야하는데 이를 하기 위해는 “무엇을 하는지”가 아니라 객체가 “무엇인지” 부터 생각을 해야하는 것 같아요. 객체가 무엇인지 생각하고 책임을 부여하면서 “무엇을 하는지” 가 된다.</p>

<p>이미 er과 or을 가지고 있는 것들은 써도 되지만, 나머지는 자제하라</p>

<p>CashFormatter가 아닌 FomattedCash는 어때 ?<br />
CashFormatter는<code class="highlighter-rouge">format()</code> 이외의 기능을 가지면 부자연스럽기 때문이다.</p>

<h3 id="메서드-이름을-신중하게-선택하세요">메서드 이름을 신중하게 선택하세요</h3>

<p>메서드 명은 무조건 동사가 아니다.</p>

<h4 id="빌더builder의-이름은-명사로">빌더(builder)의 이름은 명사로</h4>

<p>반환타입이 void가 아닌 메서드로, 무언가를 만들어 새로운 객체를 반환한다.<br />
이 메서드의 명은 항상 <strong>명사</strong>여야 한다.<br />
형용사를 덧붙여 메서드의 의미를 좀 더 풍부하게 설명하는 명사로 나타낼 수도 있다.</p>

<p>Ex) float speed(), Employee employee(), String parsedCell()</p>

<h4 id="조정자manipulator의-이름은-동사로">조정자(manipulator)의 이름은 동사로</h4>

<p>반환타입이 void인 메서드로 엔티티를 수정하는 메서드이다.<br />
이 메서드 명은 항상 <strong>동사</strong>여야 한다.<br />
부사를 덧붙여 메서드의 문맥과 목적에 관한 풍부한 정보를 제송하는 동사로 나타낼 수 있다.</p>

<p>ex) void save(String content), void quicklyPrint(int id);</p>

<h4 id="잘못된-예시">잘못된 예시</h4>

<p>boolean put(String key, Float value);</p>

<p>이 메서드는 <code class="highlighter-rouge">PutOperation</code> 과 같은 클래스를 추가해 <code class="highlighter-rouge">save()</code> , <code class="highlighter-rouge">success()</code> 메서드로 분리한다.</p>

<h4 id="빌더와-조정자로-분리---빌더는-명사다">빌더와 조정자로 분리 - 빌더는 명사다</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Bakery</span> <span class="o">{</span>
    <span class="n">Food</span> <span class="nf">cookBrownie</span><span class="o">();</span>
    <span class="n">Drink</span> <span class="nf">brewCupOfCoffee</span><span class="o">(</span><span class="n">String</span> <span class="n">flavor</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">cookBrownie()</code> , <code class="highlighter-rouge">brewCupOfCoffee()</code> 는 실제로는 객체의 메서드가 아니고, 프로시저이다.<br />
객체는 자신의 의무를 수행하는 방법을 알고 있고, 존중해줘야하는 살아있는 유기체이다.<br />
단순한 명령에 따르지 않고, 계약에 기반해 일하고 싶어한다.</p>

<p>하지만 관념적인 부분은 포기해도 괜찮다 !</p>

<p>getXxx()는 내부적으로 xxx를 가지고 있을 것이라는 것을 드러내지만,<br />
명사를 사용하면 그 메서드 내부에 로직이 있는지를 숨길 수 있다.</p>

<h4 id="빌더와-조정자로-분리---조정자는-동사다">빌더와 조정자로 분리 - 조정자는 동사다</h4>

<p>ex) DJ에게 음악을 틀어달라고 요청할 때</p>

<ul>
  <li>방법 1. 음악을 틀어주세요.</li>
  <li>방법 2. 음악을 틀고, 현재 볼륨 상태를 말해주세요.</li>
</ul>

<p>이 중 방법 1가 더 객체를 존중하고 있다.<br />
그 객체가 알아서 하겠지 ! 를 생각해라. 객체를 믿어라.</p>

<p>print도 매개변수가 다르니 <code class="highlighter-rouge">print()</code> 로 통일할 수 있다.</p>

<h4 id="빌더와-조정자로-분리-3---빌더와-조정자-혼합하기">빌더와 조정자로 분리 3 - 빌더와 조정자 혼합하기</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Document</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">write</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">content</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>값을 반환하고 있는 write를 빌더와 조정자로 분리한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Document</span> <span class="o">{</span>
    <span class="n">OutputPipe</span> <span class="nf">output</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">OutputPipe</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">content</span><span class="o">);</span>
    <span class="kt">int</span> <span class="nf">bytes</span><span class="o">();</span>
    <span class="kt">long</span> <span class="nf">time</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="빌더와-조정자로-분리---boolean-값을-반환하는-경우-형용사로-지어라">빌더와 조정자로 분리 - Boolean 값을 반환하는 경우 형용사로 지어라</h4>

<p>빌더이지만, 가독성을 위해 형용사로 지어라.</p>

<h3 id="생성자-하나를-주-생성자로-만드세요">생성자 하나를 주 생성자로 만드세요</h3>

<p><strong>클래스는 2~3개의 메서드와 5~10개의 생성</strong>자를 포함해야한다.</p>

<p>생성자가 많고 메서드가 적을 수록 응집도가 높고 견고한 클래스가 된다.<br />
생성자가 많을 수록 클라이언트가 클래스를 더 편하게 사용할 수 있다.</p>

<ul>
  <li>주 생성자 : 프로퍼티를 초기화한다. 오직 주 생성자만 담당한다.</li>
  <li>부 생성자 : 주 생성자를 호출한다.</li>
</ul>

<p>인자수가 적은 수부터 많은 순으로, 주 생성자는 마지막에 둔다.</p>

<p>테스트를 위한 생성자는 좋다 ! 하지만 메서드 추가는 옳지 않다 !
생성자 여러개를 테스트 할 때 다른 타입 매개변수의 생성자 동등성을 테스트 하면 된다.</p>

<p><em>뷰에서 List 정도로 가공은 할 수 있을 것 같다.</em></p>

<p>좋은 객체는 모든 메서드가 각각 모든 인스턴스 변수를 사용하고 있다 (100%는 어렵다).</p>

<h3 id="문서를-작성하는-대신-테스트를-만들어라">문서를 작성하는 대신 테스트를 만들어라</h3>

<p>주석이 없어도 클래스명과 메서드만을 봐도 무슨일을 하는지 알 수 있게,<br />
테스트를 통해  메서드의 의도를 알도록 하라.</p>

<p>깔끔하게 만든다라는 것은 단위 테스트도 만든다는 의미이다.<br />
단위 테스트는 클래스의 일부이고 독립적인 개체가 아니다.</p>

<h3 id="생성자에-코드를-넣지-마세요">생성자에 코드를 넣지 마세요</h3>

<p>인자에 손을 대지 말라는 의미이다.</p>

<ul>
  <li>잘못된 예시</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">dlr</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>생성자에 코드가 있을 경우 객체 변환과 관련한 예외를 제어할 수 없다.</p>

<ul>
  <li>좋은 예시</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringAsInteger</span><span class="o">(</span><span class="n">dlr</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringAsInteger</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">source</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">StringAsInteger</span><span class="o">(</span><span class="n">String</span> <span class="n">txt</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">source</span> <span class="o">=</span> <span class="n">txt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">intValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">source</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>이렇게 리팩토링을 하면 실제로 객체를 사용하는 시점까지의 객체 변환 작업은 연기된다.<br />
생성자에 코드가 없을 경우 성능 최적화가 더 쉬워 실행 속도가 더 빨라진다.</p>

<p>진정한 객체지향에서 인스턴스화란 더 작은 객체들을 조합해서 더 큰 객체를 만드는 것이다.</p>

<p>객체의 변환을 뒤로 미뤄 파싱이 여러번 실행되지 않도록  데코레이터(decorator)를 추가해 파싱 결과를 캐싱할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CachedNumber</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">origin</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cached</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">);</span>
    <span class="kd">public</span> <span class="nf">CachedNumber</span><span class="o">(</span><span class="n">Number</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>
<span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">intValue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">intValue</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">cached</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Number</span> <span class="n">dollars</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Cash</span><span class="o">(</span><span class="n">String</span> <span class="n">dlr</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dollars</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CachedNumber</span><span class="o">(</span><span class="k">new</span> <span class="n">StringAsInteger</span><span class="o">(</span><span class="n">dlr</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>


	  ]]></description>
	</item>

	<item>
	  <title>📖 Java 람다의 변수 범위</title>
	  <link>//Java-%EB%9E%8C%EB%8B%A4%EC%9D%98-%EB%B3%80%EC%88%98-%EB%B2%94%EC%9C%84</link>
	  <author></author>
	  <pubDate>2021-03-19T19:18:00+09:00</pubDate>
	  <guid>//Java-%EB%9E%8C%EB%8B%A4%EC%9D%98-%EB%B3%80%EC%88%98-%EB%B2%94%EC%9C%84</guid>
	  <description><![CDATA[
	     <h3 id="람다의-변수-범위">람다의 변수 범위</h3>

<p><img src="https://user-images.githubusercontent.com/43840561/111862130-956d4c80-8996-11eb-9abd-c2bef47886d9.png" alt="image" /></p>

<p>물론 위의 코드는 미션을 위해 일단 구현만을 목적으로 많은 리팩토링이 필요하니 참고 🥲<br />
미션을 진행하다가 for 문 내에 stream을 쓰게 되었는데, i의 값을 람다식 내에서 사용하려니 컴파일 에러가 났다.<br />
“Variable used in lambda expression should be final or effectively final”
즉 람다식에서 사용되는 변수는 final이거나 effectively final이어야 한다.</p>

<p>effectively final은 무엇이며, 람다의 변수 범위를 정확히 짚고 넘어가자.</p>

<h3 id="람다의-변수-범위-1">람다의 변수 범위</h3>

<p>다음과 같은 Lambda 클래스가 있고, 각각의 메서드를 호출해 클래스 필드인 <code class="highlighter-rouge">name</code>이 어떻게 바뀌는지 살펴본다 🔎</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lambda</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">example1</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">5</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">example2</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">10</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">example3</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">15</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/43840561/111862546-58568980-8999-11eb-8fb0-6ac25fc92285.png" alt="image" /></p>

<p>이에 대한 출력 결과는 다음과 같다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111862548-5ee50100-8999-11eb-9962-0697067614f8.png" alt="image" /></p>

<p>위 예제에서 람다식에서는 자신을 감싼 메서드나 클래스에 속한 변수에 접근을 할 수 있다.<br />
예제는 람다에 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수를 사용하고 있는데 이러한 변수를 <strong>자유 변수</strong>라고 부른다.</p>

<p>그렇다면 다시 맨 처음 오류를 가져와서 … 
<img src="https://user-images.githubusercontent.com/43840561/111862130-956d4c80-8996-11eb-9abd-c2bef47886d9.png" alt="image" /></p>

<p>이 부분에서 왜 자유 변수인 i를 final이나 effectvely final로 선언하라는 것일까 ?</p>

<p>먼저 <strong>지역 변수</strong>는 JVM에서 스택 영역에 저장이 된다. <br />
그리고 실제 메모리와 다르게 JVM에서 이 스택 영역은 스레드 마다 별도의 스택이 생성된다. <br />
따라서 지역 변수는 한 스레드 안에서만 사용이 되며, 스레드끼리 공유하지 못한다.</p>

<p>지역 변수와 다르게 인스턴스 변수는 힙 영역에 생성되어 서로 다른 스레드끼리도 공유할 수 있는 공유 변수이다.</p>

<p><strong>람다</strong>는 각각 별도의 스레드에서 실행이 가능하다.<br />
위 예제에서 각각의 메서드는 i를 증가시키는 것이 아니라 람다를 리턴할 뿐이다.<br />
실행 흐름 상 메서드를 호출한 스레드의 스택에 지역 변수인 i가 생성이 되는데,<br />
람다식을 반환한 후에는 해당 함수가 종료되었으니 메모리에서 i가 사라질 것이다. <br />
그렇지만 반환된 람다식은 다른 스레드에서 호출될 수 있는데, i가 GC에 의해 정리되어 접근할 수 없는 문제가 발생할 수 있다.</p>

<p>때문에 실행 시점에 지역 변수가 사라질 것을 방지하기 위해서 이 자유 변수의 복사본을 만들어서 동작한다. 
이 복사본을 가지고 동작할 예정인데, 이 복사본 값이 바뀌어 버리면 의도하지 않은 결과가 생길 수 있으므로 컴파일 단계에서<br />
final 또는 effectively final로 선언해 변수를 신뢰할 수 있게 만드는 것이다.<br />
이를 <strong>람다 캡처링</strong>이라고 한다.</p>

<p>위 문제에서 컴파일 에러가 뜨는 것은 i가 스코프 밖에 있어 값이 변할 수 있어 신뢰할 수 없다.<br />
때문에 인텔리제이가 권해주는 방법을 쓰면 i를 스코프 안 변수에 새로 할당해서 사용하게 된다.<br />
<img src="https://user-images.githubusercontent.com/43840561/111863899-7de79100-89a1-11eb-8ed3-6c685817269d.png" alt="image" /></p>

<p>여기서 i는 <code class="highlighter-rouge">final</code> 로 선언되지는 않았지만, 자바 8에서 추가된 effectively final로 선언된 것이다.<br />
effectively final은 final로 선언되지 않아도 컴파일러가 해당 변수가 변경되지 않았다고 판단할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111863962-d61e9300-89a1-11eb-85f8-b7e0a7d5ef7e.png" alt="image" /></p>

<p>만약 effectively final인 i의 값을 바꾸려 한다면 이렇게 컴파일 오류가 발생한다.</p>

<p>파도 파도 끝없는 람다의 세계 🤸‍♀️</p>

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://perfectacle.github.io/2019/06/30/java-8-lambda-capturing/">(Java) 람다 캡처링과 final 제약조건</a></li>
  <li><a href="https://futurecreator.github.io/2018/08/02/java-lambda-variable-scope/">Java Lambda (5) 변수 범위</a></li>
  <li><a href="https://jeong-pro.tistory.com/211">자바 람다에서 final이거나 final처럼 쓰인 지역 변수만 접근할 수 있는 이유</a></li>
</ul>

<hr />

<h3 id="enum-map">Enum Map</h3>


	  ]]></description>
	</item>

	<item>
	  <title>📝 Java8 Lambda, Stream API 강의 정리</title>
	  <link>//Java8-Lambda,-Stream-API-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</link>
	  <author></author>
	  <pubDate>2021-03-16T19:18:00+09:00</pubDate>
	  <guid>//Java8-Lambda,-Stream-API-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC</guid>
	  <description><![CDATA[
	     <h2 id="함수형-프로그래밍의-장점-">함수형 프로그래밍의 장점 ?</h2>

<h3 id="관심사의-분리">관심사의 분리</h3>

<p>관심사의 분리란 무엇일까? 예제를 들어보자.</p>

<p><code class="highlighter-rouge">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);</code> 리스트에 있는 <strong>원소마다 콜론을 추가</strong>하려 한다.</p>

<h4 id="이때-foreach-를-사용한다면-">이때 <code class="highlighter-rouge">forEach()</code> 를 사용한다면 ?</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">ForEach</span><span class="err">를</span><span class="n">_</span><span class="err">활용하여</span><span class="n">_</span><span class="err">콜론을</span><span class="n">_</span><span class="err">추가하는</span><span class="n">_</span><span class="err">문자열</span><span class="n">_</span><span class="err">작성</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">StringBuilder</span> <span class="n">stringBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="n">Integer</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">number</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">" : "</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stringBuilder</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">3</span><span class="o">,</span> <span class="n">stringBuilder</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>나는 <strong>원소마다 콜론 추가하는 것</strong>을 원하는데, forEach문을 작성하니 이를 어떻게(How) 구현할지에 집중하고 있는 것 같다.</p>

<h4 id="그렇다면-함수형-프로그래밍의-일종인-stream을-사용한다면-">그렇다면 함수형 프로그래밍의 일종인 Stream을 사용한다면 ?</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="n">Stream</span><span class="err">을</span><span class="n">_</span><span class="err">활용하여</span><span class="n">_</span><span class="err">콜론을</span><span class="n">_</span><span class="err">추가하는</span><span class="n">_</span><span class="err">문자열</span><span class="n">_</span><span class="err">작성</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">valueOf</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">joining</span><span class="o">(</span><span class="n">COLON_DELIMITER</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>요소마다 콜론을 결합하는 것</strong>을 메소드를 사용함으로서 개발자인 내가 무엇을(What)을 수행할 것인지에 집중할 수 있다.</p>

<h3 id="side-effect가-발생하지-않는다">Side Effect가 발생하지 않는다.</h3>

<ul>
  <li>Side Effect란 ? 함수 내의 실행으로 인해 함수 외부가 영향을 받는 것</li>
</ul>

<p>함수형 프로그래밍의 특징은 지역 변수만을 변경할 수 있고, 매개변수를 변경하지 않는다. <br />
즉, 함수는 같은 인수값으로 함수를 호출했을 때 항상 같은 값을 반환한다. (이 때 다른 값을 반환하는 Random, Scanner 등은 함수가 아니다).<br />
만약 함수에 참조하는 객체가 있다면 그 객체는 불변이어야 하며, 해당 객체의 모든 참조 필드도 불변 객체를 직접 참조해야 한다. <br />
함수 내에서 생성한 객체의 필드는 갱신할 수 있지만, 새로 생성한 필드의 갱신은 외부에 노출되면 안된다. <br />
또한 다음에 메서드를 다시 호출한 결과에 영향을 미치지 않으며, 어떠한 예외도 일으키지 않아야 한다. <br />
값이 변경되는 것을 허용한 객체를 멀티 스레드 프로그램에서 접근한다면, 값이 일정하지 않을 것이다.</p>

<p>하지만 단순히 구조만으로 순수성이 보장되지는 않고, 입력에 참조값이 오는 경우는 Side-Effect가 생긴다. 
이에 대한 내용은 <strong>참조 투명성</strong>을 살펴보자.</p>

<h4 id="참조-투명성">참조 투명성</h4>

<p>참조 투명성은 함수가 함수 외부의 영향을 받지 않는 것을 의미한다.<br />
또, 함수의 결과는 입력 파라미터에만 의존하고, 함수 외부 세계(입력 콘솔, 파일, 데이터 베이스 등)에서 데이터를 읽지 않는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">a</span><span class="o">++;</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 예제의 경우 원시 타입인 a의 값을 바꾸었는데, 자바의 원시타입의 매개변수는 call by value (메서드 호출 시 기본 자료형의 값을 인자로 전달하는 방식) 형태로 전달이 되어, 함수를 벗어나도 a에는 영향이 없다.<br />
여기서 인자로 참조 변수를 넣어주면 어떤 일이 발생할 수 있을까?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">position</span><span class="o">(</span><span class="n">Position</span> <span class="n">a</span><span class="o">,</span> <span class="n">Position</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">a</span><span class="o">.</span><span class="na">setX</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">getX</span><span class="o">())</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 참조 변수를 넘겨주면 함수 안에서 참조 변수의 값을 바꿀 수도 있기 때문에 side effect가 발생할 수 있다.<br />
함수형 프로그래밍은 이런 Side Effect가 발생하지 않는, 참조 투명성이어야 한다.</p>

<h3 id="일급-객체">일급 객체</h3>

<p>함수형 프로그래밍은 함수인 메서드가 일급 객체임을 말하는데, 일급 객체는 다음과 같은 특성을 가진다.</p>

<ul>
  <li>변수나 데이터에 할당할 수 있어야 한다.</li>
  <li>객체의 매개변수로 넘길 수 있어야 한다.</li>
  <li>객체의 반환 값으로 리턴할 수 있어야 한다.</li>
</ul>

<p>자바8 이전까지, 메서드는 일급 객체가 아니었지만, 자바8의 익명 함수의 등장으로 메서드도 일급 객체로 다룰 수 있게 되었다.<br />
또 이 익명 함수를 좀 더 단순화 한 것이 바로 람다 표현식(lambda expression)이다.</p>

<h3 id="boxing과-unboxing">Boxing과 UnBoxing</h3>

<p>원시 타입이 래퍼 클래스로 변환하는 것을 Boxing이라고 하며,<br />
래퍼 클래스를 원시 타입으로 형변환 하는 것을 UnBoxing이라고 한다. <br />
JDK1.5부터는 래퍼 클래스와 기본 자료형 사이의 변환을 자동으로 해주는 Auto Boxing과 Auto UnBoxing 기능을 지원한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">Integer</span> <span class="n">integer</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// Auto Boxing</span>
<span class="n">Integer</span> <span class="n">integer1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">777</span><span class="o">);</span> <span class="c1">// 명시적 Boxing</span>

<span class="kt">int</span> <span class="n">primitive</span> <span class="o">=</span> <span class="n">integer</span><span class="o">;</span> <span class="c1">// Auto UnBoxing</span>
</code></pre></div></div>

<p>#### Auto Boxing이 일어나는 예</p>

<p>자바에서는 래퍼 클래스에 대한 연산이 시도될 때, 연산을 하려는 두 객체를 Auto Unboxing을 하여 원시타입으로 변환 후,<br />
연산을 수행하게 된다. 래퍼 클래스와 원시 타입 간 연산도 동일하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="n">Integer</span> <span class="n">integer127</span> <span class="o">=</span> <span class="mi">127</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
  <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">127</span><span class="o">)</span>
  <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">integer127</span><span class="o">)</span>
  <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
<span class="o">);</span>

<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
  <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">128</span><span class="o">)</span>
  <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">integer127</span><span class="o">))</span>
  <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
<span class="o">);</span>
</code></pre></div></div>

<p>두 스트림 연산에서 원시 타입 <code class="highlighter-rouge">int</code> 인 값들의 Stream을 만들고 각각 래퍼 클래스 <code class="highlighter-rouge">Integer</code> 와 비교를 할 때 Auto Boxing이 일어난다.<br />
이때, <code class="highlighter-rouge">findFirst().get()</code> 을 하게 된다면 래퍼 클래스가 반환된다.<br />
이렇게 되면 각각 원시 타입에 Auto Boxing이 일어나니, <br />
원시 타입에 대한 스트림은 기본형 특화 스트림 (IntStream, LongStream, DoubleStream)을 사용하는 것이 성능상 좋다.</p>

<p>➕ 수업 예제에서 이 부분이 왜 127과 128로 나누었을까 크루들이랑 이야기를 했다.<br />
Integer 래퍼 클래스는 127까지 인스턴스를 미리 생성해 두기 때문에 <code class="highlighter-rouge">==</code> 연산자로도 비교가 가능하지만 (주소값을 비교하는 것이다),<br />
128부터는 새로운 인스턴스를 반환하기 때문에 동일성 검사인 <code class="highlighter-rouge">equals()</code> 를 사용해 반환한다.</p>

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://jinwooe.wordpress.com/2017/12/21/%EB%B6%80%EC%88%98-%ED%9A%A8%EA%B3%BC-side-effect-%EC%B0%B8%EC%A1%B0-%ED%88%AC%EB%AA%85%EC%84%B1-referential-transparency/">부수 효과 (Side Effect), 참조 투명성 (Referential Transparency)</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>🕹 Level 1. 블랙잭 미션 코드 리뷰 정리</title>
	  <link>//Level-1.-%EB%B8%94%EB%9E%99%EC%9E%AD-%EB%AF%B8%EC%85%98-%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0-%EC%A0%95%EB%A6%AC</link>
	  <author></author>
	  <pubDate>2021-03-15T19:18:00+09:00</pubDate>
	  <guid>//Level-1.-%EB%B8%94%EB%9E%99%EC%9E%AD-%EB%AF%B8%EC%85%98-%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0-%EC%A0%95%EB%A6%AC</guid>
	  <description><![CDATA[
	     <h2 id="-코드-리뷰-정리">💾 코드 리뷰 정리</h2>

<h3 id="controller에-있는-도메인-로직">Controller에 있는 도메인 로직</h3>
<p><img src="https://images.velog.io/images/new_wisdom/post/56c51213-0e01-48f5-ac72-8e76e77f73f1/image.png" style="zoom:50%;" /></p>

<p>게임 진행을 위해 Controller에 많은 역할을 구현했었다.<br />
위 피드백을 받고 BlackjackGame이라는 객체를 만들어 게임의 진행을 하도록 구현했다.<br />
각각의 플레이어들의 게임을 진행에 Input과 Output이 연결되어 있어서</p>

<p>처음 리팩토링에서는 BlackjackGame에서 플레이어들을 꺼내오고, 플레이어 하나 하나마다 게임을 진행하게 되었다.</p>

<p><strong>BlackjackController 일부</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">askWantToHit</span><span class="o">(</span><span class="n">Player</span> <span class="n">player</span><span class="o">,</span> <span class="n">BlackjackGame</span> <span class="n">blackjackGame</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">isAbleToAskHit</span><span class="o">(</span><span class="n">player</span><span class="o">,</span> <span class="n">blackjackGame</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">Answer</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">InputView</span><span class="o">.</span><span class="na">inputDrawAnswer</span><span class="o">()).</span><span class="na">isYes</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">blackjackGame</span><span class="o">.</span><span class="na">hit</span><span class="o">(</span><span class="n">player</span><span class="o">);</span>
        <span class="n">OutputView</span><span class="o">.</span><span class="na">printPlayerCards</span><span class="o">(</span><span class="n">player</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isAbleToAskHit</span><span class="o">(</span><span class="n">Player</span> <span class="n">player</span><span class="o">,</span> <span class="n">BlackjackGame</span> <span class="n">blackjackGame</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">blackjackGame</span><span class="o">.</span><span class="na">isNotGameOver</span><span class="o">(</span><span class="n">player</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">OutputView</span><span class="o">.</span><span class="na">printAskOneMoreCard</span><span class="o">(</span><span class="n">player</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://images.velog.io/images/new_wisdom/post/ed3abe31-8b66-4a6d-8a51-5f87404c2b83/image.png" style="zoom:50%;" /></p>

<p>하지만 결국 BlackjackGame에서 플레이어를 <code class="highlighter-rouge">get</code>해와 값을 조회하고,<br />
해당 값에 대한 로직이 Controller에서 처리되고 있었다.</p>

<p>게이츠의 말씀대로 도메인에 있어야 할 로직이 외부인 
Controller에서 처리되고 있는 것이다.
페어인 다니도 비슷한 리뷰를 받았는데, BlackjackGame 객체를 통해 게임 진행 과정을 캡슐화하라 하셨고,
이에 대해서는 <strong>출력을 제외하고 getter가 사용되는 부분이 하나도 남아있지 않아야 
캡슐화가 잘 진행되었다고 볼 수 있다</strong>고 하였다.</p>

<p>위 피드백들로 <strong>게임을 진행하는 역할</strong>을 완전히 BlackjackGame으로 옮기기 위해 
현재 게임이 끝나지 않은 플레이어들을 BlackjackGame에서 관리하도록 하고
(<code class="highlighter-rouge">getCurrentPlayer()</code>), BlackjackGame에서도 Players에게 현재 게임을 
진행해야 하는 Player를 얻어오도록 구현했다.</p>

<p>내가 적용한 부분은 다음과 같다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/88b9a4cc-0474-44a4-97b1-4832858046c9/image.png" style="zoom:50%;" /></p>

<hr />

<h3 id="테스트-코드의-가독성">테스트 코드의 가독성</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/a30b0ff5-2286-4a1e-819c-8073d35f97f0/image.png" style="zoom:50%;" /></p>

<p>리뷰어님께서 테스트 코드의 가독성을 위해 given, when, then으로 
줄바꿈 할 것을 권해주셨는데, 찾아보니 테스트 코드를 작성할 때 주로 사용하는
<a href="https://brunch.co.kr/@springboot/292">Given-When-Then Pattern</a>을 발견하였다.</p>
<ul>
  <li>
    <p>Given<br />
테스트를 위해 준비를 하는 과정
테스트에 사용하는 변수, 입력 값 등을 정의하거나, Mock 객체를 정의하는 구문 포함</p>
  </li>
  <li>
    <p>When<br />
실제로 액션을 하는 테스트를 실행하는 과정</p>
  </li>
  <li>
    <p>Then <br />
마지막은 테스트를 검증하는 과정
예상한 값, 실제 실행을 통해서 나온 값을 검증</p>
  </li>
</ul>

<p>사실 지금껏 테스트 코드를 짜는 것에만 집중을 하고 가독성은 고려하지 못했던 것 같다.
올바르게 적용한 것인지 확신은 없으나, 
앞으로 테스트 코드를 작성할 때 위 패턴을 지키려 노력해야겠다.</p>

<hr />

<h3 id="추상-메서드로-공통-기능을-선언하고-각각-구현하기">추상 메서드로 공통 기능을 선언하고 각각 구현하기</h3>

<p><img src="https://user-images.githubusercontent.com/43840561/111168509-79a82600-85e5-11eb-8143-e030459f1915.png" alt="image" style="zoom:50%;" /></p>

<p>기능 요구사항에서 초기 카드를 보여주는 로직이 딜러와 플레이어마다 달랐다. 딜러는 처음에 한장만 보여주고, 플레이어는 두장을 보여주어야 한다. 이를 처음 구현했을 때는 User 추상 클래스에 <code class="highlighter-rouge">public final Cards getCards()</code> 를 두고 플레이어는 초기에 이 메서드를 통해 카드를 2장인 Cards를 (사실은 전부) 반환하고, 딜러는 딜러만의 <code class="highlighter-rouge">Card showOneCard()</code> 를 통해 Card 객체를 반환한다. 반환 타입도 달라서 딜러와 플레이어들의 카드를 출력하기 위해서는 매개변수가 다른 출력 메서드들도 필요했다. 때문에 BlackjackGame 객체에서도 출력만을 위한 비슷한 <code class="highlighter-rouge">get()</code> 들이 생겨났다. 게이츠의 말씀대로 이렇게 추상 클래스인 User에 <code class="highlighter-rouge">Cards showInitialCard();</code>를 만들고 딜러와 플레이어 각각이
<code class="highlighter-rouge">getCardsByCount(int count)</code>에 각자 맞는 개수로 카드를 가져올 수 있도록 리팩토링 해보았다.</p>

<hr />

<h3 id="캐시-적용">캐시 적용</h3>

<p><img src="https://user-images.githubusercontent.com/43840561/111397796-7e63fb80-8705-11eb-9427-2ae8125ae479.png" alt="image" style="zoom:50%;" /></p>

<p>처음 로직 구현 때는 Deck 객체 자체를 static으로 만들어서 캐싱하는 방법으로 구현하였다.<br />
하지만 static은 메모리 주소를 하나만 가지기 때문에, 해당 게임을 여러 스레드에서 진행한다면 카드 배분에 문제가 생길 것이다.<br />
때문에 Deck을 그냥 인스턴스로 생성하게 하였는데, Deck에 들어갈 카드를 캐싱하는 부분을 생각하지 못했었다.<br />
처음에는 LottoNumber 때를 생각하고 of로 객체 하나하나를 반환해주어야 하나 고민을 했는데, 그냥 <code class="highlighter-rouge">List&lt;Card&gt;</code> 를 미리 생성하면 되었다.</p>

<p><img src="https://user-images.githubusercontent.com/43840561/111396928-6e4b1c80-8703-11eb-819b-388d0ac6be20.png" alt="image" style="zoom:50%;" /></p>

<hr />

<h3 id="ui와-관련된-로직">UI와 관련된 로직</h3>

<p><img src="https://user-images.githubusercontent.com/43840561/111469846-85712500-876a-11eb-988b-b8933870fd5b.png" alt="image" style="zoom:50%;" /></p>

<p>BlackjackGame 객체에서 카드를 더 받기 원하는지에 대한 대답을 받아야 했는데, 스스로는 BlackjackGame 객체가 게임 진행을 담당하고 있으니, yes / no 에 대한 정보는 yes인지 no인지에 따라 게임 진행 여부가 다르니, 게임 객체가 알아야 한다고 생각했다. 이에 대해 내 생각을 전달하고 의견을 물어보았는데, “BlackjackGame 객체가 블랙잭 게임 역할을 담당하고 있으니 yes no에 대한 정보를 가지고 있어도 괜찮지만 yes, no에 대한 정보는 UI 요구사항이라 추후에 예, 아니오로 변경됏을 때 도메인 객체까지 영향 범위가 갈 것 같다”라고 말씀하셨다. <strong>View의 요구사항이 변경되었을 때 도메인 객체까지 영향이 갈 것 같다</strong>는 부분은 생각하지 못했던 것 같다. 이 피드백에서 많은 인사이트를 얻었는데, 체스 게임 미션에서 사용자의 대답을 입력 받는 부분에 있어서 대답에 대한 검증을 어디에서 취해줄까를 계속 토론하다 게임 객체에서 해주었었는데, 이 답변을 받고 도메인 밖으로 대답 검증을 뺄 수 있었다.</p>

<h2 id="-미션-정리">💾 미션 정리</h2>

<h3 id="상태-패턴-적용기">상태 패턴 적용기</h3>
<p>0309 강의에서 이번 미션에 상태 패턴을 적용하여 구현하는 법에 대해 배웠다.
이번 미션을 진행하면서 스스로 제일 이슈라고 생각했던 부분은 
<strong>딜러와 플레이어의 점수만을 가지고 결과를 계산하는 것이 아니라,
딜러와 플레이어의 상태별로 결과를 계산하는 분기처리였다.</strong></p>

<p>이 부분에 대한 처리를 이번 미션동안 많이 고민해보았었고,
나의 삽질의 과정들을 함께 기록해보려 한다.</p>

<h4 id="1-if-문을-통한-처리">1. if 문을 통한 처리</h4>
<p>맨 처음 미션을 제출할 때는 각각의 상태에 따른 결과 산출을 if문을 통해서 처리해주었다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 변수로 다음과 같이 compareValue를 가지고 있음
* private final String result;
* private final int compareValue;
*/</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="n">Result</span> <span class="nf">decide</span><span class="o">(</span><span class="n">Dealer</span> <span class="n">dealer</span><span class="o">,</span> <span class="n">Player</span> <span class="n">player</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dealer</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">player</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">WIN</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dealer</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">player</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">STAND_OFF</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">dealer</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">player</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">isBust</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">LOSE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
	    <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">value</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">.</span><span class="na">compareValue</span> <span class="o">==</span> <span class="n">player</span><span class="o">.</span><span class="na">cards</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">dealer</span><span class="o">.</span><span class="na">cards</span><span class="o">))</span>          
            <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
            <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(</span><span class="nl">IllegalArgumentException:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>하지만 이렇게 구한 결과에 스스로 다음과 같은 문제점을 느꼈다.</strong></p>
<ul>
  <li>딜러와 플레이어의 상태를 비교하는 동일한 행위를 if문으로 반복해서 처리하여 길어진 <code class="highlighter-rouge">decide()</code></li>
  <li>해당 타입을 구하기 위한 책임이 분리되어 있음 (데이터와 로직 분리되어 있음)</li>
  <li>compareValue인 <code class="highlighter-rouge">1, 0, -1</code> 값이 Result의 의미를 명확히 드러내지 못함</li>
  <li>만약 실수로 <code class="highlighter-rouge">decide()</code>의 if문 한줄을 지웠다면 프로그램 오류</li>
</ul>

<p>때문에 if문으로 처리했던 상태들을 어떻게 줄일 수 있을까 많은 고민을 했다.</p>

<h4 id="2-함수형-인터페이스를-통한-처리">2. 함수형 인터페이스를 통한 처리</h4>
<blockquote>
  <p><a href="https://jojoldu.tistory.com/137">Enum 활용사례 3가지</a>
<a href="https://dev3m.tistory.com/entry/ENUM-Funcational-Interface%EB%A1%9C-if%EB%AC%B8-%EC%A4%84%EC%9D%B4%EA%B8%B0">ENUM + Funcational Interface 활용하기</a></p>
</blockquote>

<p>해결책을 찾아보다, 위 글들을 참고하여 딜러와 플레이어의 상태마다 다른 처리를 
함수형 인터페이스를 사용해 구현해보았다.</p>

<p>이에 스스로 <a href="https://velog.io/@new_wisdom/Java-Functional-Interface-%EB%B6%80%EC%88%98%EA%B8%B0">함수형 인터페이스를 학습하며 정리하고</a> 
Dealer에 대한 Player의 결과를 구하는 로직을 <code class="highlighter-rouge">BiPredicate&lt;T&gt;</code>로 처리했다.
함수형 인터페이스를 사용하여 딜러, 플레이어의 상태별 / 점수별 결과 산출 코드는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Result</span> <span class="o">{</span>
    <span class="n">WIN</span><span class="o">(</span><span class="s">"승"</span><span class="o">,</span> <span class="o">(</span><span class="n">playerNotBust</span><span class="o">,</span> <span class="n">dealerNotBust</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">playerNotBust</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dealerNotBust</span><span class="o">,</span>
            <span class="o">(</span><span class="n">playerScore</span><span class="o">,</span> <span class="n">dealerScore</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">playerScore</span> <span class="o">&gt;</span> <span class="n">dealerScore</span><span class="o">),</span>
    <span class="n">STAND_OFF</span><span class="o">(</span><span class="s">"무"</span><span class="o">,</span> <span class="o">(</span><span class="n">playerNotBust</span><span class="o">,</span> <span class="n">dealerNotBust</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">playerNotBust</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dealerNotBust</span><span class="o">,</span>
            <span class="nl">Integer:</span><span class="o">:</span><span class="n">equals</span><span class="o">),</span>
    <span class="n">LOSE</span><span class="o">(</span><span class="s">"패"</span><span class="o">,</span> <span class="o">(</span><span class="n">playerNotBust</span><span class="o">,</span> <span class="n">dealerNotBust</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">playerNotBust</span> <span class="o">&amp;&amp;</span> <span class="n">dealerNotBust</span><span class="o">,</span>
            <span class="o">(</span><span class="n">playerScore</span><span class="o">,</span> <span class="n">dealerScore</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">playerScore</span> <span class="o">&lt;</span> <span class="n">dealerScore</span><span class="o">);</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">result</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">BiPredicate</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">statusPredicate</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">BiPredicate</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">scorePredicate</span><span class="o">;</span>

<span class="c1">// ... </span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Result</span> <span class="nf">decide</span><span class="o">(</span><span class="n">User</span> <span class="n">player</span><span class="o">,</span> <span class="n">User</span> <span class="n">dealer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">value</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">.</span><span class="na">statusPredicate</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">player</span><span class="o">.</span><span class="na">isAbleToHit</span><span class="o">(),</span> <span class="n">dealer</span><span class="o">.</span><span class="na">isAbleToHit</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
                <span class="o">.</span><span class="na">orElseGet</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">decideByScore</span><span class="o">(</span><span class="n">player</span><span class="o">.</span><span class="na">score</span><span class="o">(),</span> <span class="n">dealer</span><span class="o">.</span><span class="na">score</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Result</span> <span class="nf">decideByScore</span><span class="o">(</span><span class="kt">int</span> <span class="n">playerScore</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dealerScore</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">value</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">.</span><span class="na">scorePredicate</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">playerScore</span><span class="o">,</span> <span class="n">dealerScore</span><span class="o">))</span>
                <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
                <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">"승패 결과 조건에 매치되지 않습니다."</span><span class="o">));</span>
    <span class="o">}</span>
<span class="c1">// ...</span>
</code></pre></div></div>
<p>이렇게 Enum에 함수형 인터페이스를 사용하여 결과 산출을 했을 때,<br />
<strong>스스로 다음과 같은 장점을 느꼈다.</strong></p>
<ul>
  <li>동일한 기능(딜러와 플레이어의 상태를 비교)에 대해 각각 다른 연산을 가지고 있어 
늘어졌던 <code class="highlighter-rouge">decide()</code> 단순화</li>
  <li>(현 프로그램에서는 그럴일이 없겠지만) 새로운 Result 타입이 추가되어도,
메서드의 추가적 수정이 없다.</li>
  <li>타입이 해야 하는 기능에 대해서 가장 잘 알고 있을 수밖에 없는,
자신 안에 로직을 추가하면서, 로직에 대한 명확한 상수명을 가짐</li>
</ul>

<p>이렇게 함수형 인터페이스를 사용하면서 이를 사용했을 경우의 장점을 스스로 생각하고,<br />
리뷰어님께 질문을 남겼는데 추가적으로 의견을 달아주셨다 👀</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/7f0a6deb-3e53-49b1-8424-87ad3876b191/image.png" style="zoom:50%;" /></p>

<h3 id="상태-패턴">상태 패턴</h3>
<p>미션 2단계를 시작하면서, 베팅 금액을 입력 받고 상태에 따라 수익을 구하는 기능을 추가해야했다.
미션을 시작하기 앞서,
0309 블랙잭 피드백 강의에서 다룬 상태패턴을 적용해 여러 분기처리를 해결하고 싶었고,
이후 스스로 상태 패턴에 대해 더 찾아보고 이번 미션을 통해 
<strong>상태패턴이 무엇이고, 이를 적용하면 어떠한 장점이 있는지 알아보자!</strong>를 목표로
상태패턴 적용길을 걸었다.</p>

<h4 id="내가-적용한-상태-패턴">내가 적용한 상태 패턴</h4>
<p>제이슨 코드를 미리 보고 상태패턴을 시도했기 때문에,  스스로 생각해보지 못한 코드 따라쟁이가 되어버릴까봐 스스로 계속해서 상태별로 다르게 구현해야할 기능들에 대하여 생각해보고 클래스 다이어그램에 나름대로의 명분을 정리해보았다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/5c238570-b95c-4c63-b6ae-6e4b2ab77716/image.png" style="zoom:50%;" /></p>

<p>또한 아래는 상태 패턴의 콘텍스트인 User 클래스이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="kd">final</span> <span class="n">Name</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">protected</span> <span class="n">State</span> <span class="n">state</span><span class="o">;</span>
    <span class="kd">protected</span> <span class="n">Money</span> <span class="n">bettingMoney</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="k">new</span> <span class="n">Name</span><span class="o">(</span><span class="n">name</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="n">Name</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">initializeCards</span><span class="o">(</span><span class="n">Cards</span> <span class="n">cards</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">StateFactory</span><span class="o">.</span><span class="na">generateStateByCards</span><span class="o">(</span><span class="n">cards</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isAbleToHit</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">state</span><span class="o">.</span><span class="na">isFinish</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Score</span> <span class="nf">score</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="na">cards</span><span class="o">().</span><span class="na">totalScore</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Cards</span> <span class="nf">cards</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="na">cards</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">State</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">changeState</span><span class="o">(</span><span class="n">State</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">hit</span><span class="o">(</span><span class="n">Card</span> <span class="n">card</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">changeState</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">draw</span><span class="o">(</span><span class="n">card</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">stay</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">changeState</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">stay</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="c1">// ...</span>
</code></pre></div></div>

<p>콘텍스트의 필드로 상태(State)를 가지고 있으며, 
상태에 관련된 기능들을 그 상태에게 메시지를 보내 처리하도록 하였다.</p>

<h4 id="ps">PS</h4>

<p><img src="https://images.velog.io/images/new_wisdom/post/20bb1288-8fec-4e05-a353-61be9fefc696/image.png" style="zoom:50%;" /></p>

<p>위 말은 교육장에서 포비와 이야기를 나누다 인상 깊어 스스로 DM에 남겨놓은 말이다.
말씀대로 디자인 패턴이 무조건 좋은 것은 아니지만, 
개인적으로는 <strong>이번 미션동안 제일 고민했던 부분인 상태에 따른 여러가지 분기처리를
어떻게하면 효과적으로 구현할 수 있을까? 에 대한 좋은 답이 상태패턴이라 생각하여</strong>
상태 패턴을 사용하는 방법과 이점을 느껴보고 싶었기에 스스로 좋은 시도였다고 생각한다 !
물론 다른 미션에서 상태패턴을 적용하라하면 잘 적용할 수 있을지는 모르겠으나,
이번 미션을 통해 이렇게 상태에 따른 분기처리를 줄일 수 있구나, 
디자인 패턴은 이런 장점이 있구나를 느낄 수 있었다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📖 Stream 부수기</title>
	  <link>//Stream-%E1%84%87%E1%85%AE%E1%84%89%E1%85%AE%E1%84%80%E1%85%B5</link>
	  <author></author>
	  <pubDate>2021-02-25T19:18:00+09:00</pubDate>
	  <guid>//Stream-%E1%84%87%E1%85%AE%E1%84%89%E1%85%AE%E1%84%80%E1%85%B5</guid>
	  <description><![CDATA[
	     <p>코드를 짜다보면 가독성과 간결함을 위해 stream을 자주 쓰게 된다.<br />
프리코스 때 Stream에 대해 정리했었으나,<br />
내가 쓴 글을 리팩토링(ㅎ) 해보면서 다시 개념을 익혀야 겠다.</p>

<h2 id="스트림">스트림?</h2>
<p>배열 또는 컬렉션 인스턴스에 저장된 데이터를 꺼내서 파이프에 흘려보낸다.</p>
<ul>
  <li>중간 연산 : 마지막이 아닌 위치에서 진행이 되어야 하는 연산</li>
  <li>최종 연산 : 마지막에 진행이 되어야 하는 연산
스트림은 중간 연산과 최종 연산을 진행하기 좋은 구조로 배치된 복사본이라 할 수 있다.</li>
</ul>

<h3 id="스트림의-특성">스트림의 특성</h3>
<h4 id="가독성과-간결함">가독성과 간결함</h4>
<p>컬렉션이나 배열에 데이터를 담고 원하는 결과를 얻기 위해 
for문과 Iterator를 이용해 작성한 코드는 가독성이 떨어지고 재사용성도 떨어진다.</p>

<h4 id="데이터-소스-추상화">데이터 소스 추상화</h4>
<p>어떤 메소드로 처리하기 위해 데이터 소스마다 다른 방식으로 다뤄야 하는 문제를
스트림을 통해 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있게 되었다.<br />
이는 코드의 재사용성을 가져온다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">listStream</span> <span class="o">=</span> <span class="n">strList</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">arrayStream</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">strArr</span><span class="o">);</span>

<span class="n">listStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="n">arrayStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<p>두 스트림의 데이터 소스는 서로 다르지만, 정렬하고 출력하는 방법은 같다.</p>

<h4 id="데이터-소스를-변경하지-않는다">데이터 소스를 변경하지 않는다.</h4>
<p>스트림은 데이터 소스로 부터 데이터를 읽기만 할 뿐, 
데이터 소스를 변경하지 않는다.<br />
필요시에만 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수도 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sortedList</span> <span class="o">=</span> <span class="n">listStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">Collections</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<h4 id="스트림은-일회용이다">스트림은 일회용이다.</h4>
<p>Iterator처럼 일회용이다. 한번 사용하면 닫혀서 다시 사용할 수 없다.<br />
필요하다면 스트림을 다시 생성해야한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">listStream</span><span class="o">.</span><span class="na">sorted</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">print</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">numOfElement</span> <span class="o">=</span> <span class="n">listStream</span><span class="o">.</span><span class="na">count</span><span class="o">();</span> <span class="c1">//에러- 스트림이 이미 닫혔다.</span>
</code></pre></div></div>

<h4 id="내부-반복">내부 반복</h4>
<p>스트림이 간결한 이유중 하나가 반복문을 메서드 내부에 숨기는 ‘내부 반복’ 덕분이다.<br />
<code class="highlighter-rouge">forEach()</code>는 스트림에 정의된 메서드 중의 하나로 매개변수에 대입된 
람다식을 데이터 소스의 모든 요소에 적용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<h2 id="스트림-생성하기">스트림 생성하기</h2>
<h3 id="스트림의-생성">스트림의 생성</h3>
<h4 id="메소드">메소드</h4>
<p>스트림 생성과 관련해 <code class="highlighter-rouge">Stream&lt;T&gt;</code> 인터페이스에 정의되어 있는 static 메소드는 두 개가 있다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static &lt;T&gt; Stream&lt;T&gt;(T t)
static &lt;T&gt; Stream&lt;T&gt; of(T...values)
</code></pre></div></div>
<p>이 메소드에 스트림 생성에 필요한 데이터를 인자로 직접 전달할 수 있다.</p>

<h4 id="example">Example</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class StreamOfStream {
    public static void main(String[] args) {
        // ex 1
        Stream.of(11, 22, 33, 44)
            .forEach(n -&gt; System.out.print(n + "\t"));
        System.out.println();

        // ex 2
        Stream.of("So Simple")
            .forEach(s -&gt; System.out.print(s + "\t"));
        System.out.println();

        // ex 3 세 개의 문자열로 이뤄진 스트림이 생성되는 것이 아닌
        // sl이 참조하는 하나의 인스턴스만 존재한다.
        List&lt;String&gt; sl = Arrays.asList("Toy", "Robot", "Box");
        Stream.of(sl)
            .forEach(w -&gt; System.out.print(w + "\t"));
        System.out.println();       
    }
}
</code></pre></div></div>
<p>of 메소드에 컬렉션 인스턴스를 전달하면 해당 인스턴스 하나로 이뤄진 스트림이 생성된다. <br />
하지만 배열을 전달하면 하나의 배열로 이뤄진 스트림이 생성되지 않고,<br />
배열에 저장된 요소로 이뤄진 스트림이 생성된다.</p>

<h3 id="배열">배열</h3>
<p>배열에 저장된 데이터를 대상으로 스트림을 생성할 때 호출되는 대표 메소드는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">satic</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">stream</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span> <span class="c1">// Arrays 클래스에 정의되어 있다</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">StringStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">"YOON"</span><span class="o">,</span> <span class="s">"LEE"</span><span class="o">,</span> <span class="s">"PARK"</span><span class="o">};</span>
        
        <span class="c1">// 스트림 생성</span>
        <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stm</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
        
        <span class="c1">// 최종 연산 진행</span>
        <span class="n">stm</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>forEach는 최종 연산이며 메소드의 매개변수형은 <code class="highlighter-rouge">Consumer&lt;T&gt;</code> 이므로 람다식을 인자로 전달해야하며, <br />
내부적으로 스트림 데이터를 하나씩 인자로 전달하면서 accept 메소드를 호출한다.</p>

<h3 id="컬렉션-인스턴스">컬렉션 인스턴스</h3>
<p>컬렉션 인스턴스를 대상으로 스트림을 생성할 때 호출되는 메소드는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">default</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">stream</span><span class="o">()</span>
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ListStream {
    public static void main(String[] args) {
        
        List&lt;String&gt; list = Arrays.asList("Toy", "Robot", "Box");
        
        list.stream()
          .forEach(s -&gt; System.out.print(s + "\t"));

        System.out.println();
    }
}
</code></pre></div></div>

<h3 id="특정-범위의-정수">특정 범위의 정수</h3>
<p><code class="highlighter-rouge">IntStream</code>과 <code class="highlighter-rouge">LongStream</code>은 지정된 범위의 연속된 정수를 스트림으로 생성해서
반환하는 <code class="highlighter-rouge">range()</code>와 <code class="highlighter-rouge">rangeClosed()</code>를 가지고 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IntStream intStream = IntStream.range(1, 5); // 1,2,3,4,
IntStream intStream = IntStream = Intstream.rangeClosed(1, 5); // 1,2,3,4,5 
</code></pre></div></div>
<p><code class="highlighter-rouge">range</code>는 end가 범위에 포함되지 않고 <code class="highlighter-rouge">rangeClosed</code>는 포함된다.</p>

<h3 id="람다식---iterate-generate">람다식 - iterate(), generate()</h3>
<p>Stream 클래스의 <code class="highlighter-rouge">iterate()</code>와 <code class="highlighter-rouge">generate()</code>는 람다식을 매개변수로 받아서,<br />
이 람다식에 의해 계산되는 값들을 요소로 하는 무한 스트림을 생성한다.</p>

<p>이때 생성되는 스트림은 무한하기 때문에 <code class="highlighter-rouge">limit()</code>를 호출하여 특정 사이즈로 제한해주는 것이 좋다.</p>
<h4 id="iterate">iterate()</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">evenStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
<span class="c1">// 0, 2, 4 ...</span>
</code></pre></div></div>
<p>씨드로 지정된 값부터 시작해서,  람다식에 의해 계산된 결과를 다시 시드 값으로 해서 
계산을 반복한다.</p>

<h4 id="generate">generate()</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">randomStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="nl">Math:</span><span class="o">:</span><span class="n">random</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">iterate()</code>처럼 람다식에 의해 계산되는 값을 요소로 하는 무한 스트림을 생성해서
반환하지만, <code class="highlighter-rouge">iterate()</code>와 달리 이전 결과를 이용해서 다음 요소를 계산하지 않는다.</p>

<h3 id="빈-스트림">빈 스트림</h3>
<p>요소가 하나도 없는 비어있는 스트림을 생성할 수도 있다.<br />
스트림에 연산을 수핸한 결과가 하나도 없을 때, null보다 빈 스트림을 반환하는게 낫다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span> <span class="n">emptyStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span> <span class="c1">// empty() 는 빈 스트림을 생성해서 반환한다.</span>
<span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">emptyStream</span><span class="o">.</span><span class="na">count</span><span class="o">();</span> <span class="c1">// count값은 0</span>
</code></pre></div></div>
<p>여기서 <code class="highlighter-rouge">count()</code>는 요소의 갯수를 반환한다.</p>

<h2 id="스트림의-연산">스트림의 연산</h2>
<h4 id="지연-처리">지연 처리</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyFirstStream2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ar</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>

        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">ar</span><span class="o">)</span> <span class="c1">// 스트림을 생성</span>
                        <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// filter 통과</span>
                        <span class="o">.</span><span class="na">sum</span><span class="o">();</span> <span class="c1">// sum을 통과시켜 그 결과를 반환</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위 예제에서 쓰인 두 메소드는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">IntStream</span> <span class="nf">stream</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span>
<span class="n">IntStream</span> <span class="nf">filter</span><span class="o">(</span><span class="n">IntPredicate</span> <span class="n">predicate</span><span class="o">)</span>
</code></pre></div></div>
<p>filter와 sum 메소드는 IntStream의 인스턴스 메소드이다.</p>

<p>스트림의 연산은 “지연 처리” 방식으로 동작한다.<br />
최종 연산이 수행 되기 전까지는 중간 연산이 수행되지 않는다.</p>

<p>위 예제에서는 sum이 호출될 때까지 filter의 호출 결과는 스트림에 반영되지 않는다.<br />
최종 연산인 sum이 호출되어야만 filter의 호출 결과가 스트림에 반영된다.<br />
이처럼 최종 연산이 생략되면 중간 연산이 의미가 없다.</p>

<h3 id="스트림의-중간-연산">스트림의 중간 연산</h3>
<p>연산 결과가 스트림인 연산으로, 스트림에 연속해서 중간 연산할 수 있다.</p>
<h3 id="filter-필터링">filter (필터링)</h3>
<p>스트림을 구성하는 데이터 중 일부를 조건에 따라 걸러내는 행위를 의미한다.</p>
<h4 id="메소드-1">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span> <span class="c1">// Stream&lt;T&gt;에 존재</span>
</code></pre></div></div>
<p>매개변수 형이 Predicate이므로 test 메소드의 구현에 해당하는 람다식을 
인자로 전달해야 한다.<br />
내부적으로 스트림 데이터를 하나씩 인자로 전달하면서 test를 호출하고,<br />
그 결과가 true이면 해당 데이터를 스트림에 남긴다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FilterStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ar</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">ar</span><span class="o">)</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// 홀수만 통과</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"Toy"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">,</span> <span class="s">"Box"</span><span class="o">);</span>
        <span class="n">sl</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">// 길이가 3이면 통과</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>       
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h3 id="map-맵핑">map (맵핑)</h3>
<p>스트림 요소에서 저장된 값 중에서 원하는 필드만 뽑아내거나 특정 형태로 변환해야 할 떄가 있다.<br />
맵핑을 진행하면 스트림의 데이터 형이 달라지는 특징이 있다.</p>

<h4 id="메소드-2">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span>
</code></pre></div></div>
<p>매개변수 형이 Function이므로 apply 메소드의 구현에 해당하는 람다식을 
인자로 전달해야 한다.<br />
내부적으로 스트림 데이터를 하나씩 인자로 전달하면서 apply를 호출하고,<br />
그 결과로 반환되는 값을 모아 새 스트림을 생성한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MapToInt</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"Box"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">,</span> <span class="s">"Simple"</span><span class="o">);</span>
        
        <span class="n">ls</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
          <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
          <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h4 id="map-vs-flatmap">map vs flatMap</h4>
<h5 id="map의-메소드">map의 메소드</h5>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span>
</code></pre></div></div>
<p>map에 전달할 람다식에서는 스트림을 구성할 데이터만 반환하면 된다.</p>
<h5 id="flatmap의-메소드">flatMap의 메소드</h5>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;&gt;</span> <span class="n">mapper</span><span class="o">)</span>
</code></pre></div></div>
<p>flatMap에 전달할 람다식에서는 스트림을 생성하고 이를 반환해야 한다.</p>

<h3 id="filter--map">filter &amp; map</h3>
<h4 id="example-1">example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
	<span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="o">)</span>
	<span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">getPrice</span><span class="o">())</span>
	<span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="sorted">sorted</h3>
<h4 id="메소드-3">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">sorted</span><span class="o">()</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">compatator</span><span class="o">)</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">sorted()</code>는 지정된 Comparator로 스트림을 정렬하는데, Comparator대신 
int 값을 반환하는 람다식을 사용할 수도 있다.<br />
Comparator를 지정하지 않으면 스트림 요소의 기본 정렬 기준으로 정렬한다.<br />
하지만 스트림 요소가 Comparable을 구현한 클래스가 아니면 예외가 발생한다.<br />
정렬에 사용되는 메서드의 개수가 많지만 기본적인 메서드는 <code class="highlighter-rouge">comparing()</code>이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">comparing</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">keyExtractor</span><span class="o">)</span>
<span class="n">comparing</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">keyExtractor</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">keyComparator</span><span class="o">)</span>
</code></pre></div></div>
<p>스트림 요소가 Comparable을 구현한 경우, 매개변수 하나짜리를 사용하면 되고,<br />
그렇지 않으면 추가적인 매개변수로 정렬기준(Comparator)을 따로 지정해줘야 한다.</p>

<p>정렬 조건을 추가할 때는 <code class="highlighter-rouge">thenComparing()</code>을 사용한다.</p>

<h4 id="example-2">Example</h4>
<p>학생 스트림을 반별, 성적순, 이름 순으로 정렬하는 예시이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">student</span><span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="nl">Student:</span><span class="o">:</span><span class="n">getBan</span><span class="o">)</span>
	<span class="o">.</span><span class="na">thenComparing</span><span class="o">(</span><span class="nl">Student:</span><span class="o">:</span><span class="n">getTOtalScore</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenComparing</span><span class="o">(</span><span class="nl">Student:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span>
        <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="peek">peek</h3>
<p>스트림을 이루는 모든 데이터 각각을 대상으로 특정 연산을 진행하는 행위를 “루핑”이라 한다.<br />
forEach는 루핑으로 최종연산이지만, 중간연산에도 루핑 메소드가 있다.</p>

<h4 id="메소드-4">메소드</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Stream&lt;T&gt;의 메소드
Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)
</code></pre></div></div>
<h4 id="example-3">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">LazyOpStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 최종 연산이 생략된 스트림의 파이프 라인</span>
        <span class="c1">// 아무 것도 출력되지 않는다.</span>
        <span class="n">IntStream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
            <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">d</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

  
        <span class="c1">// 최종 연산이 존재하는 파이프 라인</span>
        <span class="n">IntStream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
            <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">d</span> <span class="o">+</span> <span class="s">"\t"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">sum</span><span class="o">();</span>            
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="스트림의-최종-연산">스트림의 최종 연산</h2>
<p>최종 연산은 스트림의 요소를 소모해서 결과를 만들어낸다.<br />
그래서 최종 연산 후에는 스트임니 닫혀 더 이상 사용할 수 없다.<br />
최종 연산의 결과는 스트림의 요소의 합과 같은 단일 값이거나, <br />
스트림의 요소가 담긴 배열 또는 컬렉션일 수 있다.</p>

<h3 id="foreach">forEach</h3>
<p>지정된 작업을 스트림의 모든 요소에 대해 수행한다.
주의할 점은 <code class="highlighter-rouge">forEach()</code>는 스트림의 요소를 소모하면서 작업을 수행하므로 같은 스트림에 <code class="highlighter-rouge">forEach()</code>를 두 번 호출할 수 없다.</p>

<h4 id="메소드-5">메소드</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Stream&lt;T&gt;의 메소드
void forEach(Consumer&lt;? super T&gt; action)
</code></pre></div></div>
<p><code class="highlighter-rouge">peek()</code>과 달리 스트림의 요소를 소모하는 최종 연산이기 때문에 반환형이 void이다.</p>

<h3 id="reduce">reduce</h3>
<p>스트림 요소를 줄여나가면서 연산을 수행하고 최종 결과를 반환한다.<br />
처음 두 요소를 가지고 연산한 결과를 가지고 그 다음 요소와 연산한다.<br />
이 과정에서 스트림의 요소를 하나씩 소모하게 되며, 스트림의 모든 요소를 소모하면 그 결과를 반환한다.</p>

<p>스트림의 요소가 하나도 없는 경우, 초기값이 반환되므로 반환타입이 <code class="highlighter-rouge">Optional&lt;T&gt;</code>가 아니라 <code class="highlighter-rouge">T</code>이다.</p>
<h4 id="메소드-6">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">T</span> <span class="n">identity</span><span class="o">,</span> <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">)</span> <span class="c1">// Stream&lt;T&gt;에 존재</span>
</code></pre></div></div>
<p>reduce는 전달하는 람다식에 의해 연산의 내용이 결정된다.</p>

<p><strong><code class="highlighter-rouge">BinaryOperator&lt;T&gt;</code>의 추상 메소드</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T apply(T t1, T t2)
</code></pre></div></div>
<p>reduce 호출 시 메소드 apply에 대한 람다식을 인자로 전달해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ReduceStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"Box"</span><span class="o">,</span> <span class="s">"Simple"</span><span class="o">,</span> <span class="s">"Complex"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">);</span>
        
        <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">lc</span> <span class="o">=</span> 
            <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> 
               <span class="k">if</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
                   <span class="k">return</span> <span class="n">s1</span><span class="o">;</span>
               <span class="k">else</span> 
                   <span class="k">return</span> <span class="n">s2</span><span class="o">;</span>                   
            <span class="o">};</span>
        
        <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                      <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">lc</span><span class="o">);</span> <span class="c1">// 스트림이 빈 경우 빈 문자열 반환</span>
      
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span> <span class="c1">// Complex</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>reduce 메소드는 스트림이 빈 경우에 첫 번째 인자로 전달된 값을 반환한다.</p>
<h3 id="allmatch-anymatch-nonematch">allMatch, anyMatch, noneMatch</h3>
<p>스트림의 요소에 대해 지정된 조건에 모든 요소가 일치하는 지, 일부가 일치하는지,<br />
아니면 어떤 요소도 일치하지 않는지 확인하는데 사용할 수 있다.</p>

<h4 id="메소드-7">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">allMatch</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span>

<span class="kt">boolean</span> <span class="nf">anyMatch</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span>

<span class="kt">boolean</span> <span class="nf">noneMatch</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span>
</code></pre></div></div>
<ul>
  <li>allMatch : 스트림의 데이터가 조건을 모두 만족하는가?</li>
  <li>anyMatch : 스트림의 데이터가 조건을 하나라도 만족하는가?</li>
  <li>noneMatch : 스트림의 데이터가 조건을 하나도 만족하지 않는가?
    <h3 id="findany-findfirst">findAny, findFirst</h3>
    <p><code class="highlighter-rouge">filter()</code>와 함께 쓰여서 조건에 맞는 스트림의 요소가 있는지 확인하는데 사용된다.<br />
둘의 반환 타입은 <code class="highlighter-rouge">Optionsnal&lt;T&gt;</code>이며, 스트림의 요소가 없을 때 빈 Optional 객체를 반환한다.</p>
  </li>
</ul>

<h4 id="example-4">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">student</span><span class="o">.</span><span class="na">filer</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getTotalScore</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">).</span><span class="na">findFirst</span><span class="o">();</span>
</code></pre></div></div>
<h3 id="collect">collect</h3>
<p>파이프라인을 통해서 가공되고 걸러진 데이터를 최종 연산 과정에서 별도로 저장이 필요할 때 사용한다.</p>
<h4 id="메소드-8">메소드</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Stream&lt;T&gt;의 메소드</span>
<span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span> 
				<span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">,</span>
                <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">combiner</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="example-5">Example</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CollectStringStream</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"Box"</span><span class="o">,</span> <span class="s">"Robot"</span><span class="o">,</span> <span class="s">"Toy"</span><span class="o">};</span>
        <span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">words</span><span class="o">);</span>
        
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">)</span>
                          <span class="o">.</span><span class="na">collect</span><span class="o">(</span>
                              <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(),</span>
                              <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">),</span>
                              <span class="o">(</span><span class="n">lst1</span><span class="o">,</span> <span class="n">lst2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">lst1</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">lst2</span><span class="o">));</span>
    
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ls</span><span class="o">);</span> <span class="c1">// [Box, Toy]</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>첫 번째 매개변수인 람다식을 기반으로 데이터를 저장할 저장소를 생성한다.<br />
두 번째 매개변수인 람다식에서의 첫 번째 매개변수(c)는 
collect의 첫번째 인자를 통해서 생성된 컬렉션 인스턴스이며,<br />
두 번째 매개변수(s)는 스트림을 이루는 데이터 이다.<br />
세 번째 매개변수인 람다식은 병렬 스트림이 아닌 순차 스트림일 경우 사용되지 않는다.</p>

<h2 id="collect-1">collect()</h2>
<p>스트림의 요소를 수집하는 최종 연산으로 <code class="highlighter-rouge">reduce()</code>와 유사하다.<br />
collect()가 스트림의 요소를 수집하려면, 어떻게 수집할 것인가에 대한 방법이 정의되어<br />
있어야 하는데, 이 방법을 정의한 것이 컬렉터이다.</p>

<h3 id="컬렉터">컬렉터</h3>
<p>컬렉터는 <code class="highlighter-rouge">Collector</code> 인터페이스를 구현한 것으로, 직접 구현할 수도 있고 미리 작성된 것을 사용할 수도 있다.<br />
다양한 static 메서드를 가지고 있다.</p>

<ul>
  <li>collect() : 스트림의 최종연산, 매개변수로 컬렉터를 필요로 한다.</li>
  <li>Collector : 인터페이스. 컬렉터는 이 인터페이스를 구현해야한다.</li>
  <li>Collectors : 클래스. static 메서드로 미리 작성된 컬렉터를 제공한다.</li>
</ul>

<p>Collector는 인터페이스이기 때문에 직접 구현해서 컬렉터를 만들어야 한다.</p>

<h3 id="collect-2">collect()</h3>
<p><code class="highlighter-rouge">collect()</code>는 매개변수 타입이 Collector인데, 매개변수가 Collector를 구현한 클래스의 객체여야 한다.<br />
<code class="highlighter-rouge">collect()</code>는 이 객체에 구현된 방법대로 스트림의 요소를 수집한다.<br />
<em>sort()할 때 Comparator가 필요한 것처럼 colllect()할 때는 Collector가 필요하다.</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Object</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Collector</span> <span class="n">collector</span><span class="o">)</span> 
</code></pre></div></div>

<h3 id="스트림을-컬렉션과-배열로-반환">스트림을 컬렉션과 배열로 반환</h3>
<ul>
  <li><code class="highlighter-rouge">toList()</code>, <code class="highlighter-rouge">toSet()</code>, <code class="highlighter-rouge">toMap()</code>, <code class="highlighter-rouge">toCollection()</code>, <code class="highlighter-rouge">toArray()</code></li>
</ul>

<p>스트림의 모든 요소를 컬렉션에 수집하려면, Collectors 클래스의 <code class="highlighter-rouge">toList()</code>와 같은 메서드를 사용하면 된다.<br />
특정 컬렉션을 지정하려면 <code class="highlighter-rouge">toCollection()</code>에 해당하는 컬렉션의 
생성자 참조를 매개변수로 넣어주면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toCollection</span><span class="o">(</span><span class="n">toCollection</span><span class="o">(</span><span class="nl">ArrayList:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
</code></pre></div></div>

<p>Map은 키와 값의 쌍으로 저장해야하니 객체의 어떤 필드를 키로 사용할지와 값으로 사용할지를 지정해줘야 한다.<br />
아래 예제는 스트림에서 사람의 주민번호를 키로 하고, 값으로 Person 객체를 그대로 저장한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Person</span><span class="o">&gt;</span> <span class="n">map</span>  <span class="o">=</span> <span class="n">personStream</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toMap</span><span class="o">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">.</span><span class="na">getRegId</span><span class="o">(),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">));</span>
</code></pre></div></div>

<h2 id="참고-자료">참고 자료</h2>
<ul>
  <li>자바의 정석</li>
  <li>윤성우의 열혈 자바 프로그래밍</li>
</ul>

<hr />
<p>자주 사용하던 스트림을 정리하니까 각 메소드의 사용 목적이 명확해졌다 🙃<br />
또 Collector와 Collectors는 뭐가 다른지 궁금했는데 정리되었다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📖 Exception에 대하여</title>
	  <link>//Exception%E1%84%8B%E1%85%A6-%E1%84%83%E1%85%A2%E1%84%92%E1%85%A1%E1%84%8B%E1%85%A7</link>
	  <author></author>
	  <pubDate>2021-02-24T19:18:00+09:00</pubDate>
	  <guid>//Exception%E1%84%8B%E1%85%A6-%E1%84%83%E1%85%A2%E1%84%92%E1%85%A1%E1%84%8B%E1%85%A7</guid>
	  <description><![CDATA[
	     <p>오늘 수업 시간에 자바의 Exception에 대해 배웠다.<br />
수업을 듣고 들은 내용을 자바의 정석의 예외 처리를 함께 보면서 정리 ✍️</p>

<h2 id="프로그램-오류-종류">프로그램 오류 종류</h2>
<ul>
  <li>컴파일 에러 - 컴파일 시에 발생하는 에러</li>
  <li>런타임 에러 - 실행 시에 발생하는 에러</li>
  <li>논리적 에러 - 실행은 되지만, 의도와 다르게 동작하는 것</li>
</ul>

<p>프로그램에서 실행 도중 발생할 수 있는 모든 경우의 수를 고려해 이에 대한 적절한 대비가 필요하다!</p>

<h3 id="error와-exception의-차이">Error와 Exception의 차이?</h3>
<h4 id="error">Error</h4>
<p>애플리케이션이 정상적으로 동작하는데 심각한 문제가 있는 경우 사용한다.<br />
ex) 메모리 부족이나 스택오버플로우 등</p>

<p>개발자가 Error를 사용하는 일은 거의 없다고 한다.</p>

<h4 id="exception">Exception</h4>
<p>비즈니스 로직 상에서 에러가 발생하는 경우 사용한다. <br />
발생하더라도 수습이 가능하여 프로그래머가 이에 대한 적절한 처리를 할 수 있다.</p>

<h2 id="예외-클래스-계층-구조">예외 클래스 계층 구조</h2>
<p><img src="https://images.velog.io/images/new_wisdom/post/b3233d4f-d9e9-4c54-991b-5a0d24430cfb/pngwing.com.png" style="zoom:67%;" /></p>

<p>모두 Throwable을 상속하고 있으며, 여기서부터 Error와 Exception이 발생한다.<br />
여기서 모든 예외의 조상은 Exception 클래스이다.</p>

<p>또 예외 클래스들은 두 개의 그룹으로 나뉘어 질 수 있다.</p>
<ul>
  <li>RuntimeException 클래스와 그 자손 클래스들</li>
  <li>Exception 클래스와 그 자손 클래스들</li>
</ul>

<p>이 글에서는 RuntimeException 클래스와 그 자손 클래스들을 <strong>Checked Exception</strong>이라 하고,<br />
Exception 클래스와 그 자손 클래스들을 <strong>Unchecked Exception</strong>이라고 하겠다.</p>

<h3 id="checked-exception">Checked Exception</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">lotto.view.ErrorView</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomException</span> <span class="kd">extends</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">CustomException</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ErrorView</span><span class="o">.</span><span class="na">printErrorMessage</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<p>…</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">CustomException</span> <span class="o">{</span>
        <span class="n">LottoNumber</span> <span class="n">lottoNumber</span> <span class="o">=</span> <span class="n">LottoNumber</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Exception을 상속받아 사용하는 경우 컴파일 시점에 Exception을 확인할 수 있다. <br />
만약 컴파일 시점에 Exception에 대한 처리(try/catch)를 하지 않을 경우 컴파일 에러가 발생한다.<br />
Exception이 발생하는 메소드에서 throws 예약어를 활용해<br />
Exception을 호출 메소드에 전달해야 한다.</p>

<p>상위 메서드로 throw를 던지는 행위는 상위 메서드들의 책임이 그만큼 증가하기 때문에,<br />
그리 좋은 방법 같지는 않다.</p>

<h3 id="unchecked-exception">Unchecked Exception</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IllegalLottoNumberException</span> <span class="kd">extends</span> <span class="n">IllegalArgumentException</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IllegalLottoNumberException</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ErrorView</span><span class="o">.</span><span class="na">printIllegalLottoNumberMessage</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>…</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">LottoNumber</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MIN_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">45</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Pattern</span> <span class="n">NUMBER_PATTERN</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"^[0-9]*$"</span><span class="o">);</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LottoNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">validateLottoNumber</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">validateLottoNumber</span><span class="o">(</span><span class="n">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isBlank</span><span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">||</span> <span class="n">isInvalidNumberFormat</span><span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">||</span> <span class="n">isInvalidLottoNumberRange</span><span class="o">(</span><span class="n">number</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalLottoNumberException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>Runtime Time Exception 이라고 한다.<br />
컴파일 시점에 Exception이 발생할 것인지의 여부를 판단할 수 없다.<br />
Exception이 발생하는 메소드에서 throws 예약어를 활용해 Exception을 처리할 필요가 없지만, 처리해도 무방하다.</p>

<h3 id="checked-exception-vs-unchecked-exception">Checked Exception VS Unchecked Exception</h3>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>Checked Exception</th>
      <th>Unchecked Exception</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>확인 시점</td>
      <td>컴파일타임</td>
      <td>런타임</td>
    </tr>
    <tr>
      <td>처리</td>
      <td>반드시 예외 처리해야 한다.</td>
      <td>throws를 통해 그냥 던져도, 처리해도 상관 없다.</td>
    </tr>
    <tr>
      <td>대표 예외</td>
      <td>IOException, SQLException</td>
      <td>IllegalArgumentException, NullPointEception</td>
    </tr>
  </tbody>
</table>

<p>너무 치명적이면 Checked 쓰고,<br />
굳이 경고가 필요없고, 서비스 코드를 만드는 입장이라면 최상단에서 <br />
에러를 핸들링 할 수 있으니 Unchecked를 쓰는게 좋다.</p>

<p>참고로 코틀린에서는 Checked Exception은 코드만 늘어날 뿐이라 생각(?)해서 <br />
여러가지 이유로… Checked Exception이 없다고 한다.<br />
또 프로그래머 입장에서 메인과 같은 중앙에서 핸들링하는 녀석을 만들어 관리하는데,<br />
굳이 우리가 Checked Exception을 제공할 필요가 있냐는 말이다.</p>

<p>수업시간에 다양한 말들로 둘을 구분지어 보았는데,<br />
**Checked Exception는 **</p>

<ul>
  <li>내부 구현이 어떻게 되는지 알려주고 싶어!</li>
  <li>내가 집 수리할건데 손 다칠수도 있으니까 구급차 미리 불러!</li>
  <li>너 진짜 조심해야해!</li>
</ul>

<p>**Unchecked Exception는 **</p>
<ul>
  <li>내부에서 예외에 대한 방어가 있는데 클라이언트한테 공개는 안할거야, 대신 값을 잘 넣어주면 좋겠어.</li>
  <li>내가 집 수리할건데 아냐 다치지 않고 잘 할 수 있어!</li>
  <li>클라이언트가 입력할 값을 잘 알고 있겠지 ~</li>
</ul>

<p>이런 느낌으로 이야기가 나왔다.<br />
Checked인지 Unchecked인지는 <strong>클라이언트에게 얼마나 책임을 떠넘기느냐</strong>에 대한 관점으로 봐도 좋을 것 같다.</p>

<h2 id="예외-처리---try-catch문">예외 처리 - try-catch문</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="c1">// 예외 발생 가능성 있는 문장들</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception1</span> <span class="n">e1</span><span class="o">){</span>
    <span class="c1">// Exception1이 발생했을 경우, 처리하는 문장</span>
<span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception2</span> <span class="n">e2</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Exception2가 발생했을 경우, 처리하는 문장</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이렇게 하나의 try 블럭 다음에는 여러 종류의 예외를 처리할 수 있도록<br />
하나 이상의 catch 블럭이 올 수 있다.</p>

<h4 id="흐름">흐름</h4>
<p>try 블럭에서 예외가 발생하면, 예외가 발생한 위치 이후에 있는 <br />
try 블럭의 문장들은 수행되지 않는다.<br />
때문에 try 블럭에 포함시킬 코드의 범위를 잘 선택해야 한다.</p>

<p>예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 만들어진다.<br />
try블럭에서 예외가 발생되고, 첫 catch 문부터 차례대로 catch 블럭의<br />
괄호 내 선언된 참조변수의 종류와 생성된 예외 클래스의 인스턴스에 <code class="highlighter-rouge">instanceof</code>연산자를 이용해 검사한다.<br />
검사한 결과가 true인 블럭을 만날 때 까지 계속 검사한다.</p>

<h4 id="try에서-발생한-예외의-종류와-일치하는-단-하나의-catch-블럭만-수행된다">try에서 발생한 예외의 종류와 일치하는 단 하나의 catch 블럭만 수행된다.</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">number</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">LottoNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">LottoNumber</span> <span class="nf">from</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">CustomException</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">CustomException</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>다음과 같이 LottoNumber 객체를 <code class="highlighter-rouge">from()</code>으로 생성했을 때 <br />
<code class="highlighter-rouge">Exception</code>을 상속받고 있는 <code class="highlighter-rouge">CustomException</code>을 발생시킨다고 해보자.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/daa06d54-027d-44b4-aa16-4c4d985f3e72/image.png" style="zoom:50%;" /></p>

<p>인텔리제이에서도 알 수 있듯이 <code class="highlighter-rouge">CustomException</code>의 상위 클래스인 <br />
<code class="highlighter-rouge">Exception</code>을 미리 catch해주었기 때문에 하위 catch에서 <br />
<code class="highlighter-rouge">CustomException</code>를 잡는 것은 소용이 없다.</p>

<p>모든 예외 클래스는 Exception 클래스의 자손이므로, <br />
Exception 클래스 타입의 참조변수를 선언하면 해당 블럭에서 어떤 예외던지 처리된다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/aae681e5-9d55-4e86-99fe-da67d1cf9492/image.png" style="zoom:50%;" /></p>

<p>또 위와 같은 코드를 실행시켜보면 아래와 같은 출력 결과가 나온다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/20c67935-d673-4440-beb6-a943faf7d55d/image.png" style="zoom:50%;" /></p>

<p><strong>멀티 catch 블럭</strong><br />
JDK1.7부터 catch 블럭을 <code class="highlighter-rouge">|</code>을 이용해 하나의 catch 쁠럭으로 합칠 수 있게 되었다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/0ae3a6dd-c32e-47ff-8d0c-9788613a410e/image.png" style="zoom:50%;" /></p>

<p>하지만 이렇게 부모 자식 관계가 있다면 컴파일 에러가 발생한다.</p>

<h4 id="중첩된-try-catch">중첩된 try-catch</h4>
<p><img src="https://images.velog.io/images/new_wisdom/post/720fe0b3-6297-4a8e-85cb-4ad644451cd7/image.png" style="zoom:50%;" /></p>

<p>하나의 메서드 안에 여러개의 try-catch를 사용할 수 있으며,<br />
중첩으로도 사용이 가능하다.<br />
하지만 catch블럭 괄호 내 참조 변수는 catch 블럭 내에서 유효한데,<br />
위의 예제에서는 <code class="highlighter-rouge">e</code>의 참조변수의 영역이 서로 겹치기 때문에 컴파일 에러가 난다.</p>

<h2 id="custom-exception">Custom Exception</h2>
<p>기존에 정의된 예외 클래스 외에 필요에 따라 사용자 정의 클래스를 정의하여 사용할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyException</span> <span class="kd">extends</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">MyException</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span> 
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>생성시 string을 인자로 받아서 메시지로 저장할 수 있다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📖 배열의 깊은 복사와 얕은 복사</title>
	  <link>//%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%8B%E1%85%B4-%E1%84%80%E1%85%B5%E1%87%81%E1%84%8B%E1%85%B3%E1%86%AB-%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AA-%E1%84%8B%E1%85%A3%E1%87%80%E1%84%8B%E1%85%B3%E1%86%AB-%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A1</link>
	  <author></author>
	  <pubDate>2021-02-04T19:18:00+09:00</pubDate>
	  <guid>//%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%8B%E1%85%B4-%E1%84%80%E1%85%B5%E1%87%81%E1%84%8B%E1%85%B3%E1%86%AB-%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AA-%E1%84%8B%E1%85%A3%E1%87%80%E1%84%8B%E1%85%B3%E1%86%AB-%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A1</guid>
	  <description><![CDATA[
	     <h2 id="자바에서의-객체-복사">자바에서의 객체 복사</h2>
<p>자마에서 객체를 복사하는 유형에는 얕은 복사와 깊은 복사가 있다.</p>

<h3 id="얕은-복사">얕은 복사</h3>
<p>단순히 객체의 주소 값만을 복사하는 것이다.  <br />
때문에 실제로는 하나의 주소 값만을 가지고 서로 간의 값은 바뀌지 않는다. <br />
대부분 객체를 복사한다는 말은 얕은 복사가 아닌 깊은 복사를 의미한다.  <br />
<strong>Example</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Array_Shallow_Copy</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>  <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="n">arr2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">=</code>  연산자는 <code class="highlighter-rouge">주소를 이어줌</code>을 의미하는데,  <br />
위 예제는 a의 배열을 b배열로 <code class="highlighter-rouge">=</code> 연산자를 활용하여 대입했기 때문에 얕은 복사가 된다. <br />
즉 같은 주소값을 가진다. (참조에 의한 복사) <br />
때문에 arr2의 값을 수정하면 arr1의 값도 같이 수정된다.</p>

<h3 id="깊은-복사">깊은 복사</h3>
<p>객체의 실제 값을 새로운 객체로 복사한다.  <br />
복사된 배열이나 원본 배열이 변경될 때 서로 간의 값은 바뀌지 않는다.</p>

<p>자바에서는 배열을 깊은 복사할 수 있는 여러가지 메서드를 제공하고 있다.</p>

<h4 id="obejctclone">Obejct.clone()</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Array_Copy_Clone</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>  <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>가장 보편적인 방법으로 깊은 복사를 할 때 사용된다.</p>

<p>But. 객체 배열의 경우 <code class="highlighter-rouge">clone()</code>을 사용하면 깊은 복사가 되지 않는다! <br />
그 이유는 객체는 주소값을 가지고 있기 때문이다. (일반 자료형의 배열만 깊은 복사가 가능하다) <br />
마찬가지로 2차원 배열의 경우도 각각의 row에 대한 주소값이 존재하기 때문에 깊은 복사가 되지 않는다.</p>

<p>또 해당 메소드는 객체의 클로닝을 위한 메소드인데 <br />
추가로 <a href="https://javacan.tistory.com/entry/31">객체 클로닝에 관하여</a> 글을 읽어보면 좋다.</p>

<h3 id="systemarraycopy">System.arraycopy()</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Array_Copy_ArrayCopy</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>  <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span> <span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">System.arraycopy(src, srcPos, dest, destPos, a.length);</code> 형식으로 사용한다.</p>

<h3 id="일차원-객체-배열-복사하기">일차원 객체 배열 복사하기</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">Pos</span><span class="o">[]</span> <span class="nf">deepCopy</span><span class="o">(</span><span class="n">Pos</span><span class="o">[]</span> <span class="n">src</span><span class="o">){</span>
	<span class="k">if</span><span class="o">(</span><span class="n">src</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">Pos</span><span class="o">[]</span> <span class="n">dest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Pos</span><span class="o">[</span><span class="n">src</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">src</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    	<span class="n">src</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Pos</span><span class="o">(</span><span class="n">src</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">a</span><span class="o">,</span> <span class="n">src</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">b</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dest</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">for</code> 문을 돌 때마다 새로운 객체를 생성하여 직접 값을 넣어준다. <br />
그래야 새로운 객체를 담은 다른 배열로 깊은 복사된 배열을 가질 수 있다.</p>

<h3 id="참고-자료">참고 자료</h3>
<ul>
  <li><a href="https://coding-factory.tistory.com/548">[Java] 자바 배열을 복사하는 다양한 방법 (깊은복사, 얕은복사)</a></li>
  <li><a href="https://hoho325.tistory.com/89">자바(java) 배열의 깊은 복사(deep copy)와 얕은 복사 완벽정리(1차원 배열, 2차원 배열, 객체 배열 복사)</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>📚 머리에 박제할라고 진짜 간단히 정리한 일급 컬렉션</title>
	  <link>//%E1%84%86%E1%85%A5%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A6-%E1%84%87%E1%85%A1%E1%86%A8%E1%84%8C%E1%85%A6%E1%84%92%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%80%E1%85%A9-%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%8D%E1%85%A1-%E1%84%80%E1%85%A1%E1%86%AB%E1%84%83%E1%85%A1%E1%86%AB%E1%84%92%E1%85%B5-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B3%E1%86%B8-%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB</link>
	  <author></author>
	  <pubDate>2021-02-04T19:18:00+09:00</pubDate>
	  <guid>//%E1%84%86%E1%85%A5%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A6-%E1%84%87%E1%85%A1%E1%86%A8%E1%84%8C%E1%85%A6%E1%84%92%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%80%E1%85%A9-%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%8D%E1%85%A1-%E1%84%80%E1%85%A1%E1%86%AB%E1%84%83%E1%85%A1%E1%86%AB%E1%84%92%E1%85%B5-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B3%E1%86%B8-%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB</guid>
	  <description><![CDATA[
	     <h3 id="일급-컬렉션">일급 컬렉션</h3>
<p>일급 컬렉션의 개념을 좀 더 정확히 짚고 넘어가야 할 것 같았다.<br />
1차 리뷰어님께서 첨부해 주신 글을 저번에도 읽어보았으나<br />
그 때까지는 이 글의 모든 개념을 파악하기 어려웠다.<br />
때문에 훌라당 읽고 넘어갔지만 🥲<br />
이번에 정독해보니 머릿 속에 개념과 목적이 좀 더 명확하게 잡혔다.</p>

<p>내 머릿 속에 박을라고 내가 이해한대로 진짜 간단하게 정리하는 글 ✍️</p>
<h3 id="참고-자료">참고 자료</h3>
<p><a href="https://jojoldu.tistory.com/412">일급 컬렉션 (First Class Collection)의 소개와 써야할 이유</a></p>

<h4 id="일급-컬렉션-1">일급 컬렉션?</h4>
<p>다른 멤버 변수가 없이 오로지 콜렉션만 포함한 객체.<br />
한마디로 Collection을 클래스로 Wrapping 한 것이다.</p>

<h4 id="비즈니스에-종속적인-자료구조">비즈니스에 종속적인 자료구조</h4>
<p>collection의 값을 비즈니스 로직이 서비스 메소드에 들어가 있을 때 <br />
값을 검증하는 메소드도 이 서비스 메소드에 들어가게 될 것이다.<br />
만약 변경이 일어난다면 모든 코드와 도메인을 알고 있어야하므로 언제든지<br />
문제의 발생 여지가 있는 로직이 되어버린다.<br />
이는 객체지향 설계에 어긋난다.<br />
해당 조건으로만 생성 할 수 있는 자료구조인 일급 컬렉션을 사용한다.</p>

<h4 id="불변-보장">불변 보장</h4>
<p><code class="highlighter-rouge">final</code> 예약어를 사용하라.<br />
이는 불변을 금지하는 것이 아닌 재할당을 금지한다.</p>

<h4 id="상태와-행위를-한곳에서-관리">상태와 행위를 한곳에서 관리</h4>
<p>컬렉션 내의 어떤 상태별로 메소드를 실행하고 싶다 가정할 때 <br />
로직이 밖으로 분리되어 있다면 상태에 따라 지정된 메소드 실행이 어렵다.</p>

<h4 id="이름이-있는-컬렉션">이름이 있는 컬렉션</h4>
<p>컬렉션에 이름을 붙일 수 있어 검색이 어렵고 명확한 표현이 불가능한 문제를 해결한다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>👀 인텔리제이를 인텔리제이답게 - Mac 단축키</title>
	  <link>//%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%83%E1%85%A1%E1%86%B8%E1%84%80%E1%85%A6-Mac-%E1%84%83%E1%85%A1%E1%86%AB%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%8F%E1%85%B5</link>
	  <author></author>
	  <pubDate>2021-02-04T19:18:00+09:00</pubDate>
	  <guid>//%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8C%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%83%E1%85%A1%E1%86%B8%E1%84%80%E1%85%A6-Mac-%E1%84%83%E1%85%A1%E1%86%AB%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%8F%E1%85%B5</guid>
	  <description><![CDATA[
	     <p>사실 인텔리제이를 쓰면서 사람들이 왜 인텔리제이가 편하다고 하는 걸까 의문이었다.<br />
하지만 우테코를 진행하면서 몇 가지 단축키를 배우니 굉장히 유용한 것 . . .<br />
인텔리 제이에서 제공하는 영문 Key Map Reference를 정리하면서 <br />
나도 내게 유용한 기능들을 익혀보려 한다.</p>

<p><em>앞으로 쓰면서 계속 추가 예정 ✍️</em></p>
<blockquote>
  <p>참고로 Key Map Reference는 인텔리제이의 <code class="highlighter-rouge">Help &gt; Key Map Reference</code> 에 있다.</p>
</blockquote>

<h3 id="editing">Editing</h3>

<table>
  <thead>
    <tr>
      <th>단축키</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>^Space</td>
      <td>기본 자동 완성</td>
    </tr>
    <tr>
      <td>^⇧Space</td>
      <td>스마트 자동 완성</td>
    </tr>
    <tr>
      <td>⌘⇧Enter</td>
      <td>static 메소드 자동완성</td>
    </tr>
    <tr>
      <td>⌘P</td>
      <td>파라미터 정보</td>
    </tr>
    <tr>
      <td>F1</td>
      <td>Doc 간략 보기</td>
    </tr>
    <tr>
      <td>⌘N</td>
      <td>Getters, Setters, Constructors, hashCode/equals, toString 자동완성</td>
    </tr>
    <tr>
      <td>^O</td>
      <td>메소드 오버라이드</td>
    </tr>
    <tr>
      <td>^I</td>
      <td>Override 메서드 자동완성 (Implement Methods)</td>
    </tr>
    <tr>
      <td>⌘⌥T</td>
      <td>if..else, try..catch, for, synchronized, 등으로 감싸기</td>
    </tr>
    <tr>
      <td>⌘/</td>
      <td>한줄 주석</td>
    </tr>
    <tr>
      <td>⌘⌥/</td>
      <td>블럭 주석</td>
    </tr>
    <tr>
      <td>⌥↑</td>
      <td>코드 블록 연속 증가 선택</td>
    </tr>
    <tr>
      <td>⌥↓</td>
      <td>코드 블록 연속 감소 선택</td>
    </tr>
    <tr>
      <td>^⇧Q</td>
      <td>문맥 정보 (클래스명)</td>
    </tr>
    <tr>
      <td>⌥Enter</td>
      <td>의도하는 작업 표시 및 빠른 수정</td>
    </tr>
    <tr>
      <td>⌘⌥L</td>
      <td>코드 리포맷</td>
    </tr>
    <tr>
      <td>^⌥O</td>
      <td>import 문 최적화</td>
    </tr>
    <tr>
      <td>⌘⌥I</td>
      <td>자동 인덴트</td>
    </tr>
    <tr>
      <td>⌘⇧V</td>
      <td>버퍼에서 붙여넣기</td>
    </tr>
    <tr>
      <td>⌘D</td>
      <td>현재 라인 복제</td>
    </tr>
    <tr>
      <td>⌘Delete</td>
      <td>현재 라인 삭제</td>
    </tr>
    <tr>
      <td>^⇧J</td>
      <td>스마트 라인 합치기</td>
    </tr>
    <tr>
      <td>⇧⌘← / ⇧⌘→</td>
      <td>토글 기준으로 왼, 오 선택</td>
    </tr>
    <tr>
      <td>⌥Delete</td>
      <td>단어 삭제</td>
    </tr>
  </tbody>
</table>

<h3 id="navigation">Navigation</h3>

<table>
  <thead>
    <tr>
      <th>단축키</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⌘O</td>
      <td>클래스로 이동</td>
    </tr>
    <tr>
      <td>⌘⇧O</td>
      <td>파일로 이동</td>
    </tr>
    <tr>
      <td>⌘⌥O</td>
      <td>심볼로 이동</td>
    </tr>
    <tr>
      <td>^⇧F4</td>
      <td>run/messages/find/… tab 닫기</td>
    </tr>
    <tr>
      <td>⌘⌥← / ⌘⌥→</td>
      <td>전, 후에 있던 위치로 이동</td>
    </tr>
    <tr>
      <td>⌘⇧Delete</td>
      <td>최근 수정 위치로 이동</td>
    </tr>
    <tr>
      <td>⌘B</td>
      <td>선언으로 이동</td>
    </tr>
    <tr>
      <td>⌘⌥B</td>
      <td>구현으로 이동</td>
    </tr>
    <tr>
      <td>⌘U</td>
      <td>부모 메소드나 클래스로 이동</td>
    </tr>
    <tr>
      <td>^H</td>
      <td>Type hierarchy</td>
    </tr>
    <tr>
      <td>⌘⇧H</td>
      <td>Method hierarchy</td>
    </tr>
    <tr>
      <td>^⌥ㅗ</td>
      <td>hierarchy 호출</td>
    </tr>
    <tr>
      <td>⌘↑</td>
      <td>네비게이션 바 보이기</td>
    </tr>
    <tr>
      <td>F3</td>
      <td>북마크</td>
    </tr>
    <tr>
      <td>⌥F3</td>
      <td>멘션과 함께 북마크</td>
    </tr>
    <tr>
      <td>⌘F3</td>
      <td>북마크 보이기</td>
    </tr>
  </tbody>
</table>

<h3 id="searchreplace">Search/Replace</h3>

<table>
  <thead>
    <tr>
      <th>단축키</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⇧⇧</td>
      <td>전체 검색</td>
    </tr>
    <tr>
      <td>⌘F</td>
      <td>찾기</td>
    </tr>
    <tr>
      <td>⌘G</td>
      <td>다음 찾기</td>
    </tr>
    <tr>
      <td>⌘⇧G</td>
      <td>이전 찾기</td>
    </tr>
    <tr>
      <td>⌘R</td>
      <td>대체</td>
    </tr>
    <tr>
      <td>⌘⇧F</td>
      <td>path 찾기</td>
    </tr>
    <tr>
      <td>⌘⇧R</td>
      <td>path에서 교체</td>
    </tr>
  </tbody>
</table>

<h3 id="live-templates">Live Templates</h3>

<table>
  <thead>
    <tr>
      <th>단축키</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⌘⌥J</td>
      <td>Live Template로 감싸기</td>
    </tr>
    <tr>
      <td>⌘J</td>
      <td>Live Template 추가</td>
    </tr>
  </tbody>
</table>

<h3 id="vcs">VCS</h3>

<table>
  <thead>
    <tr>
      <th>단축키</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⌥⇧C</td>
      <td>최근 change 보기</td>
    </tr>
    <tr>
      <td>^V</td>
      <td>빠른 VSC 팝업 띄우기</td>
    </tr>
  </tbody>
</table>

<h3 id="refactoring">Refactoring</h3>

<table>
  <thead>
    <tr>
      <th>단축키</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>F5</td>
      <td>Copy</td>
    </tr>
    <tr>
      <td>F6</td>
      <td>Move</td>
    </tr>
    <tr>
      <td>⌘Delete</td>
      <td>Safe Delete</td>
    </tr>
    <tr>
      <td>⇧F6</td>
      <td>이름 변경</td>
    </tr>
    <tr>
      <td>⌘F6</td>
      <td>시그니쳐 변경</td>
    </tr>
    <tr>
      <td>⌘⌥N</td>
      <td>Inline</td>
    </tr>
    <tr>
      <td>⌘⌥M</td>
      <td>메소드 추출</td>
    </tr>
    <tr>
      <td>⌘⌥V</td>
      <td>변수 추출</td>
    </tr>
    <tr>
      <td>⌘⌥F</td>
      <td>필드 추출</td>
    </tr>
    <tr>
      <td>⌘⌥C</td>
      <td>상수 추출</td>
    </tr>
    <tr>
      <td>⌘⌥P</td>
      <td>파라미터 추출</td>
    </tr>
  </tbody>
</table>

<h3 id="compile-and-run">Compile and Run</h3>

<table>
  <thead>
    <tr>
      <th>단축키</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⌘F9</td>
      <td>프로젝트 생성</td>
    </tr>
    <tr>
      <td>⌘⇧F9</td>
      <td>파일, 패키지, 모듈 컴파일</td>
    </tr>
    <tr>
      <td>^⌥R</td>
      <td>configuration 선택하고 실행</td>
    </tr>
    <tr>
      <td>^⌥D</td>
      <td>configuration 선택하고 디버깅</td>
    </tr>
    <tr>
      <td>^R</td>
      <td>실행</td>
    </tr>
    <tr>
      <td>^D</td>
      <td>디버깅</td>
    </tr>
  </tbody>
</table>

<h3 id="general">General</h3>

<table>
  <thead>
    <tr>
      <th>단축키</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⌘0 … ⌘9</td>
      <td>해당하는 윈도우 열기</td>
    </tr>
    <tr>
      <td>⌥⇧F</td>
      <td>즐겨찾기 등록</td>
    </tr>
  </tbody>
</table>

	  ]]></description>
	</item>


</channel>
</rss>
