<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>NewWisdom.github.io/</title>
   
   <link>http://localhost:4000</link>
   <description>블로그 이사중... 아직 정리가 안되었음...</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>📌 SpringBoot Auto Configuration</title>
	  <link>//springconfiguration</link>
	  <author></author>
	  <pubDate>2021-05-27T19:18:00+09:00</pubDate>
	  <guid>//springconfiguration</guid>
	  <description><![CDATA[
	     <h2 id="테코톡을-보고-추가로-학습한-내용들">테코톡을 보고 추가로 학습한 내용들</h2>

<p>스프링 부트는 component-scan을 통해 component를 찾고 bean을 생성한다.<br />
이 과정에서 우리가 설정한 bean들이 생성된다.<br />
그리고 이 과정에서 spring boot의 auto configuration에 의해 추가적인 bean들도 함께 생성된다.</p>

<h3 id="spring-boot-autoconfiguration이란">Spring Boot AutoConfiguration이란?</h3>

<ul>
  <li>클래스 패스에 존재하는 dependecy를 기반으로 spring 애플리케이션을 자동으로 구성하는 방법</li>
  <li>스프링 부트는 web, h2, jdbc등 여러 자동 설정을 제공 (starter)</li>
  <li>특정 Bean을 정의할 필요 없기 때문에 개발이 더 빠르고 쉬워짐</li>
  <li>스프링부트에선 <code class="highlighter-rouge">@SpringBootApplication</code>에 있는 <code class="highlighter-rouge">EnableAutoConfiguration</code> 로 가능</li>
</ul>

<h3 id="springbootautoconfiguration">@SpringBootAutoConfiguration</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/024b6568-3a66-4a6f-b4c3-1eaeee3ea27d/image.png" style="zoom: 50%;" /></p>

<ul>
  <li><code class="highlighter-rouge">@SpringBootConfiguration</code> : 스프링의 <code class="highlighter-rouge">@Configuration</code>을 대체하는 스프링 부트 전용 설정 어노테이션</li>
  <li><code class="highlighter-rouge">@EnableAutoConfiguration</code> : auto configuration 기능을 사용하겠다는 설정. 클래스 패스에 지정된 내용을 기반으로 설정을 자동화. 일반적으로 <code class="highlighter-rouge">@ComponentScan</code> 와 함께 쓰임</li>
</ul>

<p><strong>그런데 우리가 정의한 Bean과 Spring Boot가 정의한 Bean이 충돌하면? 또한 불필요한 Bean들도 같이 생성된다면?</strong></p>

<p><code class="highlighter-rouge">@Condition</code>과 <code class="highlighter-rouge">@ConditionalOnXxx</code>을 이용해서 이와 같은 문제를 해결한다.</p>

<h3 id="springfactories">spring.factories</h3>

<p>위의 두 어노테이션을 살펴보기 전에 auto configuration에 필요한 파일들을 살펴보자.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/0e864065-e901-4be2-a736-ba56b5d7e8c6/image.png" style="zoom:33%;" /></p>

<h4 id="auto-configure">Auto Configure</h4>

<p><img src="https://images.velog.io/images/new_wisdom/post/06db6a39-a4bd-40f3-bb11-cbd13c55994b/image.png" style="zoom: 50%;" /></p>

<p><code class="highlighter-rouge">spring-boot-autoconfigure/META-INF/spring.factories</code> 에는 스프링 부트가 미리 정의해둔 auto configuration 정보가 들어있다.<br />
여기에는 자동 설정의 target 클래스 목록들이 나열되어 있고, 여기에 선언된 클래스들이 <code class="highlighter-rouge">@EnableConfiguration</code> 사용 시 target이 된다.</p>

<h3 id="conditional-conditionalonxxx">@Conditional? @ConditionalOnXxx?</h3>

<ul>
  <li>Sprig 4.0부터 추가된 어노테이션</li>
</ul>

<p><code class="highlighter-rouge">spring.factories</code> 에 있는 클래스들 중 익숙한 <code class="highlighter-rouge">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</code> 를 예시로 보자.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/a41c8243-04ba-424e-b466-c592dd5502b1/image.png" alt="" /></p>

<ul>
  <li><code class="highlighter-rouge">@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })</code> 설정을 통해 해당 클래스 파일이 존재해야 설정을 활성화 함을 명시</li>
  <li><code class="highlighter-rouge">@ConditionalOnMissingBean(type = "io.r2dbc.spi.ConnectionFactory")</code> 설정을 통해 해당 Bean이 존재하지 않을 경우 설정을 활성화 함을 명시</li>
</ul>

<p>이러한 설정들 덕분에 <code class="highlighter-rouge">우리가 정의한 Bean과 Spring Boot가 정의한 Bean이 충돌하는 문제, 불필요한 Bean들이 생성되는 문제 등</code>을 해결할 수 있다.</p>

<h4 id="autoconfigurationimportfilter">AutoConfigurationImportFilter</h4>

<p>그런데 사실 auto configuration에서 이 <code class="highlighter-rouge">@Condition</code> 을 무조건 타는 것이 아니다.<br />
<code class="highlighter-rouge">spring.factories</code> 에는 <code class="highlighter-rouge">AutoConfigurationImportFilter</code> 설정이 존재한다.<br />
아래와 같은 필터들은 각 AutoConfiguration이 가진 <code class="highlighter-rouge">@Conditional</code> 을 가지고 조건을 만족하는지 필터링을 수행한다.<br />
조건이 맞지 않을 경우, AutoConfiguration이 동작하지 않도록 제외시키는 역할을 한다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/6180dd11-d6e2-4e23-9146-da32cbaaba32/image.png" style="zoom: 50%;" /></p>

<ul>
  <li><strong>OnBeanCondition</strong> : 특정 bean들의 존재유무에 대해서 다루는 필터
    <ul>
      <li><code class="highlighter-rouge">@ConditionalOnBean, @ConditionalOnMissingBean, @ConditionalOnSingleCandidate</code></li>
    </ul>
  </li>
  <li><strong>OnClassCondition</strong> : 특정 class들의 존재유무에 대해서 다루는 필터
    <ul>
      <li><code class="highlighter-rouge">@ConditionalOnClass, @ConditionalOnMissingClass</code></li>
    </ul>
  </li>
  <li><strong>OnWebApplicationCondition</strong> : WebApplicationContext의 존재유무에 대해서 다루는 필터
    <ul>
      <li><code class="highlighter-rouge">@ConditionalOnWebApplication, @ConditionalOnNotWebApplication</code></li>
    </ul>
  </li>
</ul>

<p><strong>그렇다면 이 자동 설정들은 어떻게 불러와질까?</strong></p>

<h3 id="importautoconfigurationimportselectorclass">@Import(AutoConfigurationImportSelector.class)</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/024b6568-3a66-4a6f-b4c3-1eaeee3ea27d/image.png" style="zoom: 50%;" /></p>

<p><code class="highlighter-rouge">@SpringbootApplication</code> 어노테이션 내부에 있던 <code class="highlighter-rouge">@Import(AutoConfigurationImportSelector.class)</code> 는 자동 설정을 지원해주며, import하고 있는 AutoConfigurationImportSelector.class가 <code class="highlighter-rouge">META-INF/spring.factories</code> 에 정의된 자동 설정할 클래스들을 불러온다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📌 시간 복잡도</title>
	  <link>//time</link>
	  <author></author>
	  <pubDate>2021-05-26T19:18:00+09:00</pubDate>
	  <guid>//time</guid>
	  <description><![CDATA[
	     <h3 id="알고리즘이란">알고리즘이란?</h3>

<ul>
  <li>문제를 해결하기 위한 방법</li>
</ul>

<h3 id="예시">예시</h3>

<h4 id="건너뛰기-혹은-살펴보기-전략">건너뛰기 혹은 살펴보기 전략</h4>

<ul>
  <li>자취방 구하기</li>
  <li>맛있는 음식점 찾아다니기</li>
  <li>마음에 드는 옷 고르기</li>
</ul>

<h3 id="시간-복잡도">시간 복잡도</h3>

<ul>
  <li>문제를 해결하는데 걸리는 시간과 입력의 함수 관계</li>
  <li>계산법 = 핵심이 되는 연산이 무엇일까?</li>
  <li>항상 최악의 경우를 시간복잡도로 쓴다.</li>
  <li>최선의 경우는 어떤 알고리즘을 써도 만족스러운 경우가 나오기 때문에 최악의 경우를 시간복잡도로 사용</li>
</ul>

<h4 id="현실적-알고리즘">현실적 알고리즘</h4>

<ul>
  <li>Polynomial complexity (P 문제)</li>
  <li>sorting. dp</li>
</ul>

<h4 id="비현실적-알고리즘">비현실적 알고리즘</h4>

<ul>
  <li>Nondeterministic Polynomial complexity (NP 문제)</li>
  <li>소인수 분해 문제
    <ul>
      <li>ex) 21이 어떤 수들의 곱인지 구하는 것은 오래걸림</li>
      <li>q와 p의 곱을 n이라하고 이를 공개키로 둔다.</li>
    </ul>
  </li>
  <li>해밀턴 경로 문제</li>
  <li>컴퓨터로도 풀 수 없다</li>
  <li>너무 오래 걸려</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>📌 Cache</title>
	  <link>//cache</link>
	  <author></author>
	  <pubDate>2021-05-26T19:18:00+09:00</pubDate>
	  <guid>//cache</guid>
	  <description><![CDATA[
	     <h3 id="메모리-계층-구조">메모리 계층 구조</h3>

<ul>
  <li>데이터를 저장하는 공간의 속도와 용량은 반비례
    <ul>
      <li>빠를수록 가격이 올라간다.</li>
    </ul>
  </li>
  <li>용량이 큰 저장장치는 속도가 느림</li>
  <li>둘 다 잡기엔 비용이 너무 많이 듦</li>
</ul>

<h3 id="파레토의-법칙">파레토의 법칙</h3>

<ul>
  <li>원인 중 상위 20%가 전체 결과의 80%를 만든다.</li>
  <li>많이 쓰는 20%가 80%의 효율을 차지한다.</li>
</ul>

<h3 id="데이터-지역성의-원리">데이터 지역성의 원리</h3>

<ul>
  <li>자주 쓰는 데이터는 시간적 혹은 공간적으로 한 곳에 몰려있을 가능성이 높음</li>
  <li><strong>시간 지역성</strong>
    <ul>
      <li>for문에 조건 변수를 선언하면 해당 변수는 for문이 끝나기 전까지 계속 쓰일 확률이 높음</li>
    </ul>
  </li>
  <li><strong>공간 지역성</strong>
    <ul>
      <li>for문에서 어떤 배열에 접근했을 때 해당 배열이 위치한 메모리 공간의 내용은 for문이 끝나기 전까지 계속 쓰일 확률이 높음</li>
      <li>순차 지역성이라고 부르기도 함(arr[0], arr[1] 다음에는 arr[3]에 접근할 확률이 높을 것을 따로 분류하기도 함)</li>
      <li>ex) 창고의 모든 종이를 한번에 미리 책상위로 가져오면 효율이 좋다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="cache">Cache</h2>

<ul>
  <li>나중에 필요할 수 있는 무언가를 저장했다가 신속하게 회수할 수 있는 보관</li>
  <li>원본 데이터를 빠르게 저장할 수 있는 메모리에 저장한다.</li>
  <li>낮은 시간 복잡도로 접근 가능한 곳에 주로 저장한다.
    <ul>
      <li>ex) 자바의 HashMap</li>
    </ul>
  </li>
  <li>원하는 데이터가 없거나 최신성을 잃은 경우 그때서야 원본 데이터가 있는 곳에 접근해 데이터를 가져온다.
    <ul>
      <li>최신성을 잃었다는 프로그래머가 정해주는 것</li>
    </ul>
  </li>
  <li>원하는 데이터가 있으면 캐시에서 바로 해당 데이처를 제공한다. (Cache Hit)</li>
  <li>캐시 공간은 작으니 안쓰는 데이터부터 삭제한다.</li>
</ul>

<h3 id="example">Example</h3>

<h4 id="cpu">CPU</h4>

<ul>
  <li>1초에 최고 수십억번 작동 각능</li>
  <li>아무리 빠른 주기억장치라도 CPU를 따라가기 어려움</li>
  <li>그래서 SRAM이라는 특수한 메모리를 CPU에 넣어 캐시 메모리로 사용</li>
</ul>

<h4 id="하드-디스크-데이터베이스">하드 디스크, 데이터베이스</h4>

<ul>
  <li>하드디스크는 주기억장치에 비해 10만배 느림</li>
  <li>처리 효율을 올리려면 자주 쓰이는 데이터를 캐싱하는 것이 좋다.</li>
  <li>JPA의 영속성 컨텍스트</li>
</ul>

<h4 id="youtube">Youtube</h4>

<ul>
  <li>미국에 서버가 있으니 Google Global Cache를 두어 인기 동영사는 국내 서버가 처리하도록 함</li>
  <li>이처럼 세계 각지에 캐시 서버를 두는 것이 CDN</li>
</ul>

<h4 id="웹-캐시">웹 캐시</h4>

<ul>
  <li>네트워크를 통해 데이터를 가져오는 것은 하드 디스크보다 느릴 때도 많다.</li>
  <li>웹 브라우저에서는 정적 파일을 하드디스크나 메모리에 캐싱해뒀다가 다음번에 이를 재활용한다.</li>
  <li>동적 페이지 경우 매번 내용이 바뀌지 않는 경우가 더 많으므로 서버에서 생성한 HTML을 캐싱한다.</li>
  <li>클라이언트에서 자주 요청하는 내용은 웹 서버로 전달하지 않고 웹 서버 앞단 프록시 서버에서 캐싱해둔 데이터를 바로 제공한다. (프록시 캐시)</li>
</ul>

<h4 id="브라우저-캐시">브라우저 캐시</h4>

<ul>
  <li>웹 서버에서 클라이언트에 보내는 HTTP 헤더에 캐시 지시사를 삽입해 브라우저에서 이에 따른 캐싱 정책을 실시한다.</li>
  <li>캐시 유효시간 (max-age)가 지나도 캐시 데이터가 바뀌지 않은 경우를 확인하기 위해 ETag라는 유효성 검사 토큰을 사용한다.</li>
  <li>캐싱 정책은 웹페이지 전반적 상황에 따라 각 파일마다 다르게 적용되야 함
    <ul>
      <li>정적 파일과 동적 부분의 브라우저 캐싱 정책은 달라야함</li>
    </ul>
  </li>
</ul>

<h4 id="redisremote-dictionary-server">Redis(Remote Dictionary Server)</h4>

<ul>
  <li>메모리 기반 NoSQL DBMS의 일종으로 웹 서비스에서 캐싱을 위해 많이 씀</li>
  <li>Dictionary Server는 자바의 HashMap과 유사하다.</li>
  <li>기본적으로 모든 데이터를 메모리에 저장</li>
  <li>재부팅 때 메모리가 휘발되지 않게 데이터를 하드디스크에 기록할 수 있음</li>
  <li>DBMS 일종이므로 명시적 삭제하지 않는 한 메모리에서 삭제하지 않음</li>
</ul>

<h4 id="ehcache">EHcache</h4>

<ul>
  <li>자바 표준 캐싱 API 명세인 JSR-107을 따르는 오픈소스 캐시 구현체</li>
  <li>Spring 프레임워크나 Hibernate ORM 등에서 바로 사용 가능</li>
  <li>캐시 저장 공간을 속도에 따라 여러 등급으로 나누어 메모리 계층 구조 적용 가능</li>
  <li>하드디스크에 기록 가능</li>
</ul>

<hr />

<h3 id="참고자료">참고자료</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=c33ojJ7kE7M">[10분 테코톡] 🐻큰곰의 Cache</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>📋 4. 의존 자동 주입</title>
	  <link>//springbasic4</link>
	  <author></author>
	  <pubDate>2021-05-26T19:18:00+09:00</pubDate>
	  <guid>//springbasic4</guid>
	  <description><![CDATA[
	     <h2 id="autowired-어노테이션을-통한-의존-자동-주입">@Autowired 어노테이션을 통한 의존 자동 주입</h2>

<ul>
  <li>자동 주입 기능을 사용하면 스프링이 알아서 의존 객체를 찾아 주입한다.</li>
  <li>사용 방법은 의존을 주입할 대상에 <code class="highlighter-rouge">@Autowiwred</code> 어노테이션을 붙이면 된다.</li>
  <li>해당 어노테이션이 붙어있으면 스프링이 이를 찾아 필드에 할당한다.</li>
</ul>

<p>**@Autowired를 적용한 대상에 일치하는 빈이 없으면? **</p>

<p>해당 필드에 대한 의존을 충족하지 않는다는 내용과 함께 빈이 존재하지 않는다는 에러 메시지가 출력된다.</p>

<p>**만약 두개 이상이면? **</p>

<p>해당 타입의 빈이 한개가 아닌 여러개를 발견했다는 예외 메시지가 출력된다.</p>

<hr />

<h2 id="qualifier를-이용한-의존-객체-선택">@Qualifier를 이용한 의존 객체 선택</h2>

<ul>
  <li>자동 주입 가능한 빈이 두 개 이상인 경우 자동 주입을 할 빈을 지정하는 방법</li>
</ul>

<h3 id="사용-위치">사용 위치</h3>

<h4 id="bean-을-붙인-빈-설정-메서드">@Bean 을 붙인 빈 설정 메서드</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplicationContextTestResourceQualifier</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
  	<span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"defaultFile"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">File</span> <span class="nf">defaultFile</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">File</span> <span class="n">defaultFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"defaultFile.txt"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">defaultFile</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="autowired에서-자동-주입할-빈을-한정할-때-사용">@Autowired에서 자동 주입할 빈을 한정할 때 사용</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberListPrinter</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="n">MemberDao</span> <span class="n">memberDao</span><span class="o">;</span>
	<span class="kd">private</span> <span class="n">MemberPrinter</span> <span class="n">printer</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">MemberListPrinter</span><span class="o">(</span><span class="n">MemberDao</span> <span class="n">memberDao</span><span class="o">,</span> <span class="n">MemberPrinter</span> <span class="n">printer</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">memberDao</span> <span class="o">=</span> <span class="n">memberDao</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">printer</span> <span class="o">=</span> <span class="n">printer</span><span class="o">;</span>
	<span class="o">}</span>
	
  <span class="nd">@Autowired</span>
  <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"printer"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMemberPrint</span><span class="o">(</span><span class="n">MemberPrinter</span> <span class="n">printer</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">printer</span> <span class="o">=</span> <span class="n">printer</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>@Qualifier의 속성으로 주입할 빈의 후보를 한정한다.</li>
  <li>빈 설정에 해당 어노테이션이 없으면 빈의 이름을 한정자로 지정한다.</li>
</ul>

<hr />

<h2 id="상위하위-타입-관계와-자동-주입">상위/하위 타입 관계와 자동 주입</h2>

<p>MemberPrinter 클래스를 상속한 MeberSummaryPrinter 클래스가 있다고 하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberSummaryPrinter</span> <span class="kd">extends</span> <span class="n">MemberPrinter</span> <span class="o">{</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="n">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
				<span class="s">"회원 정보: 이메일=%s, 이름=%s\n"</span><span class="o">,</span> 
				<span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>그리고 AppCtx 설정에서 <code class="highlighter-rouge">memberPrinter2()</code> 가 의 빈 객체를 설정하도록 변경한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppCtx</span> <span class="o">{</span>
	<span class="c1">// ...</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberPrinter</span> <span class="nf">memberPrinter1</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberPrinter</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberSummaryPrinter</span> <span class="nf">memberPrinter2</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberSummaryPrinter</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">memberPrinter2()</code> 의 빈을 MemberSummaryPrinter으로 변경해도 빈 중복 에러가 발생한다.</li>
  <li>MemberSummaryPrinter는 MemberPrinter 타입에도 할당할 수 있기 때문이다.</li>
  <li>스프링 컨테이너는 MemberPrinter 타입 빈을 자동 주입해야하는 @Autowired를 만나면 `memberPrinter1(), memberPrinter2() 중 어떤 빈을 주입해야하는 지 알 수 없다.</li>
</ul>

<p>이 문제는 두가지 방법으로 처리할 수 있다.</p>

<p><strong>@Qualifier</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nd">@Bean</span>
	<span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"printer"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="n">MemberPrinter</span> <span class="nf">memberPrinter1</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberPrinter</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"summaryPrinter"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="n">MemberSummaryPrinter</span> <span class="nf">memberPrinter2</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberSummaryPrinter</span><span class="o">();</span>
	<span class="o">}</span>
</code></pre></div></div>

<p><strong>MemberListPrinter가 MemberSummaryPrinter를 사용하도록 (Composition)</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberListPrinter</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="n">MemberDao</span> <span class="n">memberDao</span><span class="o">;</span>
	<span class="kd">private</span> <span class="n">MemberPrinter</span> <span class="n">printer</span><span class="o">;</span>

  <span class="c1">// ...</span>
	
	<span class="nd">@Autowired</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMemberPrinter</span><span class="o">(</span><span class="n">MemberSummaryPrinter</span> <span class="n">printer</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">printer</span> <span class="o">=</span> <span class="n">printer</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="autowired의-필수-여부-지정-방법">@Autowired의 필수 여부 지정 방법</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberPrinter</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="n">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">dateTimeFormatter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
					<span class="s">"회원 정보: 아이디=%d, 이메일=%s, 이름=%s, 등록일=%tF\n"</span><span class="o">,</span> 
					<span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span>
					<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getRegisterDateTime</span><span class="o">());</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
					<span class="s">"회원 정보: 아이디=%d, 이메일=%s, 이름=%s, 등록일=%s\n"</span><span class="o">,</span> 
					<span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span>
					<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> 
					<span class="n">dateTimeFormatter</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getRegisterDateTime</span><span class="o">()));</span>
		<span class="o">}</span>
	<span class="o">}</span>
  
 	<span class="nd">@Autowired</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDateFormatter</span><span class="o">(</span><span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
	<span class="o">}</span>

 <span class="c1">// ...</span>
</code></pre></div></div>

<p>dateTimeFormatter가 null인지 여부에 따라 날짜 형식을 바꿔 출력한다.<br />
즉 반드시 <code class="highlighter-rouge">setDateFormatter()</code>를 통해 의존 객체를 주입할 필요가 없다.<br />
하지만 <code class="highlighter-rouge">@Autowired</code>는 해당하는 빈이 존재하지 않으면 예외를 발생시킨다.</p>

<h3 id="autowiredrequired--false">@Autowired(required = false)</h3>

<p>이 경우 <code class="highlighter-rouge">@Autowired(required = false)</code> 설정으로 자동 주입 대상이 필수가 아님을 명시한다.<br />
이러면 매칭되는 빈이 없어도 예외가 발생하지 않고 자동 주입을 수행하지 않는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span><span class="o">(</span><span class="n">required</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDateFormatter</span><span class="o">(</span><span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="optional">Optional</h3>

<p>스프링 5부터는 required 속성 말고, Optional을 사용할 수도 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDateFormatter</span><span class="o">(</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">DateTimeFormatter</span><span class="o">&gt;</span> <span class="n">formatterOpt</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">formatterOpt</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="n">formatterOpt</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
   	<span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="nullable">@Nullable</h3>

<p>해당 어노테이션을 의존 주입 대상 파라미터에 붙이면 세터 메서드를 호출할 때 자동 주입할 빈이 존재할 경우 인자로 받고, 존재하지 않으면 null을 전달한다.<br />
이 어노테이션은 스프링이 제공하는 어노테이션이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDateFormatter</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>required 속성을 false로 할 때와 차이점?</strong></p>

<p>@Nullable 어노테이션을 사용하면 자동 주입할 빈이 존재하지 않아도 세터 메서드가 호출된다.<br />
@Autowired(required = false)의 경우 대상 빈이 존재하지 않을 경우 세터 메서드를 호출하지 않는다.</p>

<p>위의 세가지 방식은 메서드 뿐만 아니라 필드에도 동일하게 적용할 수 있다.</p>

<h3 id="생성자-초기화와-필수-여부-지정-방식-동작">생성자 초기화와 필수 여부 지정 방식 동작</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberPrinter</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">MemberPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">dateTimeFormatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">"yyyy년 MM월 dd일"</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="n">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">dateTimeFormatter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
					<span class="s">"회원 정보: 아이디=%d, 이메일=%s, 이름=%s, 등록일=%tF\n"</span><span class="o">,</span> 
					<span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span>
					<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getRegisterDateTime</span><span class="o">());</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
					<span class="s">"회원 정보: 아이디=%d, 이메일=%s, 이름=%s, 등록일=%s\n"</span><span class="o">,</span> 
					<span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span>
					<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> 
					<span class="n">dateTimeFormatter</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getRegisterDateTime</span><span class="o">()));</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="nd">@Autowired</span><span class="o">(</span><span class="n">required</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDateFormatter</span><span class="o">(</span><span class="n">DateTimeFormatter</span> <span class="n">dateTimeFormatter</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">dateTimeFormatter</span> <span class="o">=</span> <span class="n">dateTimeFormatter</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="autowiredrequired--false일-경우">@Autowired(required = false)일 경우</h4>

<ul>
  <li>dateTimeFormatter에 null을 할당하지 않는다. <code class="highlighter-rouge">setDateFormatter()</code> 가 호출되지 않기 때문이다.</li>
</ul>

<h4 id="nullable-1">@Nullable</h4>

<ul>
  <li>일치하는 빈이 없을 때 기본 생성자에서 초기화해주고 있어도, dateTimeFormatter에 null 값을 할당한다.</li>
</ul>

<hr />

<h2 id="자동-주입과-명시적-의존-주입-간의-관계">자동 주입과 명시적 의존 주입 간의 관계</h2>

	  ]]></description>
	</item>

	<item>
	  <title>📌 MVC 패턴</title>
	  <link>//mvc-pattern</link>
	  <author></author>
	  <pubDate>2021-05-26T19:18:00+09:00</pubDate>
	  <guid>//mvc-pattern</guid>
	  <description><![CDATA[
	     <h2 id="mvc-패턴">MVC 패턴</h2>

<ul>
  <li>디자인 패턴</li>
  <li>Model View Controller 3가지로 구분한 패턴</li>
  <li>유지보수가 편해지는 코드 구성 방식</li>
</ul>

<h2 id="웹-애플리케이션-아키텍쳐의-역사">웹 애플리케이션 아키텍쳐의 역사</h2>

<h3 id="jsp로-구성한-웹-애플리케이션의-아키텍쳐--모델1">(JSP로 구성한) 웹 애플리케이션의 아키텍쳐 : 모델1</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/6a9d8528-65ae-4e83-be32-c2d033b36fab/image.png" style="zoom:67%;" /></p>

<ul>
  <li>구성 : JSP + JavaBeand(Service)</li>
  <li>뷰와 로직이 섞임</li>
  <li>장점 : 구조가 단순</li>
  <li>단점 : 출력과 로직 코드가 섞여 유지보수가 어렵다.</li>
</ul>

<h3 id="jsp로-구성한-웹-애플리케이션의-아키텍쳐--모델2">(JSP로 구성한) 웹 애플리케이션의 아키텍쳐 : 모델2</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/07291db1-f256-4786-b4ac-7e9fe76049de/image.png" style="zoom:67%;" /></p>

<ul>
  <li>구성 : JavaBean(Service) + JSP + 서블릿</li>
  <li>MVC 구조</li>
  <li>장점 : 뷰와 로직이 분리되어 유지보수가 쉽다.</li>
  <li>단점 : 복잡하므로 작은 프로젝트에서는 오히려 과할 수 있다.</li>
</ul>

<hr />

<h3 id="mvc-흐름">MVC 흐름</h3>

<ol>
  <li>사용자는 원하는 기능을 처리하기 위한 모든 요청을 컨트롤러에 보낸다.</li>
  <li>컨트롤러는 모델을 사용하고, 모델은 알맞은 비즈니스 로직을 수행한다.</li>
  <li>컨트롤러는 가용자에게 보여줄 뷰를 선택한다.</li>
  <li>선택된 뷰는 사용자에게 알맞는 결과 화면을 보여준다. 이 때 사용자에게 보여줄 데이터는 컨트롤러를 통해서 전달받는다.</li>
</ol>

<h3 id="model">Model</h3>

<ul>
  <li>값과 기능을 가지고 있는 객체</li>
  <li>비즈니스 로직을 수행</li>
</ul>

<h3 id="view">View</h3>

<ul>
  <li>모델에 포함된 데이터의 시각화</li>
</ul>

<h3 id="controller">Controller</h3>

<ul>
  <li>모델 객체로의 데이터 흐름을 제어</li>
  <li>모델과 뷰의 중개자 역할</li>
  <li>뷰와 모델의 역할을 분리</li>
</ul>

<h3 id="why-mvc">Why MVC?</h3>

<ul>
  <li>각 컨포넌트의 코드 결합도를 낮출 수 있음</li>
  <li>코드의 재사용성을 높일 수 있음</li>
  <li>구현자들 간의 커뮤니케이션 효율성을 높일 수 있음</li>
</ul>

<hr />

<h2 id="mvc-많이-실수하는-부분들">MVC 많이 실수하는 부분들…</h2>

<h3 id="model에서-view의-접근-또는-역할-수행">Model에서 View의 접근 또는 역할 수행</h3>

<ul>
  <li>도메인에서 비즈니스 로직이 아닌 출력에 대한 로직은 별도로 분리하자
    <ul>
      <li>ex) toString()</li>
    </ul>
  </li>
</ul>

<h4 id="view에서-일어나는-과한-값-검증과-예외처리">View에서 일어나는 과한 값 검증과 예외처리</h4>

<ul>
  <li>View에서 검증을 하면 뒤의 로직은 신경쓰지 않아도 되니 편리하다고는 느낄 수 있음</li>
  <li>하지만 단일 책임 원칙을 위반함 (입력 채널이 달라질 경우 유효성 테크 로직도 옮겨야함)</li>
  <li>값 형식은 유효하지만, 도메인 모델에서 확인해야할 부분들은 생성자에서 체크
    <ul>
      <li>ex) 이름은 몇 글자 이상이어야 한다.</li>
    </ul>
  </li>
</ul>

<h4 id="view에서-일어나는-비즈니스-로직">View에서 일어나는 비즈니스 로직</h4>

<ul>
  <li>모델을 생성하거나 모델끼리 연산을 하는 로직</li>
</ul>

<h4 id="controller는-최대한-가볍게">Controller는 최대한 가볍게</h4>

<ul>
  <li>로직은 최대한 배제하고 model과 view의 연결 역할만 하도록 구현</li>
</ul>

<h3 id="service의-등장-지금은-이런게-있구나-정도만-">Service의 등장 (지금은 이런게 있구나 정도만 )</h3>

<h4 id="controller에서-중복이-발생한다">Controller에서 중복이 발생한다.</h4>

<ul>
  <li>별도의 객체로 분리</li>
  <li>별도의 메서드로 분이</li>
</ul>

<p>이러다 서비스 레이어가 추가되었다!</p>

<h3 id="service란">Service란?</h3>

<ul>
  <li>비즈니스 로직을 수행하는 메서드를 가지고 있는 객체</li>
  <li>비즈니스 메서드를 별도의 서비스 객체에서 구현하도록 하고 컨트롤러는 서비스 객체를 사용</li>
  <li>하나의 트랜잭션을 가짐</li>
</ul>

<hr />

<h2 id="mvc를-지키면서-코딩하는-방법">MVC를 지키면서 코딩하는 방법</h2>

<h3 id="model은-controller와-view에-의존하지-않아야-한다">Model은 Controller와 View에 의존하지 않아야 한다.</h3>

<ul>
  <li>Model 내부에 Controller와 View에 관련된 코드가 있으면 안됨</li>
  <li>model은 데이터와 관련된 코드이니 언제든지 정제된 코드만 꺼내쓸 수 있도록</li>
</ul>

<h3 id="view는-model에만-의존해야하고-controller에-의존하면-안된다">View는 Model에만 의존해야하고, Controller에 의존하면 안된다.</h3>

<ul>
  <li>View 내부에 Model의 코드만 있을 수 있고, Controller의 코드가 있으면 안됨</li>
</ul>

<h3 id="vuew가-model로부터-데이터를-받을-때는-사용자마다-다르게-보여주어야-하는-데이터에-대해서만-받아야-함">Vuew가 Model로부터 데이터를 받을 때는 사용자마다 다르게 보여주어야 하는 데이터에 대해서만 받아야 함</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/c0d6e97c-ad21-4276-be29-6a32d23e6544/image.png" style="zoom: 33%;" /></p>

<p>빨간 부분이 사용자마다 다르게 보여져야하는 부분이다.</p>

<p>또는 자동차 경주 게임에서 <code class="highlighter-rouge">-</code>(대시) 같은 경우</p>

<p><strong>View는 사용자한테 보이는 UI와 모델로부터 받은 데이터가 합쳐지는 부분이다.</strong></p>

<h3 id="controller는-model과-view에-의존해도-된다">Controller는 Model과 View에 의존해도 된다.</h3>

<p><img src="https://images.velog.io/images/new_wisdom/post/e1c75904-1aee-4eca-b71d-14d23f3d25cd/image.png" style="zoom:33%;" /></p>

<ul>
  <li>Controller 내부에는 Model과 View의 코드가 있을 수 있다.</li>
</ul>

<h3 id="view가-model로부터-데이터를-받을-때-반드시-controller에서-받아야-한다">View가 Model로부터 데이터를 받을 때, 반드시 Controller에서 받아야 한다.</h3>

<hr />

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=ogaXW6KPc8I">[10분 테코톡] 🧀 제리의 MVC 패턴</a></li>
  <li><a href="https://www.youtube.com/watch?v=uoVNJkyXX0I&amp;t=161s">[10분 테코톡] 👩🏻‍💻👨🏻‍💻해리&amp;션의 MVC 패턴</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>📌 DTO와 VO</title>
	  <link>//dto-and-vo</link>
	  <author></author>
	  <pubDate>2021-05-26T19:18:00+09:00</pubDate>
	  <guid>//dto-and-vo</guid>
	  <description><![CDATA[
	     <h2 id="dto">DTO</h2>

<ul>
  <li>Data Transfer Object (데이터 전송 객체)</li>
  <li>계층 간 데이터 교환을 위해 사용하는 객체</li>
  <li>로직을 갖고 있지 않은 순수한 데이터 객체</li>
  <li>데이터를 전송하는 바구니</li>
  <li>getter/setter 메서드만을 가짐</li>
</ul>

<hr />

<h2 id="vo">VO</h2>

<ul>
  <li>value Object (값 객체)</li>
  <li>값 그 자체를 표현하는 객체</li>
  <li>서로 다른 이름을 가진 VO의 인스턴스가 모든 속성 값이 같다면 같은 객체</li>
  <li>equals / hashCode를 오버라이드 필수</li>
  <li>객체의 불변성을 보장</li>
  <li>로직을 포함할 수 있음</li>
</ul>

<hr />

<h2 id="dto-vs-vo">DTO VS VO</h2>

<p>웹 개발에서 사용하는 VO는 사실 DTO이다.<br />
혼동의 원인은..?</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/59d6ae10-7b6d-4ab6-b99a-10266f2627ff/image.png" style="zoom:50%;" /></p>

<p>이 책에서 getter와 setter가 있고, 데이터 전송을 위해 사용하는 객체는 VO라고 정의해버렸다.<br />
(후에는 변경되었긴했지만)</p>

<h4 id="dto를-vo처럼-불변-객체로-사용하면-얻을-수-있는-이점">DTO를 VO처럼 불변 객체로 사용하면 얻을 수 있는 이점?</h4>

<p>DTO가 전송하고자 하는 데이터가 전송 과정 중 변조되지 않음을 보장할 수 있음</p>

<hr />

<h2 id="entity">Entity</h2>

<ul>
  <li>실제 DB의 테이블과 매핑되는 클래스</li>
  <li>id로 구분</li>
  <li>로직을 포함할 수 있음</li>
</ul>

<h4 id="entity를-dto대신-사용할-수-있지-않을까">Entity를 DTO대신 사용할 수 있지 않을까?</h4>

<p>사용할수는 있지만, <br />
View에서 표현하는 속성값들이 요청에 따라 계속 달라질 수 있는데,<br />
 그 때마다 Entity의 속성값을 변경하면 영속성 모델을 표현한 Entity의 순수성이 모호해지기 때문에 Controller에 쓸 DTO와 Entity 클래스는 분리하는 것이 좋다.</p>

<hr />

<h2 id="정리">정리</h2>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>DTO</th>
      <th>VO</th>
      <th>Entity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>용도</td>
      <td>레이어 간의 데이터 전송</td>
      <td>의미 있는 값을 표현</td>
      <td>DB 테이블과 매핑되는 클래스</td>
    </tr>
    <tr>
      <td>가변 / 불변</td>
      <td>가변 객체</td>
      <td>불변 객체</td>
      <td>가변 객체</td>
    </tr>
    <tr>
      <td>로직 포함 여부</td>
      <td>로직을 포함할 수 없음</td>
      <td>로직을 포함할 수 있음`</td>
      <td>로직을 포함할 수 없음</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="추가----dto를-어디-계층까지-사용하여야-할까">추가 -  DTO를 어디 계층까지 사용하여야 할까</h2>

<h3 id="서비스-레이어가-가장-적합하다고-생각한다">서비스 레이어가 가장 적합하다고 생각한다</h3>

<h4 id="service-레이어의-정의">Service 레이어의 정의</h4>

<ul>
  <li>어플리케이션의 경계를 정의하고 비즈니스 로직 등 도메인을 캡슐화하는 역할</li>
  <li>즉 도메인을 보호</li>
  <li>도메인을 표현 계층에서 사용할 경우 결합도가 증가하여 도메인 변경이 Controller의 변경을 촉발한다.</li>
  <li>이는 유지보수의 문제로도 이어질 수 있다.</li>
</ul>

<h4 id="controller가-dto를-생성하면-생기는-문제">Controller가 DTO를 생성하면 생기는 문제</h4>

<ul>
  <li>Controller가 DTO를 완벽하게 도메인에서 객체로 구성한 뒤 서비스에게 넘겨주려면 복잡한 경우 Controller가 여러 서비스나 Repository에 의존하게 된다.</li>
  <li>Controller가 여러 도메인 객체들의 정보를 조합해서 DTO를 생성해야하는 경우 결국 Service 로직이 Controller에 포함되게 된다.</li>
</ul>

<hr />

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=J_Dr6R0Ov8E&amp;t=4s">[10분 테코톡] 🎼라흐의 DTO vs VO</a></li>
  <li><a href="https://woowacourse.github.io/javable/post/2021-04-25-dto-layer-scope/">DTO의 사용 범위에 대하여</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>📋 3. 스프링 DI</title>
	  <link>//springbasic</link>
	  <author></author>
	  <pubDate>2021-05-26T19:18:00+09:00</pubDate>
	  <guid>//springbasic</guid>
	  <description><![CDATA[
	     <h2 id="스프링은-객체-컨테이너">스프링은 객체 컨테이너</h2>

<h3 id="beanfactory">BeanFactory</h3>

<ul>
  <li>객체 생성과 검색에 대한 기능 정의</li>
  <li><code class="highlighter-rouge">getBean()</code> : 생성된 객체를 검색하는데 필요한 메서드</li>
  <li>객체 검색 이외에도 싱글톤인지 프로토타입 빈인지 확인하는 기능도 있음</li>
</ul>

<h3 id="annotationcontext">AnnotationContext</h3>

<ul>
  <li>메시지, profile, 환경 변수 등을 처리할 수 있는 기능을 추가로 쩡의</li>
</ul>

<hr />

<h2 id="의존이란">의존이란?</h2>

<h2 id="di를-통한-의존-처리">DI를 통한 의존 처리</h2>

<h3 id="의존이란-1">의존이란?</h3>

<ul>
  <li>한 클래스가 다른 클래스의 메서드를 실행할 때 <strong>의존</strong>한다고 표현</li>
  <li>
    <p>변경에 의해 영향을 받는 관계를 의미</p>
  </li>
  <li>DI는 의존하는 객체를 직접 생성하지 않고, 의존 객체를 주입받는 방식을 사용</li>
  <li>DI를 통해 객체를 주입하면 유지보수성이 더 올라간다.</li>
</ul>

<h2 id="스프링의-di-설정">스프링의 DI 설정</h2>

<ul>
  <li>스프링은 DI를 이용해서 객체를 서로 연결해주는 조립기이다.
    <ul>
      <li>특정 타입의 클래스만 생성하는 조립기가 아닌 범용 조립기이다.</li>
    </ul>
  </li>
</ul>

<p><strong>설정 클래스</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppCtx</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">MemberDao</span> <span class="nf">memberDao</span><span class="o">()</span> <span class="o">{</span>
    	<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberDao</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">MemberRegisterService</span> <span class="nf">memberRegSvc</span><span class="o">()</span> <span class="o">{</span>
    	<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberRegisterService</span><span class="o">(</span><span class="n">memberDao</span><span class="o">());</span> <span class="c1">// memberDao()	가 생성한 객체를 주입</span>
    <span class="o">}</span>
    
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">ChangePasswordService</span> <span class="nf">changePwSvc</span><span class="o">()</span> <span class="o">{</span>
    	<span class="n">ChangePasswordService</span> <span class="n">pwsSvc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChangePasswordService</span><span class="o">();</span>
        <span class="n">pwdSvc</span><span class="o">.</span><span class="na">setMemberDao</span><span class="o">(</span><span class="n">memberDao</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">pwdSvc</span><span class="o">;</span>
    
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">@Configuration</code> : 스프링 설정 클래스</li>
  <li><code class="highlighter-rouge">@Bean</code> : 해당 메서드가 생성한 객체를 스프링 빈으로 설정
    <ul>
      <li>메서드 이름을 빈 객체의 이름으로 사용</li>
    </ul>
  </li>
</ul>

<p>설정 클래스만 만들어서 끝나는 것이 아닌, 설정 클래스로 컨테이너를 생성해야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="n">AppCtx</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  
<span class="c1">// ...</span>
<span class="n">MemberRegisterService</span> <span class="n">regSvc</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"memberRegSvc"</span><span class="o">,</span> <span class="n">MemberRegisterService</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</code></pre></div></div>

<ul>
  <li>컨테이너를 생성하면 <code class="highlighter-rouge">getBean()</code> 를 이용해 사용할 객체를 구할 수 있음</li>
  <li>스프링 컨테이너 <code class="highlighter-rouge">ctx</code> 로터 이름이 “memberRegSvc”인 빈 객체를 구함</li>
</ul>

<h3 id="di-방식---생성자-방식">DI 방식 - 생성자 방식</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StationService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">StationDao</span> <span class="n">stationDao</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">StationService</span><span class="o">(</span><span class="n">StationDao</span> <span class="n">stationDao</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">stationDao</span> <span class="o">=</span> <span class="n">stationDao</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="di-방식---생성자-방식-1">DI 방식 - 생성자 방식</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StationService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">StationDao</span> <span class="n">stationDao</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setStationDao</span><span class="o">(</span><span class="n">StationDao</span> <span class="n">stationDao</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">stationDao</span> <span class="o">=</span> <span class="n">stationDao</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<hr />

<h2 id="configuration-설정-클래스의-bean-설정과-싱글톤">@Configuration 설정 클래스의 @Bean 설정과 싱글톤</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppCtx</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">MemberDao</span> <span class="nf">memberDao</span><span class="o">()</span> <span class="o">{</span>
    	<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberDao</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">MemberRegisterService</span> <span class="nf">memberRegSvc</span><span class="o">()</span> <span class="o">{</span>
    	<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberRegisterService</span><span class="o">(</span><span class="n">memberDao</span><span class="o">());</span> <span class="c1">// memberDao()	가 생성한 객체를 주입</span>
    <span class="o">}</span>
    
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">ChangePasswordService</span> <span class="nf">changePwSvc</span><span class="o">()</span> <span class="o">{</span>
    	<span class="n">ChangePasswordService</span> <span class="n">pwsSvc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChangePasswordService</span><span class="o">();</span>
        <span class="n">pwdSvc</span><span class="o">.</span><span class="na">setMemberDao</span><span class="o">(</span><span class="n">memberDao</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">pwdSvc</span><span class="o">;</span>
    
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><code class="highlighter-rouge">memberDao()</code>는 매번 새로운 MemberDao 객체를 생성해서 반환한다.</li>
</ul>

<p><strong>그러면 <code class="highlighter-rouge">memberRegSvc()</code> 가 반환하는 객체와 <code class="highlighter-rouge">changePwSvc()</code>가 반환하는 객체는 서로 다른 MemberDao 객체를 사용하는 것인가?</strong></p>

<p>🙅‍♀️ 스프링 컨테이너가 생성한 빈은 싱글톤 객체이다.<br />
<code class="highlighter-rouge">@Bean</code>이 붙은 메서드에 대해 한 개의 객체만 생성하고 이를 보관했다가, 동일한 객체를 반환한다.</p>

<hr />

<h2 id="두-개-이상의-설정-파일-사용하기">두 개 이상의 설정 파일 사용하기</h2>

<p>스프링은 한 개 이상의 설정 파일을 이용해서 컨테이너를 생성할 수 있다.</p>

<h3 id="configuration-autowired">@Configuration, @Autowired</h3>

<p><strong>AppConf1</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConf1</span> <span class="o">{</span>

	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberDao</span> <span class="nf">memberDao</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberDao</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberPrinter</span> <span class="nf">memberPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberPrinter</span><span class="o">();</span>
	<span class="o">}</span>
	
<span class="o">}</span>
</code></pre></div></div>

<p><strong>AppConf2</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConf2</span> <span class="o">{</span>
	<span class="nd">@Autowired</span>
	<span class="kd">private</span> <span class="n">MemberDao</span> <span class="n">memberDao</span><span class="o">;</span>
	<span class="nd">@Autowired</span>
	<span class="kd">private</span> <span class="n">MemberPrinter</span> <span class="n">memberPrinter</span><span class="o">;</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberRegisterService</span> <span class="nf">memberRegSvc</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberRegisterService</span><span class="o">(</span><span class="n">memberDao</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">ChangePasswordService</span> <span class="nf">changePwdSvc</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">ChangePasswordService</span> <span class="n">pwdSvc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChangePasswordService</span><span class="o">();</span>
		<span class="n">pwdSvc</span><span class="o">.</span><span class="na">setMemberDao</span><span class="o">(</span><span class="n">memberDao</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">pwdSvc</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberListPrinter</span> <span class="nf">listPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberListPrinter</span><span class="o">(</span><span class="n">memberDao</span><span class="o">,</span> <span class="n">memberPrinter</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberInfoPrinter</span> <span class="nf">infoPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">MemberInfoPrinter</span> <span class="n">infoPrinter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MemberInfoPrinter</span><span class="o">();</span>
		<span class="n">infoPrinter</span><span class="o">.</span><span class="na">setMemberDao</span><span class="o">(</span><span class="n">memberDao</span><span class="o">);</span>
		<span class="n">infoPrinter</span><span class="o">.</span><span class="na">setPrinter</span><span class="o">(</span><span class="n">memberPrinter</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">infoPrinter</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">VersionPrinter</span> <span class="nf">versionPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">VersionPrinter</span> <span class="n">versionPrinter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VersionPrinter</span><span class="o">();</span>
		<span class="n">versionPrinter</span><span class="o">.</span><span class="na">setMajorVersion</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
		<span class="n">versionPrinter</span><span class="o">.</span><span class="na">setMinorVersion</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">versionPrinter</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">@AutoWired</code> : 스프링의 자동 주입 기능. 스프링 설정 클래스 필드에 해당 어노테이션을 붙이면 해당 타입 빈을 찾아서 필드에 할당한다.
    <ul>
      <li>AppConf2의 memberDao 필드에는 AppConf1 클래스에서 설정한 빈이 할당된다.</li>
    </ul>
  </li>
  <li>스프링 컨테이너는 AppConf2 객체를 빈으로 등록하고 <code class="highlighter-rouge">@AutoWired</code> 가 붙은 대상에 대해 알맞은 빈을 자동으로 주입한다.</li>
</ul>

<p><strong>설정 클래스가 여러개일 때 스프링 컨테이너를 생성하는 방법은?</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="n">AppConf1</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">AppConf2</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</code></pre></div></div>

<ul>
  <li>AnnotationConfigApplicationContext의 생성자의 인자는 가변 인자이다.</li>
</ul>

<h3 id="import-어노테이션-사용">@Import 어노테이션 사용</h3>

<ul>
  <li>함께 사용할 설정 클래스를 지정</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@Import</span><span class="o">({</span><span class="n">AppConf2</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfImport</span> <span class="o">{</span>

	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberDao</span> <span class="nf">memberDao</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberDao</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="n">MemberPrinter</span> <span class="nf">memberPrinter</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberPrinter</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>지정한 클래스도 함께 사용하기 때문에 스프링 컨테이너를 생성할 때 AppConfi2를 지정할 필요가 없다.</li>
</ul>

<hr />

<h2 id="getbean">getBean()</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VersionPrinter</span> <span class="n">versionPrinter</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"versionPrinter"</span><span class="o">,</span> <span class="n">VersionPrinter</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</code></pre></div></div>

<ul>
  <li>첫번째 인자는 빈의 이름</li>
  <li>두번째 인자는 빈의 타입</li>
  <li>빈의 이름을 지정하지 않고 타입만으로 빈을 구할 수도 있다.
    <ul>
      <li>대신 해당 타입의 빈 객체가 한 개만 존재해야한다.</li>
    </ul>
  </li>
</ul>

<p><strong>주입 대상 객체를 모두 빈 객체로 설정해야하나?</strong></p>

<p>🙅‍♀️ 스프링 컨테이너가 객체를 관리하는지 여부만 다를 뿐이다.<br />
참고로 스프링 컨테이너는 자동 주입, 라이프사이클 관리 등 객체 생성 외에도 객체 관리를 위한 다양한 기능을 제공한다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>📌 전략패턴</title>
	  <link>//ocp-stretegy-pattern</link>
	  <author></author>
	  <pubDate>2021-05-24T19:18:00+09:00</pubDate>
	  <guid>//ocp-stretegy-pattern</guid>
	  <description><![CDATA[
	     <h3 id="if---else의-문제점">if - else의 문제점</h3>

<p><strong>example</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculate</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">isFirstGuest</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isLastGuest</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">Item</span> <span class="n">item</span> <span class="o">:</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isFirstGuest</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.9</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">item</span><span class="o">.</span><span class="na">isFresh</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.8</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">isFirstGuest</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.8</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="기능이-추가될-경우">기능이 추가될 경우</h4>

<ul>
  <li>새로운 조건문을 직접 추가해주어야 한다.</li>
  <li>때문에 추가되는 기능들이 많아질 수롣 코드 블럭도 점점 증가한다.</li>
  <li>이럴 경우 유지보수성이 떨어진다.</li>
</ul>

<h4 id="누락될-위험">누락될 위험</h4>

<ul>
  <li>(안 좋은 예시이지만) 같은 기능을 하는 로직을 서로 다른 클래스에서 사용하기 위해 복붙을 했을 경우, 한 쪽의 기능이 변경되면 이를 복붙한 모든 클래스를 전부 수정해주어야 한다.</li>
</ul>

<p><strong>때문에 if-else를 사용하면 유지보수가 어렵다.</strong></p>

<hr />

<h2 id="ocp---open-close-principle-개방-폐쇄의-원칙">OCP - Open Close Principle (개방 폐쇄의 원칙)</h2>

<p>소프트웨어 구성요소(컴포넌트, 클래스, 모듈, 함수)는 <strong>확장에 대해서는 개방되어야 하지만 변경에 대해서는 폐쇄</strong>되어야 한다.<br />
기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.<br />
기존 코드의 변경이 작으며, 확장이 쉽다는 장점이 있다.</p>

<h3 id="적용-방법">적용 방법</h3>

<ul>
  <li>상속(is-a)</li>
  <li>컴포지션(has-a)</li>
</ul>

<h3 id="컴포지션">컴포지션</h3>

<h4 id="변경확장될-것과-변하지-않을-것을-구분한다">변경(확장)될 것과 변하지 않을 것을 구분한다.</h4>

<h4 id="이-두-모듈이-만나는-지점에-인터페이스를-정의한다">이 두 모듈이 만나는 지점에 인터페이스를 정의한다.</h4>

<h4 id="구현에-의존하기보다-정의한-인터페이스에-의존하도록-코드를-작성한다">구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성한다.</h4>

<h3 id="예시">예시</h3>

<ul>
  <li>List와 ArrayList의 관계
    <ul>
      <li>타입 선언은 List이지만 인스턴스를 생성할 때는 그 구현체인 ArrayList로 생성한다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="전략-패턴">전략 패턴</h2>

<ul>
  <li>디자인 패턴 중 가장 많이 쓰임
    <ul>
      <li><strong>디자인 패턴이란?</strong> (소프트웨어) 디자인 + (공통적으로 마주치는 문제를 해결하는 방법의) 패턴</li>
    </ul>
  </li>
  <li>동적으로 전략 수정 가능</li>
  <li>행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 함</li>
  <li>새로운 기능의 추가가 기존 코드에 영향을 미치지 못하게 하므로 OCP를 만족</li>
  <li>기존 코드 변경없이 행위를 자유롭게 바꿀 수 있게 해주는 OCP를 준수한 디자인 패턴</li>
</ul>

<p><strong>➕ GoF의 디자인 패턴</strong>에서의 전략패턴</p>

<ul>
  <li>동일 계열의 알고리즘군을 정의하고 (walk, run, fly, rocket)</li>
  <li>각 알고리즘을 캡슐화하며(MoveStrategy)</li>
  <li>이들을 상호교환이 가능하도록 만든다.</li>
</ul>

<h4 id="전략이란">전략이란?</h4>

<p>어떤 목적을 달성하기 위해 일을 수행하는 방식.<br />
비즈니스 규칙, 문제를 해결하는 알고리즘 등 (Random, Reverse, Nothing)</p>

<h3 id="구성">구성</h3>

<h4 id="context">Context</h4>

<ul>
  <li>전략 패턴을 이용하는 역할을 수행</li>
  <li>필요에 따라 동적으로 구체적인 전략을 바꿀 수 있도록 함 (setter 또는 DI)</li>
</ul>

<h4 id="strategy">Strategy</h4>

<ul>
  <li>인터페이스나 추상 클래스로 외부에서 동일한 방식으로 알고리즘을 호출하는 방법 명시</li>
</ul>

<h4 id="concreatestrategy">ConcreateStrategy</h4>

<ul>
  <li>전략패턴에서 명시한 알고리즘을 실제로 구현한 클래스</li>
</ul>

<h3 id="example">Example</h3>

<p><strong>배민 로봇 이동 전략 예시</strong></p>

<ul>
  <li>Walk</li>
  <li>Run</li>
  <li>Fly</li>
  <li>Rocket</li>
</ul>

<p><strong>초기 배달 로봇</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Robot</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"배달 로봇"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"걸어서 배달합니당."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>그런데 이제 달리는 로봇도 추가하게 되었다면,</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunningRobot</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"배달 로봇"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"뛰어서 배달합니당."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이후에 날으는 로봇, 로켓으로 배달하는 로봇이 생기는 경우를 생각해보자.<br />
이를 먼저 상속으로 해결하는 경우, 아래와 같이 구현할 수 있다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/559aed96-a6f0-45b8-8c0a-2812d05e29b5/image.png" alt="" /></p>

<p>그런데 여기서 로봇에 온도 조절 기능을 추가할 경우, 아래와 같이 구현할 수 있다.</p>

<p><img src="https://images.velog.io/images/new_wisdom/post/944eed9b-c7a4-476d-9221-4f416fe5a0eb/image.png" alt="" /></p>

<h4 id="-문제점">🤔 문제점?</h4>

<ul>
  <li><strong>메서드 수정이 어렵다.</strong>
    <ul>
      <li>“걸어서 배달하는 로봇”이 “빠르게 걸어서 배달합니다”로 변할 경우 모든 클래스를 순회하면서 메서드들을 수정해주어야 한다.</li>
    </ul>
  </li>
  <li><strong>새로운 기능 추가가 어렵다.</strong>
    <ul>
      <li>한국어, 영어, 중국어를 말하는 기능이 추가된다면 추상 클래스에 말하기 기능이 추가될 것이고, 이를 상속받는 클래스에 기능에 따라 다른 각각의 메서드를 구현해주어야 한다.</li>
    </ul>
  </li>
</ul>

<p><strong>이를 해결하는 것이 바로 전략패턴이다!</strong></p>

<p><img src="https://images.velog.io/images/new_wisdom/post/71c8e746-2de7-4fbc-9e1a-300ff0229c65/image.png" alt="" /></p>

<ul>
  <li>이동전략 : 걷기, 달리기, 날기 등의 로봇의 행위를 정의한다.</li>
  <li>온도 전략 : cold, warm, hot등을 정의한다.</li>
</ul>

<p>로봇을 생성할 때 각각의 전략을 주입해주어 로봇은 전략의 행위를 실행하게 된다.</p>

<p><strong>이렇게 되면 문제점이 어떻게 해결될까?</strong></p>

<ul>
  <li><strong>메서드 수정이 용이하다.</strong>
    <ul>
      <li>“걸어서 배달하는 로봇”이 “빠르게 걸어서 배달합니다”로 변할 경우 walk 부분만 변경해주면 된다.</li>
    </ul>
  </li>
  <li>새로운 기능 추가가 용이하다.
    <ul>
      <li>한국어, 영어, 중국어를 말하는 기능이 추가된다면 이에 따른 새로운 전략의 행위를 정의해주고, 로봇을 생성할 때 전략을 함께 주입해주면 된다.</li>
    </ul>
  </li>
  <li>만약 이동방식이 도중에 변경된다면?
    <ul>
      <li>setter등을 통해 객체 생성 후 전략을 변경할 수 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="jdk에서의-전략패턴">JDK에서의 전략패턴</h3>

<h4 id="comparator">Comparator</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">T</span> <span class="n">o1</span><span class="o">,</span> <span class="n">T</span> <span class="n">o2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Comparator가 전략이고 개발자마다 custom하게 정의한 Comparator구현을 <code class="highlighter-rouge">sort()</code>라는 컨텍스트에서 사용하고 있다.<br />
개발자는 상황에 맞게 비교 전략을 구현할 수 있게 하여 기존 코드의 수정없이 확장을 이룰 수 있다.</p>

<hr />

<h3 id="참고-자료">참고 자료</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=vNsZXC3VgUA&amp;t=24s">[10분 테코톡] 📣 완태의 전략패턴</a></li>
  <li>[<a href="https://www.youtube.com/watch?v=90ZDvHl8ROE">10분 테코톡] 👾베디의 OCP와 전략패턴</a></li>
</ul>


	  ]]></description>
	</item>


</channel>
</rss>
